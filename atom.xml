<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://flyingchase.github.io</id>
    <title>flyingchase</title>
    <updated>2021-09-03T03:05:41.739Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://flyingchase.github.io"/>
    <link rel="self" href="https://flyingchase.github.io/atom.xml"/>
    <subtitle>记录成长的脚印</subtitle>
    <logo>https://flyingchase.github.io/images/avatar.png</logo>
    <icon>https://flyingchase.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, flyingchase</rights>
    <entry>
        <title type="html"><![CDATA[Go Concurrency]]></title>
        <id>https://flyingchase.github.io/post/go-concurrency/</id>
        <link href="https://flyingchase.github.io/post/go-concurrency/">
        </link>
        <updated>2021-09-03T03:05:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="concurrency">Concurrency</h2>
<ul>
<li>通过通信来共享而非通过共享来通信</li>
<li>goroutine 运行在相同的地址空间</li>
</ul>
<h4 id="channel">channel</h4>
<ul>
<li>
<p>channel 必须使用 make 创建并定义发送到 channel 的类型</p>
</li>
<li>
<p>cap 可以读取 channel 的缓存容量</p>
<ul>
<li>
<pre><code class="language-go">ch:=make(chan int) // 定义同时规定发送到 chan 的类型
v:=1
ch&lt;-v 	// 将 v 发送到 chan
w:=&lt;-ch	// 从 ch中读取并赋值给 w
</code></pre>
</li>
</ul>
</li>
<li>
<p>默认无缓存chan 接受和发送是阻塞的  除非另外一端准备好</p>
<ul>
<li>
<p><code>value:&lt;-c</code> 读取会被阻塞 直到有数据接受</p>
</li>
<li>
<p><code>ch&lt;-5</code> 发送会被阻塞 直到有被读取</p>
</li>
<li>
<pre><code class="language-go">func sum(a []int, c chan int)  {
   total:=0
   for _,v:=range a{
      total+=v
   }
   c&lt;-total

}
func main() {
   a:=[...]int {1, 2, 3,4,5,6,7,8,9,0}
   c:=make(chan int)
   go sum(a[:len(a)/2],c)
   go sum(a[len(a)/2:],c)
   x,y:=&lt;-c,&lt;-c
   fmt.Println(x,y,x+y)
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>Buffer channel 带缓存的 channel</p>
<ul>
<li>
<p><code>ch；=make(chan type,cap)</code> 在 cap 内的读写是无阻塞的 超过 cap 时候需要等待其他 goroutine 从 channel 中读取元素 释放空间</p>
</li>
<li>
<p><code>for i:=rang c</code> 可以不断读取 channel 直到 channel 被显示关闭</p>
</li>
<li>
<p><code>close</code>关闭 channel 无法发送数据 但可以在消费方通过<code>v,ok:=c;ok</code><em>断言</em>来测试是否关闭 channel</p>
<ul>
<li>在生产者方关闭 channle  在消费者方容易产生 panic</li>
<li>结束 range 循环/无数据需要发送时候关闭 channel 才使用 close显式关闭</li>
</ul>
</li>
<li>
<pre><code class="language-go">func fibonacc(n int, c chan int)  {
   x,y:=1,1
   for i:=0;i&lt;n;i++ {
      c&lt;-x
      x,y=y,x+y
   }
   close(c)	// 显示关闭 channel
}
func main() {
   c:=make(chan int, 10)
   go fibonacc(cap(c),c)
   for i:=range c {
      fmt.Println(i)
   }
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>多 channel 下 <em>select</em></p>
<ul>
<li>
<p>select 关键字监听 channel 上的数据流动</p>
</li>
<li>
<p>默认是阻塞的  只有监听的 channel 上数据流动才运行  多个 channel 准备好时select 随机选择执行</p>
</li>
<li>
<p>类似 switch 有 <code>default</code>   可设置超时来退出循环</p>
</li>
<li>
<pre><code class="language-go">func fibonacc(c, quit chan int) {
   x, y := 1, 1
   for {
      select {		// 类似 switch  监听 channel 上的数据流动
      case c &lt;- x:
         x, y  = y, x+y
      case &lt;-quit:
         fmt.Println(&quot;quit&quot;)
         return
      case &lt;-time.After(5*time.Second) // 阻塞超过5 s情况
          fmpl(&quot;timeOut&quot;)
          break;
      }
   }
}

func main() {
   c := make(chan int)
   quit:=make(chan int)
   go func() {
      for i := 0; i &lt; 10; i++ {
         fmt.Println(&lt;-c)
      }
      quit&lt;-0
   }()
   fibonacc(c,quit)
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><code>Goexit</code></p>
<ul>
<li>退出当前 Goroutine 但defer 仍调用</li>
</ul>
</li>
<li>
<p><code>Gosched</code></p>
<ul>
<li>让出 goRoutine 权限</li>
</ul>
</li>
<li>
<p><code>NumCPU</code> <code>NumGoroutine</code></p>
<ul>
<li>返回 cpu数目</li>
<li>返回执行和排队的任务总数</li>
</ul>
</li>
<li>
<p><code>GOMAXPROCS</code></p>
<ul>
<li>并行计算的 cpu 核数最大值 返回之前的核数值</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GoLang 语法入门笔记]]></title>
        <id>https://flyingchase.github.io/post/golang-yu-fa-ru-men-bi-ji/</id>
        <link href="https://flyingchase.github.io/post/golang-yu-fa-ru-men-bi-ji/">
        </link>
        <updated>2021-08-30T07:14:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="golang语法">GoLang语法</h1>
<h3 id="10-引入">1.0 引入</h3>
<pre><code class="language-go">//firt-in-go.go
package main
import &quot;fmt&quot;

func main(){
  fmt.println(&quot;firt-print-in-go\n&quot;)
    // println
}
</code></pre>
<ul>
<li>
<p>首行包名必须存在，Go通过包管理命名空间</p>
</li>
<li>
<p><code>import</code>为引入外包；<code>fmt</code>为标准输出输出包；</p>
</li>
<li>
<p><code>func</code>为函数定义的关键字；</p>
</li>
</ul>
<p><strong>Go语言特征：</strong></p>
<ul>
<li>默认UTF-8编码；</li>
<li>标志符区分大小写；</li>
<li>语句结尾 <code>;</code>可省略；</li>
<li><em>函数{必须在函数开头同一行；</em></li>
<li>调用包中方法采用 <code>.</code>访问符；</li>
<li>mian函数包名需为main；</li>
<li>强类型的静态编译语言</li>
</ul>
<p><strong>格式化输出：</strong></p>
<pre><code class="language-go">%d          十进制整数
%x, %o, %b  十六进制，八进制，二进制整数。
%f, %g, %e  浮点数： 3.141593 3.141592653589793 3.141593e+00
%t          布尔：true或false
%c          字符（rune） (Unicode码点)
%s          字符串
%q          带双引号的字符串&quot;abc&quot;或带单引号的字符'c'
%v          变量的自然形式（natural format）
%T          变量的类型
%%          字面上的百分号标志（无操作数）
</code></pre>
<p><strong>各项零值：</strong></p>
<pre><code class="language-go">int     0
int8    0
int32   0
int64   0
uint    0x0
rune    0 //rune的实际类型是 int32
byte    0x0 // byte的实际类型是 uint8
float32 0 //长度为 4 byte
float64 0 //长度为 8 byte
bool    false
string  &quot;&quot;
</code></pre>
<p><strong>Notion:</strong></p>
<ul>
<li><code>,</code>操作符没有 故而多个操作使用平行赋值 <code>i,j=1,1</code></li>
<li>查看变量类型 <code>fmt.println(&quot;type is&quot;,reflect.typeOf(var name))</code>
<ul>
<li><code>fmt.Printf(&quot;%T&quot;,val)</code></li>
</ul>
</li>
</ul>
<h3 id="11-token-词法分析">1.1 Token 词法分析</h3>
<img src="/Users/qlzhou/Library/Application Support/typora-user-images/image-20201215121911426.png" alt="image-20201215121911426" style="zoom:40%;" />
<h3 id="12-标志符">1.2 标志符</h3>
<ul>
<li>
<p>规则：</p>
<p>​	字母和下划线开头，区分大小写；</p>
</li>
</ul>
<p>**数据类型标志符：**20</p>
<ul>
<li>
<p>数值：</p>
<p>byte int int8 int16 int32 int64 uint uint8 uint16 uint64 uinprt（整数）</p>
<p>​				不同类型之间必须强制类型转换；</p>
<p>​				支持算术/位运算 结果仍为整型；</p>
<p>float32 float64（浮点数）</p>
<p>​				默认为float64 <code>var a:=1.0</code></p>
<p>complex64 complex128（复数）</p>
<p>​				<code>complex real image (构造 返回实部、返回虚部)</code></p>
<p>​</p>
<pre><code class="language-go">var v complex64=3.14+5i
v1:=3.14+5i
var v2 = complex(3.14,5)
a:=real(v)//实部
b:=imag(v)//虚步
</code></pre>
</li>
<li>
<p>字符 字符串：string rune</p>
<p>采用UTF-8字符集编码</p>
<p>字符串不可变 无法通过数字下标修改</p>
<p>可以使用操作符 **+**来链接字符串</p>
<p>​</p>
<pre><code class="language-go">var a =&quot;直接用字符串初始化&quot;
var emptyString string =&quot;&quot;	//声明空字符串
//同时声明多个字符串 
no,yes,may :=&quot;no&quot;,&quot;yes&quot;,&quot;may&quot;
/*字符串多行声明  使用``*/
s :=`my
		love`	//	``包括的字符串为Raw字符串，在代码中形式即为打印出的形式 没有字符转义 换行亦直接输出
no=&quot;yes&quot;		//常规赋值


/*可以数组索引下标值 但不可修改*/
var b = &quot;abcdef&quot;
c:=b[0]
b[0]='1'	//ERROR!!
/*字符串修改方法*/
/*- 将字符串转化为[]byte类型*/
c :=[]byte(a)
c[0]='1'
a1 :=string(c)	//再回转为string
fmt.Println(&quot;%s&quot;,a1)		//输出为1bcdef
fmt.Printf(&quot;%c&quot;,a1[0])	//输出为1
fmt.Printf(&quot;%q&quot;,a1[0])	//输出为'1'
/*- 使用切片操作修改字符串 */
s :=&quot;mylove&quot;
s=&quot;y&quot;+s[1:]
fmt.Printf(&quot;%s\n&quot;,s)


/* 字符串尾部不含NULL字符 */

/* “+”操作符链接字符串 可连接多个
s :=&quot;try&quot;
s1 :=&quot;it&quot;
s2 :=&quot;!&quot;
s3 :=s+s1
s4 :=s+s1+s2
fmt.Printf(&quot;%s\n&quot;,s+s1)
fmt.Printf(&quot;%s\n&quot;,s3)
fmt.Printf(&quot;%s\n&quot;,s+s1+s2)
fmt.Printf(&quot;%s\n&quot;,s4)
</code></pre>
<p>字符串可以拼接+ len()返回长度</p>
<pre><code class="language-go">a：=&quot;hello&quot;
b：=&quot;world&quot;

c：=a+b		//可以拼接
len(a)		//内置函数无需导入

d:=&quot;hello,go!&quot;

for i:=0;i&lt;len(d);i++ {	//数组下标形式访问字符串
  fmt.println(d[i])
}

for i,v:=rang d{
  fmt.println(i,v)
}
</code></pre>
</li>
<li>
<p>array slice map</p>
<ul>
<li>
<p>数组 array</p>
<p>定义方式为<code>var arr [n]type</code> 其中arr为名称 n为数组长度 type为元素类型 n忽略则需要同时赋值 Go会自动计算长度</p>
<p>Len(arr)可直接计算长度</p>
<p>支持数组嵌套成为多维数组</p>
<p>长度不可变 值传递和值赋值</p>
<pre><code class="language-go">var arr[10]int //长为10的in t类型数组arr 默认为类型的零值
a[0]=1	//从0开始 直接赋值

/*赋值同时声明 */
a:=[3]int{1,2,3}
b:=[...]int{1,2,3}	//省略长度 自动计算长度

/*二维数组*/
doubleArray:=[2][4]int{[4]int{1,2,3,4},[4]int{1,2,3,4}}
doubleArray:=[2][4]int{{1,2,3,4},{1,2,3,4}}

</code></pre>
</li>
<li>
<p><strong>slice</strong></p>
<p>即为动态数组，<code>slice</code>并不是真正意义上的动态数组，而是一个引用类型。<code>slice</code>总是指向一个底层<code>array</code>。</p>
<pre><code class="language-go">// 和声明array一样，只是少了长度
var fslice []int
</code></pre>
<pre><code class="language-go">slice := []byte {'a', 'b', 'c', 'd'}
</code></pre>
<p><code>slice</code>可以从一个数组或一个已经存在的<code>slice</code>中再次声明。<code>slice</code>通过<code>array[i:j]</code>来获取，其中<code>i</code>是数组的开始位置，<code>j</code>是结束位置，但不包含<code>array[j]</code>，它的长度是<code>j-i</code>。</p>
<pre><code class="language-go">// 声明一个含有10个元素元素类型为byte的数组
var ar = [10]byte {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}
// 声明两个含有byte的slice
var a, b []byte// a指向数组的第3个元素开始，并到第五个元素结束，
a = ar[2:5]
//现在a含有的元素: ar[2]、ar[3]和ar[4]
// b是数组ar的另一个slice
b = ar[3:5]
// b的元素是：ar[3]和ar[4]
</code></pre>
<ul>
<li><code>slice</code>的默认开始位置是0，<code>ar[:n]</code>等价于<code>ar[0:n]</code></li>
<li><code>slice</code>的第二个序列默认是数组的长度，<code>ar[n:]</code>等价于<code>ar[n:len(ar)]</code></li>
<li>如果从一个数组里面直接获取<code>slice</code>，可以这样<code>ar[:]</code>，因为默认第一个序列是0，第二个是数组的长度，即等价于<code>ar[0:len(ar)]</code></li>
<li>对于<code>slice</code>有几个有用的内置函数：
<ul>
<li><code>len</code> 获取<code>slice</code>的长度</li>
<li><code>cap</code> 获取<code>slice</code>的最大容量</li>
<li><code>append</code> 向<code>slice</code>里面追加一个或者多个元素，然后返回一个和<code>slice</code>一样类型的`slice``</li>
<li>``copy<code>函数</code>copy<code>从源</code>slice<code>的</code>src<code>中复制元素到目标</code>dst`，并且返回复制的元素的个数</li>
</ul>
</li>
</ul>
<p>注：<code>append</code>函数会改变<code>slice</code>所引用的数组的内容，从而影响到引用同一数组的其它<code>slice</code>。 但当<code>slice</code>中没有剩余空间（即<code>(cap-len) == 0</code>）时，此时将动态分配新的数组空间。返回的<code>slice</code>数组指针将指向这个空间，而原数组的内容将保持不变；其它引用此数组的<code>slice</code>则不受影响。</p>
<pre><code class="language-go">// 声明一个数组
var array = [10]byte{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}
// 声明两个slice
var aSlice, bSlice []byte
// 演示一些简便操作
aSlice = array[:3] // 等价于aSlice = array[0:3] aSlice包含元素: a,b,c
aSlice = array[5:] // 等价于aSlice = array[5:10] aSlice包含元素: f,g,h,i,j
aSlice = array[:]  // 等价于aSlice = array[0:10] 这样aSlice包含了全部的元素
// 从slice中获取slice
aSlice = array[3:7]  // aSlice包含元素: d,e,f,g
bSlice = aSlice[1:3] // bSlice 包含aSlice[1], aSlice[2] 也就是含有: e,f
bSlice = aSlice[:3]  // bSlice 包含 aSlice[0], aSlice[1], aSlice[2] 也就是含有: d,e,f
bSlice = aSlice[0:5] // 对slice的slice可以在cap范围内扩展，此时bSlice包含：d,e,f,g,h
bSlice = aSlice[:]   // bSlice包含所有aSlice的元素: d,e,f,g
</code></pre>
<p>从概念上面来说<code>slice</code>像一个结构体，这个结构体包含了三个元素：</p>
<ul>
<li>
<p>一个指针，指向数组中<code>slice</code>指定的开始位置 即为引用修改</p>
</li>
<li>
<p>长度，即<code>slice</code>的长度</p>
</li>
<li>
<p>最大长度，也就是<code>slice</code>开始位置到数组的最后位置的长度</p>
<pre><code class="language-go">  Array_a := [10]byte{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}  
Slice_a := Array_a[2:5]
</code></pre>
</li>
</ul>
<h3 id="map">map</h3>
<pre><code class="language-go">map//也就是Python中字典的概念
map[keyType]valueType
// 类似表格 key对应着values 
</code></pre>
<p><code>slice</code>的<code>index</code>只能是 <code>int</code> 类型，<code>map</code>是<code>int</code>，可以是<code>string</code>及所有完全定义了<code>==</code>与<code>!=</code>操作的类型。</p>
<pre><code class="language-go">// 声明一个key是字符串，值为int的字典,这种方式的声明需要在使用之前使用make初始化
var numbers map[string]int
// 另一种map的声明方式
numbers = make(map[string]int)
numbers[&quot;one&quot;] = 1  //赋值
numbers[&quot;ten&quot;] = 10 //赋值
numbers[&quot;three&quot;] = 3
fmt.Println(&quot;第三个数字是: &quot;, numbers[&quot;three&quot;]) // 读取数据
// 打印出来如:第三个数字是: 3
</code></pre>
<p>Note:</p>
<ul>
<li><code>map</code>是无序的，每次打印出来的<code>map</code>都会不一样，它不能通过<code>index</code>获取，而必须通过<code>key</code>获取</li>
<li><code>map</code>的长度是不固定的，也就是和<code>slice</code>一样，也是一种引用类型</li>
<li>内置的<code>len</code>函数同样适用于<code>map</code>，返回<code>map</code>拥有的<code>key</code>的数量</li>
<li><code>map</code>的值可以很方便的修改，通过<code>numbers[&quot;one&quot;]=11</code>可以很容易的把key为<code>one</code>的字典值改为<code>11</code></li>
<li><code>map</code>有两个返回值，第一个为values第二个为存在否，存在为true，不存在为false</li>
<li><code>map</code>和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用mutex lock机制</li>
</ul>
<p><code>map</code>的初始化可以通过<code>key:val</code>的方式初始化值，同时<code>map</code>内置有判断是否存在<code>key</code>的方式</p>
<p>通过<code>delete</code>删除<code>map</code>的元素：</p>
<pre><code class="language-go">// 初始化一个字典
rating := map[string]float32{&quot;C&quot;:5, &quot;Go&quot;:4.5, &quot;Python&quot;:4.5, &quot;C++&quot;:2 }
// map有两个返回值，第二个返回值，如果不存在key，那么ok为false，如果存在ok为true
csharpRating, ok := rating[&quot;C#&quot;]
if ok {
  fmt.Println(&quot;C# is in the map and its rating is &quot;, csharpRating)
}else {
  fmt.Println(&quot;We have no rating associated with C# in the map&quot;)
}
delete(rating, &quot;C&quot;)  
// 删除key为C的元素
</code></pre>
<p><code>map</code>也是一种引用类型，如果两个<code>map</code>同时指向一个底层，那么一个改变，另一个也相应的改变：</p>
<pre><code class="language-go">m := make(map[string]string)
m[&quot;Hello&quot;] = &quot;Bonjour&quot;
m1 := m
m1[&quot;Hello&quot;] = &quot;Salut&quot;  // 现在m[&quot;hello&quot;]的值已经是Salut了
</code></pre>
</li>
</ul>
</li>
<li>
<p>接口：error</p>
</li>
<li>
<p>布尔：bool</p>
<p>​				默认false；&amp;&amp; || ! 操作符</p>
<p>​				仅两值 ture false <code>var ok bool</code>  <code>ok = true</code> //<code>ok:=true</code></p>
<p>​				表达式/逻辑表达式的结果为bool；if for条件为bool</p>
</li>
</ul>
<p>**内置函数：**15 全局可用 无需导入import</p>
<p><code>make new lwn cap append copy delete panic recover close complex real image Print Println</code></p>
<p>**常量标志符：**4</p>
<p><code>ture false;iota（连续枚举）;nil（指针/引用变量默认值nil）</code></p>
<p>**空白标志符：**1</p>
<p><code>_</code></p>
<pre><code class="language-go">//空白标志符用于去除第一项值
sum :=0
for _;value:=range array{
  sum+=value
}
</code></pre>
<pre><code class="language-go">	var a string = &quot;inital&quot;
	fmt.Println(a)
//输出inital

	var b,c int =1,2
	fmt.Println(b,c)
//输出1 2

	var d =true
	fmt.Println(!d)
//输出false

	var e int
	fmt.Println(e)
//输出0 默认int未赋值
	f :=&quot;one&quot;				//命名方式 无须声明
	fmt.Println(f)
</code></pre>
<pre><code class="language-go">	
	const s string = &quot;constant&quot;
	fmt.Println(s)

	const n =50000000
	const d = 3e20 / n 

	fmt.println(d)
	fmt.println(int64(d))

	fmt.println(math.Sin(n))
</code></pre>
<h3 id="13-变量">1.3 变量</h3>
<hr>
<p><code>var 变量名称 类型 = 表达式</code></p>
<p>其中 类型/表达式可忽略一个 类型忽略自行推倒；表达式忽略初始化0值 数值=0 boolean=false string=&quot;&quot;空 接口。引用（slice 指针 map chan 函数）对应零值=nil</p>
<p><em>即Go中无未初始化的变量</em></p>
<pre><code class="language-go">//同时声明多个变量
var i,j,k int
var b,f,s=true,3.14,&quot;four&quot;		//bool,float64,string
var names []string
i,j:=1,0

</code></pre>
<p>**:=**是变量声明语句 **=**是赋值操作 <code>i,j=j,i //交换值</code></p>
<ul>
<li>:= 其左边变量不一定是第一次声明，如果已经声明 则:=仅用于赋值 <em>但其中至少有一个变量是新声明</em></li>
</ul>
<pre><code class="language-go">in ,err :=os.Open(infile)
out,err :=os.Create(outfile)	//out声明并赋值 err仅赋值

f,err :=os.Open(infile)
f,err :=os.Create(outfile)	//	error! 至少一个声明
</code></pre>
<p><strong>指针：</strong></p>
<p><code>var x int;p=&amp;x</code>称p指针指向变量x *p表达式为读取p指针指向的变量x的值</p>
<pre><code class="language-go">x :=1
p :=&amp;x
fmt.Println(*p)		//p of type *int,points to x
*p=2			//equivalent to x=2
fmt.Println(x)
</code></pre>
<ul>
<li>不可<code>++age</code>但可以<code>age++</code></li>
</ul>
<h3 id="14-控制结构">1.4 控制结构</h3>
<hr>
<p><em>控制结构的左大括号不可另起一行</em> 否则会自动在大括号前插入;</p>
<p>reason: Go正式语法以; 分号结束语句 词法分析器自动插入分号  故而源码中不必使用;</p>
<p>​				词法分析器插入规则：新行前最后一个标记为标志符、数值、字符串常量 或者 <code>break continue fallthrough return ++ -- ) }</code>等将在该标记后插入;</p>
<p>​				新行前的标记为语句末尾 则插入分号; 分号还可在闭括号之前省略 <code>go func() { for {dst &lt;- &lt;-src}} ()</code></p>
<p>**关键字 keywords：**25个</p>
<ul>
<li>
<p>引导程序整体结构：8</p>
<p>​	<code>package、import、const、var（变量声明关键字）、func、defer(延迟执行)、go(并发语法关键字)、return</code></p>
</li>
<li>
<p>复合数据结构：4</p>
<p>​	<code>struct、interface(接口类型)、map(声明/创建map)、chan(声明/创建通道)</code></p>
</li>
<li>
<p>控制程序结构：13</p>
<p>​	<code>if eles、for range break continue(循环)、switch select type case default fallthroug(select/switch语句关键字)、goto</code></p>
</li>
</ul>
<p><strong>if</strong></p>
<p><strong>if...else...</strong></p>
<p>​	条件表达式的值必须为boolean 可以省略括号 左花括号不可另起一行</p>
<p>​	条件表达式可以定义局部变量 初始化函数**（作用域为if/else块）** 可接受初始化语句</p>
<pre><code class="language-go">if x&gt;0 {
  return y
}
//初始化语句
if err:=file.Chmod(0664);err!=nil{
  log.Print(err)
  return err
}
</code></pre>
<p><strong>go to</strong></p>
<p><code>goto</code>跳转必须在函数内定义的标签</p>
<pre><code class="language-go">func main(){
  i:=0
  Here:
  fmt.Printf(i)
  i++
  goto Here
}
</code></pre>
<p><strong>For</strong></p>
<p>可以循环又可以控制逻辑作为while使用</p>
<p><code>for expression1;expression2;expression3{}</code>e1\e3均为变量声明 函数调用返回值 e2判断条件 e1在循环开始前调用 e3在每轮循环结束后调用</p>
<p>e1 e3可省略 for e2{}即为仅仅判断e2的条件 相当于while使用 <code>break</code>跳出所有循环 <code>continue</code>结束本次循环 继续下一次</p>
<p>无 <code>,</code>操作符 多变量使用平行赋值</p>
<pre><code class="language-go">//for的三种用法
for init;condition;post{}		//类似C
for condition {}		//类似C中的while
for{}		//类似C中for(;;)

sum:=0
for i:=0;i&lt;10;i++{
  sum+=i
}

//遍历数组 切片 字符串 映射 信道读取 使用rang
for key,value:=range oldMap {
  newMap[key] =value
}

//range在字符串中解析utf-8 独立的Unicode码点分离出来 错误编码占据一个字节 以U+FFFD代替1																		`1`

for pos, char := range &quot;日本\x80語&quot; { // \x80 在 UTF-8 编码中是一个非法字符
    fmt.Printf(&quot;character %#U starts at byte position %d\n&quot;, char, pos)
}

//go无,逗号操作符 在for中多个变量应该采用平行赋值 
for i,j:=0,len(a)-1;i&lt;j;i,j=i+1,j-1{
  a[i],a[j]=a[j],a[i]
}

</code></pre>
<p><strong>Switch：</strong></p>
<pre><code class="language-go">//使用说明
switch sExpr{
  case e1:
  		s1
  case e2:
  		s2
}
</code></pre>
<ul>
<li>其中switch sExpr必须和e1 e2为同一类型 sExpr无表达式为true</li>
<li>默认case 带有break；可使用 <code>fallthroug</code>强制执行后续case</li>
</ul>
<p><strong>make new使用：</strong></p>
<p>make用于内建类型（map slice channel）内存分配；new可以用于全部内存分配</p>
<p><strong>new(Type)</strong> 分配零值的Type类型的内存空间，返回地址为*Type 返回指针，指向新分配的类型Type的零值</p>
<p>New(T) make(T,args)</p>
<p><em>new返回指针</em>	<em>make返回初始化后非零值</em></p>
<h3 id="15-函数">1.5 函数</h3>
<ul>
<li>
<p>保留函数 <code>init main</code> 不存在参数和返回值</p>
</li>
<li>
<p><code>import</code></p>
<ul>
<li>
<p>支持相对和绝对路径的导入，<code>import &quot;./model&quot;</code>当前文件同目录下 <code>import &quot;short/model&quot;</code>加载footpath/src/short/model</p>
</li>
<li>
<p><code>import ( .&quot;fmt)</code> 使得调用包内函数可以忽略包名 <code>fmt.Println(&quot;&quot;)</code>——&gt;<code>Println(&quot;&quot;)</code></p>
</li>
<li>
<pre><code class="language-go">// 将包别名化 使用为f.Println()
import (
  f &quot;fmt&quot;
)

// _操作 
impot (
	&quot;database/sql&quot;
  _&quot;gihub.com/ziutek/mymysql/godrv&quot;	//_操作为引入包但不直接食用包内函数，调用包内init函数
)

</code></pre>
</li>
</ul>
</li>
</ul>
<p>func关键字声明;</p>
<pre><code class="language-go">func funcName(input1 type, inpute2 type)(output1 type,output type){
  
  return v1,v2
}
</code></pre>
<ul>
<li>多参输入 <code>,</code>分隔 多个返回值；</li>
<li>返回值声明变量 output1 output2可忽略</li>
<li>可接受变参</li>
</ul>
<pre><code class="language-go">func SumAndProduct(A,B int)(int,int) {
	return A+B , A*B
	
}

func main(){
	x:=3
	y:=5

	x1,x2:=SumAndProduct(x,y)

	fmt.Printf(&quot;%d+%d=%d\n&quot;,x,y,x1)
	fmt.Printf(&quot;%d*%d=%d\n&quot;,x,y,x2)

  }
</code></pre>
<ul>
<li>
<p>支持变参输入</p>
<p><code>func myFunc(arg ...int){}</code> arg ...int即为不定参数的int输入 arg则为int的slice</p>
</li>
</ul>
<p><strong>延迟 defer:</strong></p>
<p><strong>函数作为值和类型：</strong></p>
<p>在函数中传递函数类型</p>
<h3 id="16-struct-结构体">1.6 Struct 结构体</h3>
<pre><code class="language-go">//定义和使用type person struct {	name string	age  int}var P personfunc main() {  /*逐个赋值 */	P.name = &quot;hello&quot;	P.age = 22  P.name,P.age=&quot;qq&quot;,01  /* 直接使用并赋值 */  P1:=person{&quot;world&quot;,18}	fmt.Printf(&quot;%s\n %d\n&quot;, P.name, P.age)  //错误使用   fmt.Printf(&quot;%s\n&quot;,P1)   // {world %!s (int=18)}    /*通过field:value初始化任意顺序 */  P3:=person{age:24,name:&quot;aaa&quot;}    /* new函数分配指针 类型为*person */  P4:=new(person)}
</code></pre>
<p><strong>匿名字段</strong></p>
<p>将多个结构体中公共部分字段拿出来单独作为结构体，使之嵌套在其他结构体中，可以略过中间结构体名</p>
<p>外在结构体可以直接访问内在结构体的属性 同样可以多重嵌套</p>
<pre><code class="language-go">type Point struct {		x, y int	}	type Circle struct {		Point		Radius int	}	type Wheel struct {		Circle		spokes int	}	var w Wheel//多层嵌套，同时赋值	w = Wheel{Circle{Point{1, 1}, 1}, 1}	fmt.Println(w)
</code></pre>
<h3 id="17-面向对象-method">1.7 面向对象 -method</h3>
<p><code>func (recv ReceiverType) methName(parameters)(results)</code></p>
<p>可认为是特殊类型的函数 recv.Method()</p>
<pre><code class="language-go">package mainimport &quot;fmt&quot;//&quot;github.com/sqs/goreturns/returns&quot;//	&quot;time&quot;type TwoInts struct {	a, b int}func (tn *TwoInts) AddThem() int {	return tn.a + tn.b}func (tn *TwoInts) AddtoParam(param int) int {	return tn.a + tn.b + param}/*以上需在main之外声明 */func main() {	two1 := new(TwoInts)	two1.a, two1.b = 12, 10	fmt.Printf(&quot;sum %d\n&quot;, two1.AddThem())	fmt.Printf(&quot;add this to param %d\n&quot;, two1.AddtoParam(20))	two2 := TwoInts{3, 4}	fmt.Printf(&quot;sum %d\n&quot;, two2.AddThem())}
</code></pre>
<ul>
<li>函数&amp;方法比较：
<ul>
<li>函数参数为变量 <code>fuc(recv)</code> 方法在变量上被调用 <code>recv.emthod()</code></li>
<li>接受者为指针时 方法可以改值 函数引用调用亦可</li>
<li>接受者必须有显式名称 名称必须被调用 receivertype 必须在方法相同的包内被声明</li>
</ul>
</li>
</ul>
<h3 id="18-接口-interface">1.8 接口 interface</h3>
<ul>
<li>利于代码与特定实现分离</li>
</ul>
<h3 id="19-go-module">1.9 go module</h3>
<p>go弃用了gopath模式 转向gomodule</p>
<p>Go mod 常用命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>go mod init</td>
<td>生成 go.mod 文件</td>
</tr>
<tr>
<td>go mod download</td>
<td>下载 go.mod 文件中指明的所有依赖</td>
</tr>
<tr>
<td>go mod tidy</td>
<td>整理现有的依赖</td>
</tr>
<tr>
<td>go mod graph</td>
<td>查看现有的依赖结构</td>
</tr>
<tr>
<td>go mod edit</td>
<td>编辑 go.mod 文件</td>
</tr>
<tr>
<td>go mod vendor</td>
<td>导出项目所有的依赖到vendor目录</td>
</tr>
<tr>
<td>go mod verify</td>
<td>校验一个模块是否被篡改过</td>
</tr>
<tr>
<td>go mod why</td>
<td>查看为什么需要依赖某模块</td>
</tr>
</tbody>
</table>
<p>终端查看:</p>
<p><code>go env</code> 查看go相关环境变量</p>
<p><code>go env -w</code> 修改 +对应</p>
<p>开关 go env -w GO111MODULE=on</p>
<h4 id="初始化项目">初始化项目</h4>
<p>在完成 Go modules 的开启后，我们需要创建一个示例项目来进行演示，执行如下命令：</p>
<pre><code>$ mkdir -p $HOME/eddycjy/module-repo $ cd $HOME/eddycjy/module-repo
</code></pre>
<p>然后进行Go modules的初始化，如下：</p>
<pre><code>$ go mod init github.com/eddycjy/module-repogo: creating new go.mod: module github.com/eddycjy/module-repo
</code></pre>
<p>在执行 <code>go mod init</code> 命令时，我们指定了模块导入路径为 <code>github.com/eddycjy/module-repo</code>。接下来我们在该项目根目录下创建 main.go 文件，如下：</p>
<pre><code>package mainimport (    &quot;fmt&quot;    &quot;github.com/eddycjy/mquote&quot;)func main() {	fmt.Println(mquote.GetHello())}
</code></pre>
<p>然后在项目根目录执行 <code>go get github.com/eddycjy/mquote</code> 命令，如下：</p>
<pre><code>$ go get github.com/eddycjy/mquote go: finding github.com/eddycjy/mquote latestgo: downloading github.com/eddycjy/mquote v0.0.0-20200220041913-e066a990ce6fgo: extracting github.com/eddycjy/mquote v0.0.0-20200220041913-e066a990ce6f
</code></pre>
<h4 id="查看gomod-文件">查看go.mod 文件</h4>
<p>在初始化项目时，会生成一个 go.mod 文件，是启用了 Go modules 项目所必须的最重要的标识，同时也是GO111MODULE 值为 auto 时的识别标识，它描述了当前项目（也就是当前模块）的元信息，每一行都以一个动词开头。</p>
<p>在我们刚刚进行了初始化和简单拉取后，我们再次查看go.mod文件，基本内容如下：</p>
<pre><code>module github.com/eddycjy/module-repogo 1.15.2require (	github.com/eddycjy/mquote v0.0.0-20200220041913-e066a990ce6f)
</code></pre>
<p>为了更进一步的讲解，我们模拟引用如下：</p>
<pre><code>module github.com/eddycjy/module-repogo 1.15.2require (    example.com/apple v0.1.2    example.com/banana v1.2.3    example.com/banana/v2 v2.3.4    example.com/pear // indirect    example.com/strawberry // incompatible)exclude example.com/banana v1.2.4replace example.com/apple v0.1.2 =&gt; example.com/fried v0.1.0 replace example.com/banana =&gt; example.com/fish
</code></pre>
<ul>
<li>module：用于定义当前项目的模块路径。</li>
<li>go：用于标识当前模块的 Go 语言版本，值为初始化模块时的版本，目前来看还只是个标识作用。</li>
<li>require：用于设置一个特定的模块版本。</li>
<li>exclude：用于从使用中排除一个特定的模块版本。</li>
<li>replace：用于将一个模块版本替换为另外一个模块版本。</li>
</ul>
<p>另外你会发现 <code>example.com/pear</code> 的后面会有一个 indirect 标识，indirect 标识表示该模块为间接依赖，也就是在当前应用程序中的 import 语句中，并没有发现这个模块的明确引用，有可能是你先手动 <code>go get</code> 拉取下来的，也有可能是你所依赖的模块所依赖的，情况有好几种。</p>
<h4 id="查看gosum文件">查看go.sum文件</h4>
<p>在第一次拉取模块依赖后，会发现多出了一个 go.sum 文件，其详细罗列了当前项目直接或间接依赖的所有模块版本，并写明了那些模块版本的 SHA-256 哈希值以备 Go 在今后的操作中保证项目所依赖的那些模块版本不会被篡改。</p>
<pre><code>github.com/eddycjy/mquote v0.0.1 h1:4QHXKo7J8a6J/k8UA6CiHhswJQs0sm2foAQQUq8GFHM=github.com/eddycjy/mquote v0.0.1/go.mod h1:ZtlkDs7Mriynl7wsDQ4cU23okEtVYqHwl7F1eDh4qPg=github.com/eddycjy/mquote/module/tour v0.0.1 h1:cc+pgV0LnR8Fhou0zNHughT7IbSnLvfUZ+X3fvshrv8=github.com/eddycjy/mquote/module/tour v0.0.1/go.mod h1:8uL1FOiQJZ4/1hzqQ5mv4Sm7nJcwYu41F3nZmkiWx5I=...
</code></pre>
<p>我们可以看到一个模块路径可能有如下两种：</p>
<pre><code>github.com/eddycjy/mquote v0.0.1 h1:4QHXKo7J8a6J/k8UA6CiHhswJQs0sm2foAQQUq8GFHM=github.com/eddycjy/mquote v0.0.1/go.mod h1:ZtlkDs7Mriynl7wsDQ4cU23okEtVYqHwl7F1eDh4qPg=
</code></pre>
<p>h1 hash 是 Go modules 将目标模块版本的 zip 文件开包后，针对所有包内文件依次进行 hash，然后再把它们的 hash 结果按照固定格式和算法组成总的 hash 值。</p>
<p>而 h1 hash 和 go.mod hash 两者，要不就是同时存在，要不就是只存在 go.mod hash。那什么情况下会不存在 h1 hash 呢，就是当 Go 认为肯定用不到某个模块版本的时候就会省略它的 h1 hash，就会出现不存在 h1 hash，只存在 go.mod hash 的情况。</p>
<h4 id="查看全局缓存">查看全局缓存</h4>
<p>我们刚刚成功的将 <code>github.com/eddycjy/mquote</code> 模块拉取了下来，其拉取的结果缓存在 <code>$GOPATH/pkg/mod</code>和 <code>$GOPATH/pkg/sumdb</code> 目录下，而在<code>mod</code>目录下会以 <code>github.com/foo/bar</code> 的格式进行存放，如下：</p>
<pre><code>mod├── cache├── github.com├── golang.org├── google.golang.org├── gopkg.in...
</code></pre>
<p>需要注意的是同一个模块版本的数据只缓存一份，所有其它模块共享使用。如果你希望清理所有已缓存的模块版本数据，可以执行 <code>go clean -modcache</code> 命令。</p>
<h3 id="110-error接口">1.10 error接口</h3>
<p>error为预定义的类型 interface</p>
<pre><code class="language-go">type error interface {    Error() string}
</code></pre>
<p>调用errors.new函数即可利用传入的错误信息返回新的error</p>
<p>整个errors包仅只有4行：</p>
<pre><code class="language-go">package errorsfunc New(text string) error { return &amp;errorString{text} }type errorString struct { text string }func (e *errorString) Error() string { return e.text }
</code></pre>
<p>承载errorString的类型是一个结构体</p>
<pre><code class="language-go">package syscalltype Errno uintptr // operating system error codevar errors = [...]string{    1:   &quot;operation not permitted&quot;,   // EPERM    2:   &quot;no such file or directory&quot;, // ENOENT    3:   &quot;no such process&quot;,           // ESRCH    // ...}func (e Errno) Error() string {    if 0 &lt;= int(e) &amp;&amp; int(e) &lt; len(errors) {        return errors[e]    }    return fmt.Sprintf(&quot;errno %d&quot;, e)}
</code></pre>
<h3 id="111-reflect">1.11 reflect</h3>
<p>反射是由 reflect 包提供的。它定义了两个重要的类型，Type 和 Value。一个 Type 表示一个Go类型。它是一个接口，有许多方法来区分类型以及检查它们的组成部分，例如一个结构体的成员或一个函数的参数等。唯一能反映 reflect.Type 实现的是接口的类型描述信息（§7.5），也正是这个实体标识了接口值的动态类型。</p>
<p>函数 reflect.TypeOf 接受任意的 interface{} 类型，并以 reflect.Type 形式返回其动态类型：</p>
<pre><code class="language-Go">t := reflect.TypeOf(3)  // a reflect.Typefmt.Println(t.String()) // &quot;int&quot;fmt.Println(t)          // &quot;int&quot;
</code></pre>
<p>其中 TypeOf(3) 调用将值 3 传给 interface{} 参数。回到 7.5节 的将一个具体的值转为接口类型会有一个隐式的接口转换操作，它会创建一个包含两个信息的接口值：操作数的动态类型（这里是 int）和它的动态的值（这里是 3）。</p>
<p>因为 reflect.TypeOf 返回的是一个动态类型的接口值，它总是返回具体的类型。因此，下面的代码将打印 &quot;*os.File&quot; 而不是 &quot;io.Writer&quot;。稍后，我们将看到能够表达接口类型的 reflect.Type。</p>
<pre><code class="language-Go">var w io.Writer = os.Stdoutfmt.Println(reflect.TypeOf(w)) // &quot;*os.File&quot;
</code></pre>
<p>要注意的是 reflect.Type 接口是满足 fmt.Stringer 接口的。因为打印一个接口的动态类型对于调试和日志是有帮助的， fmt.Printf 提供了一个缩写 %T 参数，内部使用 reflect.TypeOf 来输出：</p>
<pre><code class="language-Go">fmt.Printf(&quot;%T\n&quot;, 3) // &quot;int&quot;
</code></pre>
<p>reflect 包中另一个重要的类型是 Value。一个 reflect.Value 可以装载任意类型的值。函数 reflect.ValueOf 接受任意的 interface{} 类型，并返回一个装载着其动态值的 reflect.Value。和 reflect.TypeOf 类似，reflect.ValueOf 返回的结果也是具体的类型，但是 reflect.Value 也可以持有一个接口值。</p>
<pre><code class="language-Go">v := reflect.ValueOf(3) // a reflect.Valuefmt.Println(v)          // &quot;3&quot;fmt.Printf(&quot;%v\n&quot;, v)   // &quot;3&quot;fmt.Println(v.String()) // NOTE: &quot;&lt;int Value&gt;&quot;
</code></pre>
<p>和 reflect.Type 类似，reflect.Value 也满足 fmt.Stringer 接口，但是除非 Value 持有的是字符串，否则 String 方法只返回其类型。而使用 fmt 包的 %v 标志参数会对 reflect.Values 特殊处理。</p>
<p>对 Value 调用 Type 方法将返回具体类型所对应的 reflect.Type：</p>
<pre><code class="language-Go">t := v.Type()           // a reflect.Typefmt.Println(t.String()) // &quot;int&quot;
</code></pre>
<p>reflect.ValueOf 的逆操作是 reflect.Value.Interface 方法。它返回一个 interface{} 类型，装载着与 reflect.Value 相同的具体值：</p>
<pre><code class="language-Go">v := reflect.ValueOf(3) // a reflect.Valuex := v.Interface()      // an interface{}i := x.(int)            // an intfmt.Printf(&quot;%d\n&quot;, i)   // &quot;3&quot;
</code></pre>
<p>reflect.Value 和 interface{} 都能装载任意的值。所不同的是，一个空的接口隐藏了值内部的表示方式和所有方法，因此只有我们知道具体的动态类型才能使用类型断言来访问内部的值（就像上面那样），内部值我们没法访问。相比之下，一个 Value 则有很多方法来检查其内容，无论它的具体类型是什么。让我们再次尝试实现我们的格式化函数 format.Any。</p>
<p>我们使用 reflect.Value 的 Kind 方法来替代之前的类型 switch。虽然还是有无穷多的类型，但是它们的 kinds 类型却是有限的：Bool、String 和 所有数字类型的基础类型；Array 和 Struct 对应的聚合类型；Chan、Func、Ptr、Slice 和 Map 对应的引用类型；interface 类型；还有表示空值的 Invalid 类型。（空的 reflect.Value 的 kind 即为 Invalid。）</p>
<pre><code class="language-Go">package formatimport (    &quot;reflect&quot;    &quot;strconv&quot;)// Any formats any value as a string.func Any(value interface{}) string {    return formatAtom(reflect.ValueOf(value))}// formatAtom formats a value without inspecting its internal structure.func formatAtom(v reflect.Value) string {    switch v.Kind() {    case reflect.Invalid:        return &quot;invalid&quot;    case reflect.Int, reflect.Int8, reflect.Int16,        reflect.Int32, reflect.Int64:        return strconv.FormatInt(v.Int(), 10)    case reflect.Uint, reflect.Uint8, reflect.Uint16,        reflect.Uint32, reflect.Uint64, reflect.Uintptr:        return strconv.FormatUint(v.Uint(), 10)    // ...floating-point and complex cases omitted for brevity...    case reflect.Bool:        return strconv.FormatBool(v.Bool())    case reflect.String:        return strconv.Quote(v.String())    case reflect.Chan, reflect.Func, reflect.Ptr, reflect.Slice, reflect.Map:        return v.Type().String() + &quot; 0x&quot; +            strconv.FormatUint(uint64(v.Pointer()), 16)    default: // reflect.Array, reflect.Struct, reflect.Interface        return v.Type().String() + &quot; value&quot;    }}
</code></pre>
<p>到目前为止，我们的函数将每个值视作一个不可分割没有内部结构的物品，因此它叫 formatAtom。对于聚合类型（结构体和数组）和接口，只是打印值的类型，对于引用类型（channels、functions、pointers、slices 和 maps），打印类型和十六进制的引用地址。虽然还不够理想，但是依然是一个重大的进步，并且 Kind 只关心底层表示，format.Any 也支持具名类型。例如：</p>
<pre><code class="language-Go">var x int64 = 1var d time.Duration = 1 * time.Nanosecondfmt.Println(format.Any(x))                  // &quot;1&quot;fmt.Println(format.Any(d))                  // &quot;1&quot;fmt.Println(format.Any([]int64{x}))         // &quot;[]int64 0x8202b87b0&quot;fmt.Println(format.Any([]time.Duration{d})) // &quot;[]time.Duration 0x8202b87e0&quot;
</code></pre>
<h3 id="112单元测试">1.12单元测试</h3>
<p><code>go test</code> 使用该命令时以 <code>_test.go</code>后缀的源文件在<code>gobuild</code>时不会成为包的一部分</p>
<p>遍历所有 <code>*_test.go</code>的文件</p>
<p><strong>测试函数</strong></p>
<p><code>func TestName (t *testing.T){}</code></p>
<p>必须以Test开头 后缀名可选且必须大写字母</p>
<p><code>e.g. func TestSin(t *testing.T){}</code> t参数用于报告测试失败和附加日志</p>
<pre><code class="language-go">
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[# idea 单元测试]]></title>
        <id>https://flyingchase.github.io/post/idea-dan-yuan-ce-shi/</id>
        <link href="https://flyingchase.github.io/post/idea-dan-yuan-ce-shi/">
        </link>
        <updated>2021-08-30T07:04:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="安装插件">安装插件</h2>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/ovrMKQ.png" alt="ovrMKQ" loading="lazy"></figure>
<h2 id="配置-test-目录">配置 test 目录</h2>
<ul>
<li>
<p>在 src 同级生成 test 目录</p>
</li>
<li>
<p>右键 test 目录设为 test resourceroot</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/JQtpJv.png" alt="JQtpJv" loading="lazy"></figure>
</li>
</ul>
<h2 id="生成测试类">生成测试类</h2>
<ul>
<li>
<p>在待测试的类或者方法上使用快捷键 <code>cmd+shift+t</code></p>
</li>
<li>
<p>选择 Junit5 + 待测方法名</p>
</li>
<li>
<p>自动上设置的test 目录新建对应 package 下的测试类</p>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/t4PxEI.png" alt="t4PxEI" loading="lazy"></figure>
</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/Cf7oFg.png" alt="Cf7oFg" loading="lazy"></figure>
<h2 id="编写测试代码">编写测试代码</h2>
<ul>
<li>使用 new 创建原先的代码类并传入方法</li>
<li>使用<code>assertEquals</code>等进行测试</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[位移运算]]></title>
        <id>https://flyingchase.github.io/post/wei-yi-yun-suan/</id>
        <link href="https://flyingchase.github.io/post/wei-yi-yun-suan/">
        </link>
        <updated>2021-08-21T06:40:45.000Z</updated>
        <content type="html"><![CDATA[<h3 id="01-位移运算">01 位移运算</h3>
<ul>
<li>
<p>左移 扩大</p>
<ul>
<li>
<p><code>1&gt;&gt;4</code> 即1 * 2 * 2 * 2 * 2 = 16 左移 4 位即pow（2,4）</p>
</li>
<li>
<p>Java提供的位运算符有：左移( <code>&lt;&lt;</code> )、右移( <code>&gt;&gt;</code> ) 、无符号右移( <code>&gt;&gt;&gt;</code> ) 、位与( <code>&amp;</code> ) 、位或( <code>|</code> )、位非( <code>~</code> )、位异或( <code>^</code> )，除了位非( <code>~</code> )是一元操作符外，其它的都是二元操作符。</p>
<h4 id="1-左移">1. 左移( &lt;&lt; )</h4>
<p>a &lt;&lt; b 表示将数值 a 的二进制数值从 0 位算起到第 b - 1 位，整体向左方向移动 b 位，符号位不变，低位空出来的位补数值 0。</p>
<pre><code class="language-shell">a &lt;&lt; b = a * (2 ^ b)
</code></pre>
<h4 id="2-右移">2. 右移( &gt;&gt; )</h4>
<p><strong>a &gt;&gt; b</strong> 表示将数值 a 的二进制数值从 0 位算起到第 b - 1 位，整体向右方向移动 b 位，符号位不变，高位空出来的位补数值 0。</p>
<pre><code>a &gt;&gt; b = a / ( 2 ^ b )
</code></pre>
<h4 id="3-无符号右移">3. 无符号右移( &gt;&gt;&gt; )</h4>
<p>无符号右移运算符&gt;&gt;&gt;和右移运算符&gt;&gt;是一样的，只不过右移时左边是补上符号位，而无符号右移运算符是补上0，也就是说，对于正数移位来说等同于：&gt;&gt;，负数通过此移位运算符能移位成正数。</p>
<h4 id="4-位与">4. 位与( &amp; )</h4>
<p>与运算时，进行运算的两个数，从最低位到最高位，一一对应。如果某 bit 的两个数值对应的值都是 1，则结果值相应的 bit 就是 1，否则为 0.</p>
<pre><code class="language-java">0 &amp; 0 = 0,

0 &amp; 1 = 0,

1 &amp; 1 = 1
</code></pre>
<h4 id="5-位或">5. 位或( | )</h4>
<p>与运算时，进行运算的两个数，从最低位到最高位，一一对应。如果某 bit 的两个数值对应的值只要 1 个为 1，则结果值相应的 bit 就是 1，否则为 0。</p>
<pre><code class="language-java">0 | 0 = 0,

0 | 1 = 1,

1 | 1 = 1
</code></pre>
<h4 id="6-位异或">6. 位异或( ^ )</h4>
<p>两个操作数进行异或时，对于同一位上，如果数值相同则为 0，数值不同则为 1。</p>
<pre><code class="language-java">1 ^ 0 = 1,

1 ^ 1 = 0,

0 ^ 0 = 0;
</code></pre>
<h4 id="7-位非-~">7. 位非( ~ )</h4>
<p>对操作数的每一位进行操作，1 变成 0，0 变成 1。</p>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[String 总结]]></title>
        <id>https://flyingchase.github.io/post/string-zong-jie/</id>
        <link href="https://flyingchase.github.io/post/string-zong-jie/">
        </link>
        <updated>2021-08-20T07:31:38.000Z</updated>
        <content type="html"><![CDATA[<h2 id="string">String</h2>
<pre><code class="language-java">// 1. 基本操作
    charAt(),substring()
    ch = st.toCharArray(); // 字符串转换为字符数组.
// 2. 比较
    if(!this.name.equals(s1.name)){
         return this.name.compareTo(s1.name);
    }
// 3.StringBuilder比较
	s1.toString().equals(s2.toString())

</code></pre>
<ul>
<li>
<p><strong>替换/循环移动</strong></p>
<ul>
<li>使用 charAt(index)和 subSrting(index)（index 和后直到字符串结尾的整个子串）循环移动子串</li>
</ul>
</li>
<li>
<p><strong>split</strong></p>
<ul>
<li>String[] line =  str.split(“ ”) //以空格划分</li>
<li>Sting s =line[1].split(“\\.”)  // 以.划分</li>
</ul>
</li>
<li>
<p><strong>子串后缀链接</strong></p>
<ul>
<li>
<pre><code class="language-java">String temp  =&quot;&quot;;
// 从后往前遍历 sting 
for(int i=domains.leng-1;i&gt;=0;i--) {
    // 保证子串不断增长
    temp = domains[i] + (temp.equals(&quot;&quot;)?temp:&quot;.&quot;+temp);
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>遍历中使用subString获得后续子串</strong></p>
<ul>
<li>
<pre><code class="language-java">for (String cd : cpdomains) {
	// ues indexOf 确定''划分的位置下标
    int i = cd.indexOf(' ');
    // ues subString 获得空格前的数值 Integer.valueOf 转化
    int n = Integer.valueOf(cd.substring(0, i));
    
    String s = cd.substring(i + 1);
    for (i = 0; i &lt; s.length(); ++i) {
        if (s.charAt(i) == '.') {
            // 获得'.'划分的子缀 正向遍历不丢失后续信息
            String d = s.substring(i + 1);
            count.put(d, count.getOrDefault(d, 0) + n);
        }
    }
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>筛选：</strong></p>
<ul>
<li>LC811</li>
</ul>
</li>
</ul>
<h3 id="tips">Tips</h3>
<h4 id="替换字符">替换字符</h4>
<h5 id="思路">思路</h5>
<ul>
<li>
<p>使用 <code>HashSet</code>保存替换的字典集  Arrays.asList(‘...’)作为参数 保存为 private static final 类型</p>
<pre><code class="language-java">private static final HashSet&lt;Character&gt; vowels = new HashSet&lt;&gt;(
        Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));
</code></pre>
</li>
<li>
<p>使用 <code>s.split(“ ”)</code>删除空格字符</p>
</li>
<li>
<p>使用 <code>StringBuilder</code>作为append的新字符串 最后 toString返回</p>
</li>
</ul>
<h5 id="codes">Codes</h5>
<pre><code class="language-java">private static final HashSet&lt;Character&gt; vowels = new HashSet&lt;&gt;(
        Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));

public String toGoatLatin(String S) {
    if (S == null || S.length() == 0) {
        return &quot;&quot;;
    }

    StringBuilder sb = new StringBuilder();
    StringBuilder suffix = new StringBuilder(&quot;a&quot;);

    for (String w : S.split(&quot; &quot;)) {
        // 保证前导“ ”在非第一个字符前出现
        if (sb.length() != 0) {
            sb.append(&quot; &quot;);
        }
		// 暂存 w 的首字符 判断是否是元音
        char fChar = w.charAt(0);
        if (vowels.contains(fChar)) {
            sb.append(w);
        } else {
            // 使用 subString 链接除首字符外的字符串
            sb.append(w.substring(1));
            // 再将暂存的首字符追加
            sb.append(fChar);
        }
		// 连续追加
        sb.append(&quot;ma&quot;).append(suffix);
		// 保证后缀a 随字符的下标增加
        suffix.append(&quot;a&quot;);
    }
    // System.out.println(&quot;sb.toString() = &quot; + sb.toString());
    return sb.toString();
}
</code></pre>
<ul>
<li></li>
</ul>
<h3 id="sb">sb</h3>
<ul>
<li>
<p><strong>连续追加</strong></p>
<ul>
<li><code>Sb.append(“aa”).append(“string”)</code></li>
</ul>
</li>
<li>
<p><strong>构建二维 string</strong></p>
<ul>
<li>
<pre><code class="language-java">StringBuffer[] sb = new StringBuffer[len];
for (int i = 0; i &lt; sb.length; i++) sb[i] = new StringBuffer();
</code></pre>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Array 总结]]></title>
        <id>https://flyingchase.github.io/post/array-zong-jie/</id>
        <link href="https://flyingchase.github.io/post/array-zong-jie/">
        </link>
        <updated>2021-08-20T07:30:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="array-数组">Array 数组</h2>
<ol>
<li>相对于array，ArrayList特点：<br>
动态改变大小，如果事先知道大小，并且不会改变可以使用Array<br>
存储需要的空间更多<br>
编译时检查类型是否正确<br>
只能保存封装类<br>
可以通过iterator遍历<br>
size获取存储元素的个数,array中length获取数组长度<br>
不支持多维</li>
<li>list接口<br>
add(),get(int index),remove(int index),set(),clear()<br>
ArrayList类的特点：底层是数组结构，查询快，增删慢；线程不安全，效率高<br>
Vector类的特点：底层是数组机构，查询快，增删慢；线程安全，效率低<br>
LinkedList类的特点：底层是链表结构，增删快，查询慢；线程不安全，效率低<br>
removeall:比较参数collection的对象是否包含，如果包含则删除，复杂度O(n^2)<br>
clear：将所有元素置为空</li>
<li>array操作</li>
</ol>
<p><strong>memset：</strong><code>Arrays.fill()</code><br>
<strong>sort:</strong><code>Arrays.sort()</code><br>
<strong>bsearch:</strong> <code>Arrays.binarySearch()</code>   must be sorted</p>
<pre><code class="language-java">int ind = Arrays.binarySearch(students, 0,N,student);//类中需要重构equals函数和compareTo函数


 public int compareTo(Student student) {
      return sid.compareTo(student.sid);
  }
  @Override
  public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null || getClass() != o.getClass()) return false;
      Student student = (Student) o;
     return Objects.equals(sid, student.sid);
 }
int dir[][]={{1,0},{-1,0},{0,1},{0,-1}};
  	
</code></pre>
<ol start="4">
<li>
<p>数组反转<br>
<code>Collections.reverse(buf);</code></p>
</li>
<li>
<p>寻找一个集合的最大元素</p>
</li>
<li>
<p>Arrays.sort()然后取第一个元素</p>
</li>
<li>
<p><code>Collection.max()</code></p>
</li>
<li>
<p>两种复制方法<br>
System.arraycopy(arr1, 0, arr2, 0, arr1.length);<br>
arr2 = Arrays.copyOf(arr1, arr1.length * 2);</p>
</li>
</ol>
<h3 id="tips">Tips</h3>
<h4 id="右移数组">右移数组</h4>
<p>思路： k%=n;保证 k在数组长度 n 之内</p>
<pre><code class="language-java">reverse(nums,0,n-k-1);
reverse(nums,n-k,n-1);
reverse(nums,0,n-1);
</code></pre>
<h4 id="o1删除重复元素">O(1)删除重复元素</h4>
<p>思路：从j=0 i=0开始 i 遍历数组  当两指针指向不相等时候++j; A[j]=A[i];</p>
<pre><code class="language-java">public int removeDuplicates(int[] A) {
    // return the length of A
    if (A.length==0) return 0;
    int j=0;
    // 不断与下一个元素比较 不同则替换为下一元素
    for (int i=0; i&lt;A.length; i++)
        if (A[i]!=A[j]) A[++j]=A[i];
    return ++j;
}
</code></pre>
<h4 id="找到升序的下一个稍大排列">找到升序的下一个稍大排列</h4>
<p>思路：</p>
<ul>
<li>
<p>从后向前遍历数组 找到非升序的转折点</p>
</li>
<li>
<p>从转折点向后找 找到转折点后最小的数字 并交换转折点和其后的最小位置  即为下一个稍大的排列</p>
</li>
</ul>
<pre><code class="language-java">public int[] nextPermutation(int[] nums) {
    int len = nums.length;
    if ( len &lt;= 1)
        return nums;
    int i = len - 1; 
    // 从后向前找到非递增的转折点
    while (i &gt; 0 &amp;&amp; nums[i] &lt;= nums[i - 1])
        i --;
    // 区间逆转 将转折点及后续部分逆转
    swapList(nums, i, len - 1);
    if (i != 0) {
        int j = i;
        while (nums[j] &lt;= nums[i - 1]) j++;
        // 找到转折点后稍大的数字并交换位置
        swapItem(nums, j, i-1);
    }
    return nums;
}
</code></pre>
<p>全部代码：</p>
<pre><code class="language-java">public void nextPermutation(int[] A) {
    if(A == null || A.length &lt;= 1) return;
    int i = A.length - 2;
    while(i &gt;= 0 &amp;&amp; A[i] &gt;= A[i + 1]) i--; // Find 1st id i that breaks descending order
    if(i &gt;= 0) {                           // If not entirely descending
        int j = A.length - 1;              // Start from the end
        while(A[j] &lt;= A[i]) j--;           // Find rightmost first larger id j
        swap(A, i, j);                     // Switch i and j
    }
    reverse(A, i + 1, A.length - 1);       // Reverse the descending sequence
}

public void swap(int[] A, int i, int j) {
    int tmp = A[i];
    A[i] = A[j];
    A[j] = tmp;
}

public void reverse(int[] A, int i, int j) {
    while(i &lt; j) swap(A, i++, j--);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的非递归遍历算法]]></title>
        <id>https://flyingchase.github.io/post/er-cha-shu-de-fei-di-gui-bian-li-suan-fa/</id>
        <link href="https://flyingchase.github.io/post/er-cha-shu-de-fei-di-gui-bian-li-suan-fa/">
        </link>
        <updated>2021-07-02T10:13:16.000Z</updated>
        <content type="html"><![CDATA[<h2 id="非递归遍历二叉树">非递归遍历二叉树</h2>
<hr>
<p>递归本质上就是栈 由于二叉树提供节点只能向下访问 无法返回 故而使用栈结构实现返回</p>
<pre><code class="language-java">public static List&lt;Integer&gt; inOrderTraversalBT(TreeNode root) {
    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
    //空树则直接返回null的res
    if (root == null) {
        return res;
    }
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
    // 保存root
    TreeNode cur = root;
    while (cur != null || !stack.isEmpty()) {
        // 向树的最左侧走 并不断压栈
        while (cur != null) {
            stack.push(cur);
            cur = cur.left;
        }
        // 走完最左侧后弹栈顶
        TreeNode node = stack.pop();
        res.add(node.val);
        // 往上层的右边去再重复找最左侧
        cur = node.right;
    }
    return res;
}


public static List&lt;Integer&gt; preOrderTraversalBT(TreeNode root) {
    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
    //空树则直接返回null的res
    if (root == null) {
        return res;
    }
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
    // 保存root
    TreeNode cur = root;
    while (cur != null || !stack.isEmpty()) {
        // 向树的最左侧走 并不断压栈入数组
        while (cur != null) {
            res.add(cur.val);
            stack.push(cur);
            cur = cur.left;
        }
        // 走完最左侧后弹栈顶 无须入组 cur循环内已经入组
        TreeNode node = stack.pop();
        // 往上层的右边去 再重复找最左侧
        cur = node.right;
    }

    return res;
}


public static List&lt;Integer&gt; postOrderTraversalBT(TreeNode root) {
    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
    //空树则直接返回null的res
    if (root == null) {
        return res;
    }
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
    // 保存root
    TreeNode cur = root;
    while (cur != null || !stack.isEmpty()) {
        // 向树的最右侧走 并不断压栈入数组
        while (cur != null) {
            res.add(cur.val);
            stack.push(cur);
            cur = cur.right; // 使得reverse后正常左在前
        }
        // 走完最右侧后弹栈顶 无须入组 cur循环内已经入组
        TreeNode node = stack.pop();
        // 往上层的左边去 再重复找最右侧
        cur=node.left;
    }
    Collections.reverse(res);
    return res;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git常见问题汇总]]></title>
        <id>https://flyingchase.github.io/post/git-chang-jian-wen-ti-hui-zong/</id>
        <link href="https://flyingchase.github.io/post/git-chang-jian-wen-ti-hui-zong/">
        </link>
        <updated>2021-06-28T06:08:25.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>整理收集于互联网</p>
</blockquote>
<h3 id="1修改提交信息">1.修改提交信息</h3>
<p>重写<code>commit</code></p>
<pre><code class="language-shell">git commit --amend -m &quot;new message&quot;
</code></pre>
<h3 id="2添加文件到最后一次提交">2.添加文件到最后一次提交</h3>
<p><code>git push</code> 后新增文件到最后一次提交</p>
<pre><code class="language-shell">git add &lt;file_name&gt;git commit --amend HEAD~1
</code></pre>
<h3 id="3撤消提交">3.撤消提交</h3>
<p>如果要撤消最近一次提交但保留更改，可执行以下操作：</p>
<pre><code class="language-shell">git reset --soft HEAD~1
</code></pre>
<p>如果要撤消提交和更改，可执行以下操作：——&gt;丢弃更改</p>
<pre><code class="language-shell">git reset --hard HEAD~1
</code></pre>
<p>如果要撤消所有的本地更改，则可以重置为分支的原始版本：</p>
<pre><code class="language-shell">git reset --hard origin/&lt;branch_name&gt;
</code></pre>
<p>如果要撤消提交而不修改现有历史记录，则可以使用 git revert，此命令通过创建新的提交来撤消提交。</p>
<pre><code class="language-shell">git revert HEAD
</code></pre>
<p>撤消已经推送到远程分支的合并提交的安全方法是使用 git revert 命令：</p>
<pre><code class="language-shell">git revert -m 1 &lt;commit_id&gt;
</code></pre>
<p>commit_id 是要还原的合并提交 id。</p>
<p>注意要点：</p>
<ol>
<li>可以撤消任意数量的提交。例如：<code>git reset HEAD~3</code>（返回 HEAD 之前的 3 个提交)；<code>git reset --hard &lt;commit_id&gt;</code>（返回特定的提交）。</li>
<li>如果尚未推送提交，并且你不想引入糟糕的提交到远程分支，可以使用 git reset。</li>
<li>使用 git revert 还原已经推送到远程分支的合并提交。</li>
<li>使用 git log 查看提交历史。</li>
</ol>
<pre><code class="language-bash"># 删除 untracked files 
git clean -f
 
# 连 untracked 的目录也一起删掉
git clean -fd
 
# 连 gitignore 的untrack 文件/目录也一起删掉 （慎用，一般这个是用来删掉编译出来的 .o之类的文件用的）
git clean -xfd
 
# 在用上述 git clean 前，墙裂建议加上 -n 参数来先看看会删掉哪些文件，防止重要文件被误删
git clean -nxfd
git clean -nf
git clean -nfd
</code></pre>
<h3 id="4-git命令显示中文路径">4. Git命令显示中文路径</h3>
<pre><code class="language-shell">git config --global core.quotePath false
</code></pre>
<h3 id="5-指定文件的历史修改记录">5. 指定文件的历史修改记录</h3>
<pre><code class="language-shell">git log --follow -p 文件名
</code></pre>
<h3 id="6-指定提交的修改记录">6. 指定提交的修改记录</h3>
<pre><code class="language-shell"># 查看commit提交修改的文件git show --stat &lt;commit的代号&gt;#查看commit提交修改的文件及内容git show &lt;commit的代号&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java-集合]]></title>
        <id>https://flyingchase.github.io/post/java-ji-he/</id>
        <link href="https://flyingchase.github.io/post/java-ji-he/">
        </link>
        <updated>2021-06-02T09:08:51.000Z</updated>
        <content type="html"><![CDATA[<h2 id="13-类集合框架">13 类集合框架</h2>
<hr>
<p>Collection定义的方法:</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/NpsW79.png" alt="NpsW79" loading="lazy"></figure>
<p>单列集合+双列集合</p>
<p>Collection接口有两个子接口 list Set实现的子类均为单列集合 Map接口实现的子类为双列结合(K_V )</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/Whzxbx.png" alt="Whzxbx" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/vkXtxV.png" alt="vkXtxV" loading="lazy"></figure>
<h3 id="1301-collection接口">13.01 Collection接口</h3>
<ul>
<li>
<p>常用方法</p>
<ul>
<li>add/addAll</li>
<li>remove/clear/removeAll</li>
<li>contains/containsAll</li>
<li>size</li>
<li>isEmpty</li>
</ul>
</li>
<li>
<p>遍历:</p>
<ul>
<li>
<p>迭代器——&gt;Iterator对象; 所有实现Collection接口均实现</p>
<img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/2021-05-13 15.42.43.gif" alt="2021-05-1315.42.43" style="zoom:150%;" />
</li>
</ul>
</li>
</ul>
<h3 id="1302-list接口">13.02 List接口</h3>
<p><code>List特点:</code></p>
<ul>
<li>元素有序(添加和取出顺序 ) 可重复</li>
<li>支持索引 从0开始</li>
</ul>
<p>实现List接口有: <code>ArrayList LinkedList Vector Stack etc.</code></p>
<p><code>List接口常用方法:</code> 常见8种</p>
<pre><code class="language-java">// index位置插ele List长度自动+1
void add(int index, Object ele);
//index位置开始将eles中所有元素加入
boolean addAll(int index, Collection eles);
// 获取index位置元素
Object get(int index);
// 返回object在集合中首次出现位置
int indexOf(Object obj);
// 返回obj在集合中末次出现位置
int lastIndexOf(Object obj);
// 移除index位置元素并返回该元素
Object remove(int index);
// 替换index位置元素为ele——&gt;也可用于交换

Object set(int index, Object ele);
// 返回从fromIndex到toIndex位置的子集合 前闭后开[forIndex,toIndex)
List subList(int formIndex, int toIndex);

</code></pre>
<p><code>set</code>可用于交换 注意先后访问的顺序</p>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/KGeM3K.png" alt="KGeM3K" loading="lazy"></figure>
<p><code>List常见遍历方式:</code></p>
<pre><code class="language-java">// 迭代器遍历
Iterator ite = collection.iterator();
while(ite.hasNext()) {
    Object next - ite.next();
}

// foreach遍历
for(Object o : Collection) {
    
}

// 普通fori
        for (int i = 0; i &lt; Collection.size(); i++) {
            Object o = Collection.get(i);
        }
</code></pre>
<h4 id="arraylist注意事项️">ArrayList注意事项⚠️</h4>
<ul>
<li>
<p>可以加入多个null</p>
</li>
<li>
<p>是由数组底层实现</p>
</li>
<li>
<p>线程不安全——&gt;没有<code>synchronized</code> 可以等同于Vector (线程安全)</p>
</li>
</ul>
<p><em>底层源码阅读</em>  注意IDEA默认debug不显示null的扩容内容</p>
<ul>
<li>
<p>维护<code>Object</code>类型数组 <code>elecmentData</code></p>
<ul>
<li><code>transient object[] elementData</code> 表示为瞬时 该属性不会被序列化</li>
</ul>
</li>
<li>
<p>创建<code>ArrayList</code>对象时:</p>
<ul>
<li>无参构造器——&gt;初始化的elementData容量为0, 第一次添加扩容elementData为10, 再次扩容则为1.5倍(0_10_15_22)</li>
<li>ArrayList(int) 指定大小的构造器——&gt;elementData容量为制定大小,扩容则直接扩为1.5倍</li>
</ul>
<p><strong>扩容:</strong></p>
<pre><code class="language-java">// 右移一位 ——&gt; /2int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);// 使用Arrays.copyOf(nums,length)来对底层数组elementData扩容return elementData = Arrays.copyOf(elementData, newCapacity);// Arrays.copyOf()超出nums的len范围用null来填充
</code></pre>
<p><code>无参构造器:</code><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/HXRDVH.png" alt="HXRDVH" loading="lazy"></p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/tIEh4x.png" alt="tIEh4x" style="zoom: 50%;" />
<img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/kBrKAj.png" alt="kBrKAj" style="zoom:150%;" />
<p><code>ArraysSupport.newLength</code>方法用于获取newCapacity</p>
<img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/Mh3IOH.png" alt="Mh3IOH" style="zoom:50%;" />
<h4 id="vector底层结构源码剖析"><code>Vector</code>底层结构&amp;源码剖析</h4>
<ul>
<li>
<p>底层同样是对象数组 <code>protected Object[] elementData</code></p>
</li>
<li>
<p>线程同步安全 操作方法带有<code>synchronized</code></p>
<p><strong>无参构造:</strong> 默认10initalCapacity 再按照2倍扩容</p>
<p><strong>指定大小:</strong> 每次2倍扩容</p>
</li>
</ul>
<h4 id="linkedlist源码和结构"><code>LinkedList</code>源码和结构</h4>
<img src="/Users/qlzhou/Library/Application Support/typora-user-images/image-20210514171051143.png" alt="image-20210514171051143" style="zoom:50%;" />
<ul>
<li>底层双向链表、队列——&gt;插入、删除效率高
<ul>
<li>维护两个属性first last 分别指向首尾结点</li>
<li>每个节点Node维护prev next item三个属性</li>
<li>双向链表的插入——&gt; waitInsert.next=prevNode; waitInsert.pre=nextNode; prevNode.next=waitInsert; nextNode.pre=waitInsert;</li>
</ul>
</li>
<li>元素任意(可以重复)  包括null</li>
<li>线程不安全 没有实现同步</li>
</ul>
<p><strong><code>LinkedListCRUD</code></strong></p>
<p>​	linkedList.add(item)——&gt;使用linkLast(e)函数(将添加的节点挂入原链表的最后)</p>
<img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/NJEbDZ.png" alt="NJEbDZ" style="zoom:50%;" />
<p><em><code>Explain To linkLast(E e)</code></em></p>
<p>初始last=null——&gt;第一个节点时 first last newNode均指向节点newNode——&gt;再插入则 l=last last=newNode 将newNode的prev指向l 即原先的last(上一个节点位置) 同时将last指向newNode 设为双向链表的尾指针——&gt;l!=null 再将上一个节点的next指针指向newNode 同时更新size/modCount 完成两个节点之间的链接</p>
<p>linkedList.remove(int index)——&gt;首先使用node(index)函数找到index下标的结点并返回该节点——&gt;调用unlink(Node<E> x) 函数删除该节点并返回item值</p>
<img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/C2JGW8.png" alt="C2JGW8" style="zoom:50%;" />
<p><em><code>Explain To node(index)</code></em></p>
<p>判断下标index在整个链表的前部还是后部——&gt;⚠️后部<code>i=size-1;i&gt;index;i--</code> 判断</p>
<img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/DdBI3S.png" alt="DdBI3S" style="zoom:50%;" />
<p>​	<em><code>Explain To unlink(Node&lt;E&gt; x)</code></em></p>
<p>暂存待删结点x的前后结点</p>
<p>prev next——&gt;移动x的前一结点的next指向x的下一结点<code>prev.next=next</code>   移动x的下一结点的prev指向x的上一结点<code>next.prev=prev</code> ——&gt;同时将x的prev和next均置空(help GC) ——&gt;最后item置空并链表size-1</p>
<h5 id="arraylist-linkedlist-compare">ArrayList &amp;&amp; LinkedList Compare</h5>
<p>ArrayList——&gt;增查</p>
<p>LinkedList——删改</p>
<p>均为线程不安全</p>
<h3 id="1303-set">13.03 <code>Set</code></h3>
<p><code>Feature:</code></p>
<ul>
<li>无序（添加与取出的顺序不一致） 没有 index 索引
<ul>
<li>取出的顺序一次设定即被固定</li>
</ul>
</li>
<li>无重复元素——&gt;最多包含一个 null 多个重复数字后者不会被添加</li>
<li><code>set</code>接口实现的类：<code>HashSet、TreeSet、LinkedHashSet、etc.</code></li>
</ul>
<p><code>Mathods:</code></p>
<ul>
<li>是 Collection 的子接口——&gt;常用方法一致</li>
<li>遍历：迭代器 foeeach 不可 index 索引</li>
</ul>
<h4 id="hashset"><code>HashSet</code></h4>
<p><code>instructions:</code></p>
<ul>
<li>
<p>实现 Set 接口</p>
</li>
<li>
<p>本质上是<code>HashMap</code> <img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/DBF5F0.png" alt="DBF5F0" style="zoom:50%;" />——<code>HashMap</code>底层是数组+链表+红黑树</p>
<ul>
<li>在数组的某个index 位置存储链表（数据存储的高效）</li>
<li>index 上存储的链表长度&gt;8（TreeIfy_Threshold）并且数组长度&gt;64(Min_TreeIfy_Capacity) ————&gt;转化为树</li>
</ul>
</li>
<li>
<p>可存放 null 但仅可有一个 元素不可重复</p>
<ul>
<li>注意元素重复与否与 JVM 内存相关——&gt;常量池、栈内存</li>
<li>toString 没有重写则输出为引用的地址 重写则为内容</li>
<li>new String(“**”)——&gt;先在常量池中查找有没有已经存在的 str</li>
</ul>
</li>
<li>
<p>不保证元素有序，取决于 Hash 后在确定索引</p>
</li>
</ul>
<h5 id="hashset-add-method"><code>HashSet add Method</code></h5>
<ul>
<li>添加元素时——&gt;得到元素的 hash 值再转化——&gt;索引值(存储位置)</li>
<li>存储数据表 tables——&gt;是否已经存放（没有直接加入、有则下步比较 ）</li>
<li>有调用 equal 比较——&gt;不相同再加入到最后</li>
</ul>
<p>hash 值计算<img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/2b37hf.png" alt="2b37hf" style="zoom:50%;" /></p>
<p>第一次 add</p>
<p>依据 hash 计算出的 key 应该存档于 table 的位置，并赋值给辅助变量 p(p 指向索引的结点)</p>
<p>再判断 p 是否为空——&gt;空（对应的插入位置无元素）则将 key新建 Node 并存入 tab[i] （hash key value=present next）——&gt;判断 size 与 threshold(0.75*16)  扩容与否  再返回 null 则表示插入成功</p>
<p>add 所插入的位置非空——&gt;</p>
<p><code>p.hash==hash &amp;&amp; ((k=p.key)==key)||(key!=null&amp;&amp;key.equals(k))</code> hash value equals 三重比较确保两者不相同</p>
<p>返回 oldValue 非空则插入式失败</p>
<img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/Jzejjh.png" alt="Jzejjh" style="zoom:150%;" />
<h5 id="hashset-扩容机制"><code>HashSet 扩容机制</code></h5>
<ol>
<li>
<p>底层<code>HashMap</code> 第一次添加时 <code>table 数组</code>扩容到 16，阈值<code>threshold</code>为 16*0.75加载因子（<code>loadFactor</code>）=12</p>
</li>
<li>
<p><code>table 数组</code>扩容为* 2=32 新的临界值(<code>threshold</code>)为 0.75*32=24</p>
<p>扩容是使用左移&lt;&lt;1实现 * 2</p>
</li>
<li>
<p>链表元素个数达到<code>TreeIfy_Threshold(8)</code>且 table 数组大小&gt;=<code>Min_Treeify_Capacity</code> 则转化为红黑树，否则仍然是扩容数组</p>
</li>
</ol>
<p>​	使用重写 class 的 hashcode 方法 返回同一个 hashcode 使得插入在 map 的同一个数组 index 上的链表内 链表长度超过 8 后会使  table 扩容 &lt;&lt;1 表长+1  扩容为 32表长再+1 到 10  再扩容 64  若在添加元素则树化  treeifyBin 方法</p>
<img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/29NvGo.png" alt="29NvGo" style="zoom:50%;" />
<p>​	直到走到链表末尾进行且 binCount&gt;=8-1=7(从 0 开始)则调用<code>treeifyBin</code>方法树化 传入 table 和 hash 参数</p>
<img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/B2ojcy.png" alt="B2ojcy" style="zoom:50%;" />
<p><code>Min_TreeIfy_Capacity=64</code></p>
<p><code>tab[index=(n-1)&amp;hash]</code> 找到数组储存数据的位置并将e 指向这个引用</p>
<h4 id="linkedhashset"><code>LinkedHashSet</code></h4>
<blockquote>
<p><code>Features:</code></p>
<ol>
<li>属于 HashSet 的子类；</li>
<li>底层是<code>LinkedHashMap</code>，维护了数组+双向链表；</li>
<li>依据元素的<code>hashcode</code>决定元素的存储位置，同时用链表维护元素的次序（图），使得元素看起来插入顺序保存；</li>
<li>不允许重复元素；</li>
</ol>
</blockquote>
<p><code>Explain</code></p>
<blockquote>
<ol>
<li>维护 hash 表和双向链表（属性有 head 和 tail） 使得每次后续插入的元素连接在最后 有序</li>
<li>每个节点有 prev 和 next 属性 before after</li>
<li>添加元素时，先求 hash值再求索引，从而确定元素在 hashtable 的位置——&gt;再添加进入双向链表</li>
<li>遍历顺序保证与插入顺序一致</li>
</ol>
</blockquote>
<ul>
<li>
<p>底层维护<code>LinkedeHashMap</code>结构 ——&gt;是 <code>HashMap</code> 的子类</p>
</li>
<li>
<p>首次初始化为 16（size）结点类型为<code>LinkedHashMao$Entry</code>——&gt;数组是<code>HashMap$Node[]</code> 存放的元素是<code>LinkedHashMap$Entry</code>  即为多态 继承父类的属性</p>
<figure data-type="image" tabindex="5"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/W58GVZ.png" alt="W58GVZ" loading="lazy"></figure>
</li>
</ul>
<p>要求 hashcode 和 equal 均相同才无法加入，对于非基本数据类型需要重写两个方法 equal 和 hashcode</p>
<h4 id="treeset">TreeSet</h4>
<p>可以排序</p>
<p>使用无参构造器创建<code>TreeSet</code>  无序</p>
<p>有参可以使用<code>Comparator</code> 接口——&gt;传入比较器 匿名内部类</p>
<p>构造器将传入的比较器对象comparator赋给 TreeSet 底层的 TreeMap 的属性 comparator</p>
<pre><code class="language-java">public TreeMap(Comparator&lt;? super K&gt; comparator) {
    this.comparator = comparator;
}


final int compare(Object k1, Object k2) {
    return comparator==null ? ((Comparable&lt;? super K&gt;)k1).compareTo((K)k2)
        : comparator.compare((K)k1, (K)k2);
}
</code></pre>
<p>在 TreeSet 的 add 方法会调用</p>
<pre><code class="language-java">private V put(K key, V value, boolean replaceOld) {
    Entry&lt;K,V&gt; t = root;
    if (t == null) {
        addEntryToEmptyMap(key, value);
        return null;
    }
    int cmp;
    Entry&lt;K,V&gt; parent;
    // split comparator and comparable paths
    Comparator&lt;? super K&gt; cpr = comparator;
    if (cpr != null) {
        do {
            parent = t;
           	// 调用自定的 compare
            cmp = cpr.compare(key, t.key);
            if (cmp &lt; 0)
                t = t.left;
            else if (cmp &gt; 0)
                t = t.right;
            else {
                // 两个值相等时候即返回 oldVaule 无法添加
                V oldValue = t.value;
                if (replaceOld || oldValue == null) {
                    t.value = value;
                }
                return oldValue;
            }
        } while (t != null);
    } else {
        Objects.requireNonNull(key);
        @SuppressWarnings(&quot;unchecked&quot;)
        Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;
        do {
            // 这里的循环逐个比较则一旦出现相应的就 return了 
            // 即==时候无法被加入（==为自定的规则）
            parent = t;
            cmp = k.compareTo(t.key);
            if (cmp &lt; 0)
                t = t.left;
            else if (cmp &gt; 0)
                t = t.right;
            else {
                V oldValue = t.value;
                if (replaceOld || oldValue == null) {
                    t.value = value;
                }
                return oldValue;
            }
        } while (t != null);
    }
    addEntry(key, value, parent, cmp &lt; 0);
    return null;
}
</code></pre>
<h3 id="1304-map">13.04 Map</h3>
<p>该接口子类具有的特点：</p>
<blockquote>
<p>Features:</p>
<ol>
<li>Map 和 collection 并列，用于保存具有映射关系的 Key-value 之间为单项一对一的关系</li>
<li>Key Value 可以是任何引用类型的数据 object，会被封装到 HashMap$Node 内部类，Node 实现Entry 接口，即一对 K-V 就是一个 Entry</li>
<li>使用 EntrySet 内部类，定义的类型是 Entry 实际上存放是 HashMap$Node 因为 Node implement Map.Entry 接口——&gt;接口的多态</li>
<li>EntrySet 方便遍历——&gt;提供了 getKey getValue 方法</li>
<li>Key 可为 null 仅一个但不可重复（），value 可以重复并可为 null</li>
</ol>
</blockquote>
<p>Node——&gt;Entry——&gt;EntrySet</p>
<p>Properties：</p>
<p>​	继承自HashTable 并且适用于 Properties文件类型导入加载数据到 Properities 类对象读取和修改</p>
<p>​	读取配置文件时候常用</p>
<h4 id="集合选择">集合选择</h4>
<ul>
<li>存储类型</li>
<li>单列对象：<code>Collection</code> 接口
<ul>
<li>允许重复：List
<ul>
<li>增删：LinkedList——&gt;底层双向链表</li>
<li>改查：ArrayList——&gt;底层维护 Object 可变数组</li>
</ul>
</li>
<li>不允许重复：Set
<ul>
<li>无序：HashSet——&gt;底层 HashMap 维护哈希表（数组+链表+红黑树）</li>
<li>排序：TreeSet</li>
<li>插入和取出循序一致：LinkedHashSet——&gt;数组+双向链表</li>
</ul>
</li>
</ul>
</li>
<li>双列键值对：Map
<ul>
<li>键无序：HashMap——&gt;哈希表</li>
<li>键排序：TreeMap</li>
<li>键插入和取出顺序一致：LinkedHashMap</li>
<li>读取配置文件：Properties</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mac配置指南]]></title>
        <id>https://flyingchase.github.io/post/mac-pei-zhi-zhi-nan/</id>
        <link href="https://flyingchase.github.io/post/mac-pei-zhi-zhi-nan/">
        </link>
        <updated>2021-05-03T12:26:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>升级Big sur时替换硬盘使用Time Machine只恢复一月前备份,故将配置流程记录</p>
<p>教训:</p>
<ul>
<li>做好多处备份, 机械和固态多个备份, 在升级和较多本地内容变动时加强备份频率;</li>
<li>少折腾多干活, 黑苹果不要追求太完美, 现有的版本能稳定运行即可, 多刷题多学习, 不要花时间过于折腾;</li>
</ul>
<h2 id="系统设置">系统设置</h2>
<h4 id="触控板">触控板</h4>
<p>Bettertouch</p>
<h2 id="开发工具">开发工具</h2>
<h4 id="idea系列">IDEA系列</h4>
<h5 id="自动补全">自动补全</h5>
<p><strong>快速输出</strong></p>
<p>List.sout——&gt;System.out.println(list);</p>
<p><strong>定义局部变量</strong></p>
<p>new ArrayList&lt;&gt;().var;</p>
<p><strong>判断空与否</strong></p>
<p>List.null——&gt;if(List==null)</p>
<p>List.notnull——&gt;if(List!=null)</p>
<p><strong>快速取反:</strong></p>
<p>​	输入 .not 可以让布尔值快速取反，再输入 .if 可快速生成 if 判断语句块。</p>
<p>![2021-05-1311.47.57](https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/2021-05-13 11.47.57.gif)</p>
<p><strong>快速遍历集合:</strong></p>
<p>collection.for/.forr/.fori</p>
<p>![2021-05-1311.51.59](https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/2021-05-13 11.51.59.gif)</p>
<p><strong>快速返回:</strong></p>
<p>Object.return——&gt;return Object;</p>
<h5 id="重构生成">重构/生成</h5>
<p>快速生成类的构造器和get set等常见方法</p>
<p>重写toString/hashCode/equal等常见方法</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/ry6AzG.png" alt="ry6AzG" loading="lazy"></figure>
]]></content>
    </entry>
</feed>