<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://flyingchase.github.io</id>
    <title>flyingchase</title>
    <updated>2021-12-15T03:26:19.101Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://flyingchase.github.io"/>
    <link rel="self" href="https://flyingchase.github.io/atom.xml"/>
    <subtitle>一两黄金一两风</subtitle>
    <logo>https://flyingchase.github.io/images/avatar.png</logo>
    <icon>https://flyingchase.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, flyingchase</rights>
    <entry>
        <title type="html"><![CDATA[[Golang Cache 项目]]]></title>
        <id>https://flyingchase.github.io/post/golang-cache-xiang-mu/</id>
        <link href="https://flyingchase.github.io/post/golang-cache-xiang-mu/">
        </link>
        <updated>2021-11-24T04:58:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="geecache概述">GeeCache概述</h2>
<p>模仿<code>goroupcache</code>，考虑：</p>
<ul>
<li>资源控制、淘汰策略、并发、分布式节点通信</li>
<li>缓存更新、缓存淘汰之前是否允许改变</li>
</ul>
<p><strong>特性：</strong></p>
<ul>
<li>单机缓存和基于 HTTP 的分布式缓存</li>
<li>最近最少访问(Least Recently Used, LRU) 缓存策略</li>
<li>使用 Go 锁机制防止缓存击穿</li>
<li>使用一致性哈希选择节点，实现负载均衡</li>
<li>使用 protobuf 优化节点间二进制通信</li>
</ul>
<h2 id="常见缓存淘汰算法">常见缓存淘汰算法</h2>
<h4 id="fifo">FIFO</h4>
<p>创建队列，新增记录添加到队尾，内存不够时淘汰队首</p>
<p><strong>缺点：</strong></p>
<ul>
<li>早入队的数据若被常访问，导致频繁被添加缓存又被淘汰——&gt;缓存命中率低</li>
</ul>
<h3 id="lfu">LFU</h3>
<p>淘汰缓存汇总的访问访问频率最低的记录，维护按照访问次数排序的队列</p>
<p><strong>缺点：</strong></p>
<ul>
<li>维护每个记录的访问次数消耗内存高</li>
<li>LFU 算法手历史数据影响大</li>
</ul>
<h3 id="lru">LRU</h3>
<p>最近最少使用策略</p>
<h2 id="lru-2">LRU</h2>
<h3 id="核心数据结构">核心数据结构</h3>
<img src="/Users/qlzhou/Library/Application Support/typora-user-images/image-20211021223546014.png" alt="image-20211021223546014" style="zoom:30%;" />
<ol>
<li>map 存储字典映射，按key查找value 复杂度 O(1)</li>
<li>双向链表实现队列，将移动到队尾的复杂度是 O(1)，在队尾新增记录和删除记录的复杂度均为 O(1)</li>
</ol>
<h4 id="结构体">结构体</h4>
<p>包含字典和双向链表的结构体 Cache</p>
<pre><code class="language-go">type (
	Cache struct {
		// 允许使用的最大内存
		maxBytes int64
		// 当前使用的内存
		nbytes int64
		ll     *list.List
		cache  map[string]*list.Element
		// 某条记录删除时候的回调函数 可为 nil
		OnEvicted func(key string, value Value)
	}
	entrty struct {
		key   string
		value Value
	}
	// 值实现 Len() 方法则均可视为 value
	Value interface {
		Len() int
	}
)
</code></pre>
<h4 id="get-移至队首">Get 移至队首</h4>
<ol>
<li>
<p>map 查找 <code>c.cache[key]</code></p>
</li>
<li>
<p>调用<code>c.ll.MoveToFront(ele)</code>将所得封装为 entry <code>kv:=ele.Value.(*Entry)</code>，返回<code>kv.value</code></p>
</li>
</ol>
<h4 id="removeoldest-删除队尾和缓存-map">RemoveOldest 删除队尾和缓存 map</h4>
<ol>
<li>取出队尾<code>ele:=c.kll.Back()</code></li>
<li>存在则删除<code>c.ll.Remove(ele)</code> <code>delete(c.cache,kv.key)</code></li>
<li>更新使用内存<code>c.nbytes-=int64(len(kv.key))+int64(kv.value.Len())</code> nbytes 前移偏移量为 kv 的大小（key+value.Len()）</li>
<li>回调函数非空则使用回调函数</li>
</ol>
<h4 id="add更新-新增-越界">Add（更新、新增、越界）</h4>
<ol>
<li>
<p>添加节点已存在——&gt;更新结点</p>
<ul>
<li>缓存map存在则移至队首再更新结点值，</li>
<li>使用内存偏移量同步更新<code>c.nbytes+=int64(value.Len())-int64(kv.value.Len())</code> 多使用新加入结点的 value 比原 value 大的部分</li>
</ul>
</li>
<li>
<p>添加节点不存在——新增结点</p>
<ul>
<li>移至队首<code>ele:=c.ll.MoveToFront(&amp;entry{key,value})</code></li>
<li>新增缓存<code>c.cache[key]=ele</code></li>
<li>更新已使用内存<code>c.nbytes+=int64(len(key))+int64(value.Len())</code></li>
</ul>
</li>
<li>
<p>判定新增结点是否超容</p>
<p><code>for c.maxBytes!=0&amp;&amp;c.maxBytes&lt;c.nBytes{ c.RemoveOldest()}</code> 越界则移出队尾</p>
</li>
</ol>
<h2 id="00-概述">00-概述</h2>
<ul>
<li>实现<code>LRU</code>缓存的并发控制</li>
<li>实现 Cache的核心数据结构<code>Group</code>，当缓存不存在时使用回调函数</li>
</ul>
<h2 id="01-并发-lru-读写">01-并发 lru 读写</h2>
<h3 id="11-byteview-缓存值只读">1.1 ByteView 缓存值只读</h3>
<ol>
<li><code>b []byte</code>存储真实的缓存值，支持任意数据类型存储(byte)</li>
<li>实现<code>Len()</code>方法，支持 lru 的缓存对象的 <code>Value</code>接口</li>
<li><code>ByteSlice()</code>返回缓存 b 的复制，防止外部程序修改缓存</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/mhrcGo.png" alt="mhrcGo" style="zoom:50%;" />
<h3 id="12-cache-并发">1.2 Cache 并发</h3>
<ol>
<li>实例化<code>lru</code>，封装<code>get</code>和<code>add</code>方法，添加互斥锁<code>Mutex</code></li>
</ol>
<pre><code class="language-go"> type cache struct {
     lru        *lru.Cache
     mu         sync.Mutex
     cacheBytes int64
 }
</code></pre>
<ol start="2">
<li><code>add</code>方法使用 <strong>延迟初始化（lazy initialization）</strong> 在判读<code>c.lru==nil</code>后再创建实例，使得对象的创建会延迟至第一次使用该对象时，提高程序性能，减少内存要求</li>
</ol>
<h2 id="02-主体-group">02 主体 Group</h2>
<h3 id="21-逻辑">2.1 逻辑</h3>
<p>与用户之间的交互，<strong>控制缓存值的存储和获取</strong></p>
<pre><code>                            是
接收 key --&gt; 检查是否被缓存 -----&gt; 返回缓存值 ⑴
                |  否                         是
                |-----&gt; 是否应当从远程节点获取 -----&gt; 与远程节点交互 --&gt; 返回缓存值 ⑵
                            |  否
                            |-----&gt; 调用`回调函数`，获取值并添加到缓存 --&gt; 返回缓存值 ⑶
</code></pre>
<h3 id="22-代码结构">2.2 代码结构</h3>
<pre><code>step2/
    |--lru/
        |--lru.go  // lru 缓存淘汰策略
    |--byteview.go // 缓存值的抽象与封装
    |--cache.go    // 并发控制
    |--geecache.go // 负责与外部交互，控制缓存存储和获取的主流程
</code></pre>
<h3 id="23-回调-getter">2.3 回调 Getter</h3>
<p>对于多种数据源（文件、数据库）缓存不存在时，使用回调函数获得源数据（将如何从源头获取数据交给用户）</p>
<pre><code class="language-go">type (
	Getter interface {
		Get(key string) ([]byte, error)
	}
	// GetterFunc 函数类型的参数和返回值与 Getter 接口内的 Get 方法一致
	GetterFunc func(key string) ([]byte, error)
)
// GetterFunc 含有 Get 方法，在方法内调用自身，实现了接口 Getter
// 通过函数实现 Getter接口的 Get 方法，接口型函数
// 接口型函数只应用于接口内部之定义一个方法的接口
func (f GetterFunc) Get(key string)([]byte,error)  {
	return f(key)
}
</code></pre>
<p>#接口函数</p>
<p><strong>接口函数：</strong></p>
<ol>
<li>将普通的函数类型（类型转换 GetterFunc(test）作为函数参数</li>
<li>将结构体作为参数</li>
</ol>
<p>eg:</p>
<p>​	GetterFunc 类型的函数作为参数，支持匿名函数、普通函数（类型转换）</p>
<p>​	实现了 Getter 接口的结构体可作为函数参数</p>
<p>接口函数使用场景：</p>
<ol>
<li>
<p><code>net/http</code>中的<code>Handler</code>和<code>HandlerFunc</code></p>
<pre><code class="language-go">type Handler interface {
	ServeHTTP(ResponseWriter, *Request)
}
type HandlerFunc func(ResponseWriter, *Request)

func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
	f(w, r)
}
</code></pre>
</li>
<li>
<p><code>http.Handle</code>和<code>http.ListenAndServe</code>的第二个参数即为接口类型<code>Handler</code></p>
</li>
<li>
<p>传入实现<code>Handler</code>接口的结构体则可以托管所有的 HTTP 请求，可扩展为 Web 框架</p>
</li>
<li>
<p><code>Java</code>中 lambda 表达式函数式编程可认为是接口函数</p>
<ul>
<li>自定义排序时，需要实现匿名的 Comparator 类，重写 Compare 方法</li>
</ul>
<pre><code class="language-java">Collertions.sort(list,new Comparator&lt;Integer&gt;(){
    @Override
    public int compare(Integer o1,Integer o2) {
        return 02-01;
    }
});
</code></pre>
<ul>
<li>1.8之后<code>lambda</code> 从匿名对象简化为 lambda 表达式</li>
</ul>
<pre><code class="language-java">Collections.sort(list,(Integer o1,Integer o2)-&gt;o2-o1);
</code></pre>
</li>
<li>
<p>定义<code>Getter</code>接口和回调函数<code>Get(key string)([]byte,error)</code></p>
</li>
<li>
<p>定义函数类型<code>GetterFunc</code>实现<code>Getter</code>接口内的<code>Get</code>方法</p>
</li>
<li>
<p><strong>定义函数类型 F，并实现接口 A 的方法，在方法中调用自身</strong>使得其他函数（参数与返回类型与 F一致）<strong>转化为接口 A</strong></p>
</li>
</ol>
<h4 id="24-group-定义">2.4 Group 定义</h4>
<h4 id="结构体-2">结构体</h4>
<pre><code class="language-go">type Group struct {
	name      string
	// 缓存未命中时回调函数
    getter    Getter
    // 并发缓存
	mainCache cache
}
</code></pre>
<ol>
<li>视为缓存的命名空间，每个<code>Group</code>有唯一的<code>name</code></li>
<li><code>getter Getter</code> 为缓存未命中时的数据回调(callback)</li>
<li><code>NewGroup</code>用于实例化 Group 并存储在全局变量 <code>groups</code>内</li>
<li><code>GetGroup</code>获取特定名称的 Group 无写入操作，使用<code>mu.RLock()</code></li>
</ol>
<h4 id="get-方法">Get 方法</h4>
<ol>
<li><code>mainCache</code> 查找缓存，log 内写入缓存命中</li>
<li>缓存不存在<code>load</code>——&gt;<code>getLocally</code>（分布式场景下调用<code>getFromPeer</code>从其他节点获取）——&gt;<code>g.getter.Get</code>回调函数获取源数据，通过<code>g.populateCache</code>添加到缓存内</li>
</ol>
<pre><code>geecache/
    |--lru/
        |--lru.go  // lru 缓存淘汰策略
    |--byteview.go // 缓存值的抽象与封装
    |--cache.go    // 并发控制
    |--geecache.go // 负责与外部交互，控制缓存存储和获取的主流程
	|--http.go     // 提供被其他节点访问的能力(基于http)
</code></pre>
<p>分布式缓存：</p>
<ol>
<li>通过<code>HTTP</code>的通信机制实现节点间的通信</li>
</ol>
<h2 id="geecache-http-服务端">GeeCache HTTP 服务端</h2>
<h3 id="httppool-数据结构">HTTPPool 数据结构</h3>
<p>承载节点间 HTTP 通信的核心数据结构</p>
<pre><code class="language-go">type HTTPPool struct {
	self    string
	basePth string
}

func NewHTTPPool(self string) *HTTPPool {
	return &amp;HTTPPool{self: self, basePth: defaultBasePath}
}
</code></pre>
<ol>
<li><code>HTTPPool</code>内 self 存储主机名/IP 和端口</li>
<li>basePath 作为节点间通信的前缀，默认<code>/_geecache/</code></li>
</ol>
<h3 id="serverhttp-方法">ServerHTTP 方法</h3>
<ol>
<li>
<p>判断前缀是否是<code>basePath</code></p>
<pre><code class="language-go">if !strings.HasPrefix(r.URL.Path, p.basePth) {
   panic(&quot;HTTPPool serving unexpected path: &quot; + r.URL.Path)
}
</code></pre>
</li>
<li>
<p>约定访问路径格式<code>/basePath/groupName/key</code> 通过<code>groupName</code>获得 group 实例，再使用<code>group.Get(key)</code>获得缓存数据</p>
</li>
<li>
<p><code>w.Write()</code>将缓存值作为<code>httpResponse</code>的<code>body</code>返回</p>
</li>
</ol>
<h2 id="01-概述">01 概述</h2>
<p>单节点走向分布式节点通信</p>
<h3 id="11-hash-算法保证-key-存储在同一节点">1.1 hash 算法保证 key 存储在同一节点</h3>
<p>随机节点获取数据，若不存在从数据源获取数据并缓存；</p>
<p>再次随机节点获取数据具有不确定性</p>
<h3 id="12-节点数量变化">1.2 节点数量变化</h3>
<p><code>缓存雪崩</code>：某节点失效后在收到请求时，均需要从数据源重新获取数据</p>
<h3 id="13-一致性-hash-算法">1.3 一致性 hash 算法</h3>
<p>将<code>key</code>映射到2^32空间内，形成环</p>
<ul>
<li>
<p>节点/机器的 hash 值放在环上</p>
</li>
<li>
<p>计算<code>key</code>的哈希值，放置在环上，顺时针找到的第一个节点即为应选择的节点/机器</p>
</li>
<li>
<p><strong>数据倾斜问题</strong></p>
<ul>
<li>引入虚拟节点，一个真实结点对应多个虚拟节点</li>
<li>计算虚拟节点的 hash 值放置在环上</li>
<li>计算 key的 hash 值在环上顺时针寻找应该选取的虚拟节点</li>
</ul>
<p>虚拟节点有效扩充了及诶单的数量解决节点数量较少情况下的数据倾斜问题；</p>
<p>只需增加<code>map</code>维护真实节点与虚拟节点之间的关系即可</p>
</li>
</ul>
<h2 id="02-语言实现">02 语言实现</h2>
<h3 id="21-consistenthash">2.1 consistenthash</h3>
<pre><code class="language-go">type (
	Hash func(data[]byte) uint32
	Map struct {
		hash Hash
		replicas int
		keys []int
		hashMap map[int]string
	}
)

func New(replicas int, fn Hash) *Map  {
	m:=&amp;Map{
		hash: fn,
		replicas: replicas,
		hashMap: make(map[int]string),
	}
	if m.hash == nil {
		m.hash=crc32.ChecksumIEEE
	}
	return m
}
</code></pre>
<ol>
<li>定义函数类型<code>Hash</code> 依赖注入的方式，默认为<code>crc32.ChechsumIEEE</code></li>
<li>构造函数<code>New()</code>允许自定义虚拟节点和 Hash 函数</li>
</ol>
<h3 id="22-add-真实节点机器">2.2 Add 真实节点/机器</h3>
<ol>
<li>传入多个真实节点的名称</li>
<li>对应每个真实节点<code>key</code>，创建<code>m.replicas</code>个虚拟节点，虚拟节点名称为<code>strconv.Itoa(i)+key</code>，通过编号区分；</li>
<li><code>m.hash()</code>计算虚拟节点的 hash 值——&gt;添加到环上<code>append(m.keys,hash)</code></li>
<li><code>hashMap</code>添加虚拟和真实节点之间的映射</li>
<li>环上哈希值排序</li>
</ol>
<pre><code class="language-go">func (m *Map) Add(keys ...string) {
	for _, key := range keys {
		for i := 0; i &lt; m.replicas; i++ {
			hash := int(m.hash([]byte(strconv.Itoa(i) + key)))
			m.keys = append(m.keys, hash)
			m.hashMap[hash] = key
		}
	}
	sort.Ints(m.keys)
}
</code></pre>
<h3 id="23-选择节点-get-方法">2.3 选择节点 Get 方法</h3>
<pre><code class="language-go">func (m *Map) Get(key string) string {
	if len(m.keys) == 0 {
		return &quot;&quot;
	}
	hash := int(m.hash([]byte(key)))
    // func Search(n int, f func(int)bool) int 
    // 在[0,n）内二分查找满足 f 条件的最小下标
	index := sort.Search(len(m.keys), func(i int) bool {
		return m.keys[i] &gt;= hash
	})
	return m.hashMap[m.keys[index%len(m.keys)]]
}
</code></pre>
<ol>
<li>计算 key 的哈希值<code>hash:=int(m.hash([]byte(key)))</code></li>
<li>顺时针查找第一个匹配的虚拟节点的下标<code>index</code> ，使用<code>sort.Search(len(环长,fn))</code></li>
<li>由于 keys为环状，故取余</li>
<li>在<code>m.keys[]</code>找到对应的哈希值，通过哈希值在 <code>hashMap</code>中的映射得到真实节点</li>
</ol>
<ul>
<li>注册节点 register peers，通过一致性哈希算法选择节点</li>
<li>实现<code>HTTP</code>客户端与远程节点的服务端通信</li>
</ul>
<h2 id="00-概述-2">00 概述</h2>
<p>对于未被缓存的 key 从远程节点调用</p>
<pre><code>使用一致性哈希选择节点        是                                    是
    |-----&gt; 是否是远程节点 -----&gt; HTTP 客户端访问远程节点 --&gt; 成功？-----&gt; 服务端返回返回值
                    |  否                                    ↓  否
                    |----------------------------&gt; 回退到本地节点处理。
</code></pre>
<h2 id="01-抽象peerpicker">01 抽象PeerPicker</h2>
<ol>
<li>抽象接口，对 PeerPicker 的<code>PickPeer()</code>方法参考传入key 选择相应的结点<code>PeerGetter</code></li>
<li>接口<code>PeerGetter</code> 的<code>Get()</code>方法从<code>group</code>查找缓存值，<code>PeerGetter</code>即为<code>HTTP 客户端</code></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计网笔记记录]]></title>
        <id>https://flyingchase.github.io/post/ji-wang-bi-ji-ji-lu/</id>
        <link href="https://flyingchase.github.io/post/ji-wang-bi-ji-ji-lu/">
        </link>
        <updated>2021-10-31T13:54:35.000Z</updated>
        <content type="html"><![CDATA[<p>收集于互联网，侵删</p>
<h1 id="计网八股文">计网八股文</h1>
<h2 id="osi-参考模型">OSI 参考模型</h2>
<p>OSI 从上到下分为 7 层：</p>
<p>应用层：应用层协议定义的是应用进程间的通信和交互的规则，不同的网络应用需要不同的应用层协议<br>
表示层：把数据转换为能与接收者的系统格式兼容并适合传输的格式<br>
会话层：在数据传输中设置和维护电脑网络中两台电脑之间的通信连接<br>
传输层：向两台主机进程之间的通信提供通用的数据传输服务<br>
网络层：基于网络层地址（IP地址）进行不同网络系统间的路径选择<br>
数据链路层：在不可靠的物理介质上提供可靠的传输<br>
物理层：在局域网上透明地传送比特，尽可能屏蔽掉具体传输介质和物理设备的差异</p>
<h2 id="tcpip-参考模型">TCP/IP 参考模型</h2>
<p>从上到下分为 4 层，对应于 OSI 中的 5 层：</p>
<ol>
<li>应用层：对应于 OSI 参考模型的应用层，为用户提供所需要的各种服务。定义的是应用进程间的通信和交互的规则，不同的网络应用需要不同的应用层协议。协议包括 SMTP、HTTP、FTP 等</li>
<li>传输层：对应于 OSI 参考模型的传输层，为应用层实体提供端到端的、通用的通信功能，保证了数据包的顺序传送及数据的完整性。“通用的”是指不同的应用可以使用同一个运输层服务。协议包括 TCP、UDP 等</li>
<li>网络层（或网际互联层）：对应于 OSI 参考模型的网络层，主要解决主机到主机的路由问题。协议包括 IP、ICMP 等</li>
<li>网络接入层：对应于 OSI 参考模型的物理层和数据链路层，负责相邻的物理节点间的可靠数据传输。协议包括 ARP、IEEE 802.2 等</li>
</ol>
<h2 id="tcpip-参考模型各层常见协议">TCP/IP 参考模型各层常见协议</h2>
<figure data-type="image" tabindex="1"><img src="/Users/qlzhou/Desktop/protocol.png" alt="protocol" loading="lazy"></figure>
<p>![5cKLtR](/Users/qlzhou/Desktop/TCP 参考模型各层协议.png)</p>
<p>将“网络接入层”进一步分为“数据链路层”与“物理层”，得到五层协议模型。各层的常见协议如下：</p>
<table>
<thead>
<tr>
<th>TCP/IP 协议层</th>
<th>协议</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层</td>
<td>HTTP</td>
<td>超文本传输协议（HyperText Transfer Protocol）</td>
</tr>
<tr>
<td></td>
<td>FTP</td>
<td>文件传输协议（File Transfer Protocol）用于在客户端和服务器之间进行文件传输</td>
</tr>
<tr>
<td></td>
<td>SMTP</td>
<td>文件传输协议（File Transfer Protocol）用于在客户端和服务器之间进行文件传输</td>
</tr>
<tr>
<td></td>
<td>TELNET</td>
<td>Telnet 是服务器远程登录控制的标准协议与主要方式</td>
</tr>
<tr>
<td></td>
<td>DNS</td>
<td>域名系统（Domain Name System）是域名和 IP 地址相互映射的分布式数据库</td>
</tr>
<tr>
<td></td>
<td>SSH</td>
<td>安全外壳协议（Secure Shell）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境</td>
</tr>
<tr>
<td></td>
<td>DHCP</td>
<td>动态主机配置协议（Dynamic Host Configuration Protocol）的主要作用是集中管理、动态分配 IP 地址，提升地址的使用率</td>
</tr>
<tr>
<td>传输层</td>
<td>TCP</td>
<td>传输控制协议（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议</td>
</tr>
<tr>
<td></td>
<td>UDP</td>
<td>用户数据报协议（User Datagram Protocol）是一个简单的、无连接的、不可靠的、面向数据报的通信协议</td>
</tr>
<tr>
<td>网络层</td>
<td>IP</td>
<td>网际协议（Internet Protocol）是用于分组交换数据网络的一种协议，功能包括寻址、路由、尽最大努力交付数据包</td>
</tr>
<tr>
<td></td>
<td>ICMP</td>
<td>互联网控制消息协议（Internet Control Message Protocol）用于返回通信环境的错误消息。traceroute 和 ping 都是基于 ICMP 消息实现的，traceroute 是通过发送含有特殊 TTL 的包，然后接收 ICMP 超时消息和目标不可达消息来实现的；ping 则是用 ICMP 的“Echo request (8)”和“Echo reply (0)”消息来实现的</td>
</tr>
<tr>
<td></td>
<td>IGMP</td>
<td>因特网组管理协议（Internet Group Management Protocol ）管理 IP 协议多播组成员</td>
</tr>
<tr>
<td></td>
<td>RIP</td>
<td>路由信息协议（Routing Information Protocol）是一种内部网关协议（IGP），是距离向量路由协议的一种实现</td>
</tr>
<tr>
<td></td>
<td>OSFP</td>
<td>开放式最短路径优先（Open Shortest Path First）是一种内部网关协议（IGP），使用 Dijkstra 算法计算最短路径，是链路状态路由协议的一种实现</td>
</tr>
<tr>
<td></td>
<td>BGP</td>
<td>边界网关协议（Border Gateway Protocol）是互联网上一个核心的去中心化自治路由协议，属于矢量路由协议。BGP 用于互联网上，将自治系统视作一个整体；每个自治系统使用 IGP（代表实现有 RIP 和 OSPF）进行路由</td>
</tr>
<tr>
<td>数据链路层</td>
<td>ARP*</td>
<td>地址解析协议（Address Resolution Protocol）通过 IP 寻找 MAC 地址</td>
</tr>
<tr>
<td></td>
<td>ARQ</td>
<td>自动重传请求（Automatic Repeat-reQuest）是一种错误纠正协议</td>
</tr>
<tr>
<td>物理层</td>
<td>IEEE802</td>
<td>IEEE 802 指 IEEE 标准中关于局域网和城域网的一系列标准，其中最广泛使用的有以太网、令牌环、无线局域网等</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>ARP 协议</strong>：ARP 协议应该属于哪一层？一种说法是属于网络层，因为 IP 协议使用 ARP 协议；另一种说法是属于数据链路层，因为 MAC 地址是数据链路层的内容。在 OSI 模型中，ARP 协议属于链路层；而在 TCP/IP 模型中，ARP 协议属于网络层。</li>
</ul>
<h2 id="集线器-网桥-交换机-路由器">集线器、网桥、交换机、路由器</h2>
<ol>
<li>网线是物理层的硬件</li>
<li>集线器（Hub）是物理层的硬件，连接所有的线路，广播所有信息</li>
<li>网桥（Bridge）是数据链路层的硬件。网桥隔离两个端口，不同的端口形成单独的冲突域，减少网内冲突。网桥在不同或相同类型的 LAN 之间存储并转发数据帧，根据 MAC 头部来决定转发端口，显然是数据链路层的设备</li>
<li>交换机（Switch）是数据链路层的硬件，相当于多端口的网桥。交换机内部存储 MAC 表，只会将数据帧发送到指定的目的地址</li>
<li>路由器（Router）是网络层的硬件，根据 IP 地址进行寻址，不同子网间的数据传输隔离</li>
</ol>
<h2 id="比特-帧-数据包-数据段-报文">比特、帧、数据包、数据段、报文</h2>
<p>PDU：Prtocol data unit，协议数据单元，指对等层协议之间交换的信息单元。PDU 再往上就是数据（data）。</p>
<p>在 OSI 模型里，PDU 和底下四层相关：</p>
<ol>
<li>物理层———<strong>比特（Bit）</strong></li>
<li>数据链路层———<strong>帧（Frame）</strong></li>
<li>网络层———<strong>分组、数据包（Packet）</strong></li>
<li>传输层———<strong>数据段（Segment）</strong></li>
</ol>
<p>第五层或以上为<strong>数据（data）</strong>。也有一种说法是，应用层的信息称为<strong>消息、报文（message）</strong>，表示完整的信息。</p>
<h2 id="msl-ttl-rtt-是什么">MSL、TTL、RTT 是什么？</h2>
<p><strong>MSL</strong>（Maximum segment lifetime）：报文最大生存时间。它是任何 TCP 报文在网络上存在的最长时间，超过这个时间报文将被丢弃。实际应用中常用的设置是 30 秒，1 分钟和 2 分钟。</p>
<ol>
<li>应用场景：TCP 四次挥手时，需要在 TIME-WAIT 状态等待 2MSL 的时间，可以保证本次连接产生的所有报文段都从网络中消失。</li>
</ol>
<p><strong>TTL</strong>（Time to live）：IP 数据报在网络中可以存活的总跳数，称为“生存时间”，但并不是一个真正的时间。该域由源主机设置初始值，每经过一个路由器，跳数减 1，如果减至 0，则丢弃该数据包，同时发送 ICMP 报文通知源主机。取值范围 1-255，如果设置的 TTL 值小于传输过程中需要经过的路由器数量，则该数据包在传输中就会被丢弃。</p>
<p><strong>RTT</strong>（Round trip time）：客户端到服务端往返所花时间。RTT 受网络传输拥塞的变化而变化，由 TCP <strong>动态地估算</strong>。</p>
<h2 id="tcp-的流量控制和拥塞控制">TCP 的流量控制和拥塞控制</h2>
<figure data-type="image" tabindex="2"><img src="/Users/qlzhou/Desktop/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%B4%A0%E6%98%82.png" alt="NrFurg" loading="lazy"></figure>
<pre><code class="language-markdown">1. TCP 的流量控制机制
   - 滑动窗口的原理
   - 零窗口
   - Nagle 算法

2. TCP 的拥塞控制机制
   - 慢启动
     - 每收到一个 ACK，窗口大小+1，倍增
   - 拥塞避免
   - 超时重传
     - 丢包时，慢启动阈值设定为窗口大小的一半
   - 快速重传 / 快速恢复
     - 收到三个重复的 ACK 消息
</code></pre>
<h2 id="tcp-标志位">TCP 标志位：</h2>
<p>TPC 标志位代表了当前请求的目的。一共有六种：</p>
<ol>
<li><strong>SYN</strong>（synchronous）： 发送/同步标志，用来建立连接，和 ACK 标志位搭配使用。A 请求与 B 建立连接时，SYN=1，ACK=0；B 确认与 A 建立连接时，SYN=1，ACK=1</li>
<li><strong>ACK</strong>（acknowledgement）：确认标志，表示确认收到请求</li>
<li>PSH（push） ：表示推送操作，就是指数据包到达接收端以后，不对其进行队列处理，而是尽可能的将数据交给应用程序处理</li>
<li><strong>FIN</strong>（finish）：结束标志，表示关闭一个 TCP 连接</li>
<li>RST（reset）：重置复位标志，用于复位对应的 TCP 连接</li>
<li>URG（urgent）：紧急标志，用于保证 TCP 连接不被中断，并且督促中间层设备尽快处理</li>
</ol>
<h2 id="tcp-序列号-确认号">TCP 序列号、确认号</h2>
<pre><code class="language-markdown">### 作用
序列号和确认号是 TCP 实现可靠传输的依赖。TCP 使用序列号来记录发送数据包的顺序。TCP 传送一个数据包后，只有在指定时间里收到这个包的确认信息，才会将其从队列中删除，否则会重新发送该数据包。对接收方而言，通过数据分段中的序列号可以保证数据能够按照正常的顺序进行重组。

### 序列号 Sequence Number
- 在 SYN flag 置 1 时，表示当前连接的初始序列号（Initial Sequence Number，ISN）
- 在 SYN flag 置 0 时，表示当前报文段中的第一个字节的序列号

序列号的规则：

- 握手阶段，`[SYN]` 包即使没有传送数据，也会消耗一个序列号。因此，建立连接后的序列号从 `ISN+1` 开始
- 挥手阶段，`[FIN/ACK]` 包即使没有传送数据，也会消耗掉一个序列号
- 数据传输阶段，序列号 = 第一个报文段的序列号 + 已经发送的字节数
  - 比如第一个报文段的序列号为 `S`，已经发送了 100 个字节，则下一个报文段的序列号为 `S+100`
  - 如果某个报文段不携带数据，不会消耗序列号，下一个报文段还是用相同的序列号发送
  - 正常情况下，B 给 A 的确认号，就是 A 下一个报文段的序列号
- 客户端三次握手第三步的 `[ACK]` 包，和传输阶段的第一个报文段，有相同的序列号

### 确认号 Acknowledge Number
- ACK flag 置 1 时才有效，表示接收方期待的下一个报文段的序列号。一般是上次收到的报文段 seq + 1
</code></pre>
<h2 id="三次握手">三次握手</h2>
<h3 id="三次握手过程">三次握手过程</h3>
<img src="/Users/qlzhou/Desktop/A.png" alt="A" style="zoom:70%;" />
<ol>
<li>第一次握手：客户端请求建立连接，向服务端发送一个<strong>同步报文</strong>（SYN synchronous 标志位记为1），同时选择一个随机数 seq（sequence number） = x 作为<strong>初始序列号</strong></li>
<li>第二次握手：服务端收到连接请求报文后，如果同意建立连接，则向客户端发送<strong>同步确认报文</strong>（SYN synchronous为1，ACK acknowledgement 为1），确认号为 ack acknowledge number 为x + 1，同时选择一个随机数 seq sequence number 为y 作为<strong>初始序列号</strong></li>
<li>第三次握手：客户端收到服务端的确认后，向服务端发送一个<strong>确认报文</strong>（ACK标志位 acknowledgement为1），确认号为 ack acknowledge number 为y + 1，序列号为 seq sequence number 为x + 1</li>
</ol>
<p>这时就完成了三次握手，连接建立成功。随后，客户端和服务端的序列号将分别从 <code>x+1</code> 和 <code>y+1</code> 开始进行传输。</p>
<p>客户端在两次握手就进入<code>ESTABLISHED</code>状态，服务端在三次握手后再进入<code>ESTABLISHED</code>状态，故而第三次ACK 可捎带客户端数据一起发送</p>
<h2 id="为什么需要三次握手而不是两次或四次">为什么需要三次握手，而不是两次或四次？</h2>
<figure data-type="image" tabindex="3"><img src="/Users/qlzhou/Desktop/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="F3KgOu" loading="lazy"></figure>
<p>如果只有两次握手，那么服务端向客户端发送 SYN/ACK 报文后，就会认为连接建立。但是如果客户端没有收到报文，那么客户端是没有建立连接的。这就导致服务端会浪费资源。</p>
<ol>
<li>
<p>确认双方的收发能力正常；</p>
</li>
<li>
<p>序号同步的确定性；</p>
<p>缺少最后一次 ACK 则服务端无法确定对方是否收到自己的初始序号，</p>
<p>数据包的序号是 TCP滑动窗口机制的基本字段</p>
</li>
<li>
<p>历史失效链接请求的乱序问题</p>
<p>老的失效请求连接延迟，此时到达服务端，无第三次握手则服务端即开启新的连接进入 ESTABLISHED 状态，有三次握手则会发生 RST 标志 restet 终止连接</p>
</li>
</ol>
<p>为什么不是四次握手？理论上我们总可以使用更多的通信次数交换相同的信息，使用两次握手无法建立 TCP 连接，而使用三次握手是建立连接所需要的最小次数：</p>
<ol>
<li>第一次握手：服务端确认“自己收、客户端发”报文功能正常</li>
<li>第二次握手：客户端确认“自己发、自己收、服务端收、客户端发”报文功能正常，客户端认为连接已建立</li>
<li>第三次握手：服务端确认“自己发、客户端收”报文功能正常，此时双方均建立连接，可以正常通信</li>
</ol>
<h2 id="tcp-第三次握手丢包">TCP 第三次握手丢包</h2>
<p>丢包则触发 TCP重传机制：</p>
<ol>
<li>重试一定次数后，服务端管理连接；</li>
<li>客户端认为建立连接，发送数据；</li>
<li>服务端回复 RST 报文，则客户端知悉链接失效</li>
</ol>
<h2 id="什么是-syn-攻击如何防范">什么是 SYN 攻击？如何防范？</h2>
<p>SYN 攻击属于 DOS 攻击的一种，它利用 TCP 协议缺陷，通过发送大量的半连接请求，耗费 CPU 和内存资源。</p>
<p>原理：</p>
<ol>
<li>在三次握手过程中，服务器发送 <code>[SYN/ACK]</code> 包（第二个包）之后、收到客户端的 <code>[ACK]</code> 包（第三个包）之前的 TCP 连接称为半连接（half-open connect），此时服务器处于 <code>SYN_RECV</code>（等待客户端响应）状态。如果接收到客户端的 <code>[ACK]</code>，则 TCP 连接成功，如果未接受到，则会<strong>不断重发请求</strong>直至成功</li>
<li>SYN 攻击的攻击者在短时间内<strong>伪造大量不存在的 IP 地址</strong>，向服务器不断地发送 <code>[SYN]</code> 包，服务器回复 <code>[SYN/ACK]</code> 包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时</li>
<li>这些伪造的 <code>[SYN]</code> 包将长时间占用未连接队列，影响了正常的 SYN，导致目标系统运行缓慢、网络堵塞甚至系统瘫痪</li>
</ol>
<p>检测：当在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。</p>
<p>防范：主要有两大类，一类是通过防火墙、路由器等过滤网关防护，另一类是通过加固 TCP/IP 协议栈防范，如增加最大半连接数，缩短超时时间。但 SYN 攻击不能完全被阻止，除非将 TCP 协议重新设计，否则只能尽可能的减轻 SYN 攻击的危害。</p>
<h2 id="四次挥手">四次挥手</h2>
<h3 id="四次挥手过程">四次挥手过程</h3>
<img src="/Users/qlzhou/Desktop/B.png" alt="B" style="zoom:80%;" />
<ol>
<li>第一次挥手：客户端向服务端发送连接释放报文（FIN=1，ACK=1），主动关闭连接，同时等待服务端的确认，客户端加入 FIN_WAIT_1
<ol>
<li>序列号 seq = X，即客户端上次发送的报文的最后一个字节的序号 + 1</li>
<li>确认号 ack = Y, 即服务端上次发送的报文的最后一个字节的序号 + 1</li>
</ol>
</li>
<li>第二次挥手：服务端收到连接释放报文后，立即发出<strong>确认报文</strong>（ACK=1），序列号 seq = Y，确认号 ack = X + 1，服务端进入 CLOSE_WAIT，客户端收到后进入FIN_WAIT_2</li>
</ol>
<p>这时 TCP 连接处于半关闭状态，即客户端到服务端的连接已经释放了，但是服务端到客户端的连接还未释放。这表示客户端已经没有数据发送了，但是服务端可能还要给客户端发送数据。</p>
<ol start="3">
<li>第三次挥手：服务端向客户端发送连接释放报文（FIN=1，ACK=1），主动关闭连接，同时等待 A 的确认，客户端进入 LAST_WAIT
<ol>
<li>序列号 seq = w(未发送数据则 w==Y)，即服务端上次发送的报文的最后一个字节的序号 + 1。如果半关闭状态，服务端没有发送数据，那么 w == Y</li>
<li>确认号 ack = X + 1，与第二次挥手相同，因为这段时间客户端没有发送数据</li>
</ol>
</li>
<li>第四次挥手：客户端收到服务端的连接释放报文后，立即发出<strong>确认报文</strong>（ACK=1），序列号 seq = X + 1，确认号为 ack = w + 1，客户端进入 TIME_WAIT</li>
</ol>
<p>此时，客户端就进入了 <code>TIME-WAIT</code> 状态。注意此时客户端到 TCP 连接还没有释放，必须经过 2*MSL（最长报文段生命周期）的时间后，才进入 <code>CLOSED</code> 状态。而服务端只要收到客户端发出的确认，就立即进入 <code>CLOSED</code> 状态。可以看到，服务端结束 TCP 连接的时间要比客户端早一些。</p>
<p>TCP 规定，<code>[FIN/ACK]</code> 包即使没有传送数据，也会消耗掉一个序列号。<code>[FIN/ACK]</code> 包是第一、三次挥手：</p>
<ol>
<li>第一次挥手时，客户端的序列号 seq = X，消耗一个序列号。因此：
<ol>
<li>第二次挥手时，服务端的确认号 ack = X + 1</li>
<li>第四次挥手时，客户端的序列号 seq = X + 1</li>
</ol>
</li>
<li>第三次挥手时，服务端的序列号 seq = w，消耗一个序列号。因此：
<ol>
<li>第四次挥手时，客户端的确认号 ack = w + 1</li>
</ol>
</li>
</ol>
<h2 id="为什么第四次挥手客户端的-time-wait-状态必须等待-2msl-的时间才能返回到-closed-状态">为什么第四次挥手，客户端的 TIME-WAIT 状态必须等待 2MSL 的时间才能返回到 CLOSED 状态？</h2>
<p>为什么四次挥手——&gt;因为 <strong>TCP 是全双工的</strong>，一方关闭连接后，另一方还可以继续发送数据。所以四次挥手，将断开连接分成两个独立的过程。</p>
<p>2MSL——&gt;主要有两个原因：</p>
<p>(1) 确保 ACK 报文能够到达服务端，从而使服务端正常关闭连接。</p>
<p>第四次挥手时，客户端第四次挥手的 ACK 报文不一定会到达服务端。服务端会超时重传 FIN/ACK 报文，此时如果客户端已经断开了连接，那么就无法响应服务端的二次请求，这样服务端迟迟收不到 FIN/ACK 报文的确认，就无法正常断开连接。</p>
<p>MSL 是报文段在网络上存活的最长时间。客户端等待 2MSL 时间，即「客户端 ACK 报文 1MSL 超时 + 服务端 FIN 报文 1MSL 传输」，就能够收到服务端重传的 FIN/ACK 报文，然后客户端重传一次 ACK 报文，并重新启动 2MSL 计时器。如此保证服务端能够正常关闭。</p>
<p>那如果服务端重发的 FIN 没有成功地在 2MSL 时间里传给客户端，会怎样？服务端会继续超时重试直到断开连接，见下文。</p>
<p>(2) 防止已失效的连接请求报文段出现在之后的连接中。</p>
<p>TCP 要求在 2MSL 内不使用相同的序列号。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以保证本连接持续的时间内产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。或者即使收到这些过时的报文，也可以不处理它。</p>
<h2 id="如果已经建立了连接但是客户端出现故障了怎么办">如果已经建立了连接，但是客户端出现故障了怎么办？</h2>
<p>或者说，如果三次握手阶段、四次挥手阶段的包丢失了怎么办？比如上面描述的“服务端重发 FIN”的问题。</p>
<p>简而言之，通过<strong>定时器 + 超时重试机制</strong>，尝试获取确认，直到最后会自动断开连接。</p>
<p>具体而言，TCP 设有一个保活计时器。服务器每收到一次客户端的数据，都会重新复位这个计时器，时间通常是设置为 2 小时。若 2 小时还没有收到客户端的任何数据，服务器就开始重试：每隔 75 分钟发送一个探测报文段，若一连发送 10 个探测报文后客户端依然没有回应，那么服务器就认为连接已经断开了。</p>
<h2 id="tcp-的粘包问题">TCP 的粘包问题</h2>
<p>TCP 是基于字节流的，数据块是没有边界、没有结构的字节流，因此可能产生粘包：</p>
<ol>
<li>
<p>发送方为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小、数据量小的数据包，合并成一个大的数据包一次性发送。</p>
<p>当应用层协议通过 TCP 协议传输数据时，实际上待发送的数据先被写入了 TCP 协议的缓冲区，如果用户开启了 Nagle 算法，那么 TCP 协议可能不会立刻发送写入的数据，它会等待缓冲区中数据超过最大数据段（MSS）或者上一个数据段被 ACK 时才会发送缓冲区中的数据。</p>
</li>
<li>
<p>接收方不能及时读取数据，导致缓冲区中的多个包粘连。</p>
</li>
</ol>
<p><strong>解决方法</strong>：</p>
<ol>
<li>发送方关闭 Nagle 算法</li>
<li>应用层定义消息边界，最常见的两种解决方案就是基于长度或者基于终结符（Delimiter）
<ol>
<li>基于长度的实现有两种方式，一种是使用固定长度；另一种方式是使用不固定长度，但是需要在应用层协议的协议头中增加表示负载长度的字段，HTTP 协议的消息边界就是基于长度实现的</li>
<li>HTTP 协议除了使用基于长度的方式实现边界，也会使用基于终结符的策略，当 HTTP 使用块传输（Chunked Transfer）机制时，HTTP 头中就不再包含 Content-Length 了，它会使用负载大小为 0 的 HTTP 消息作为终结符表示消息的边界</li>
</ol>
</li>
</ol>
<p>除了这两种方式之外，我们可以基于特定的规则实现消息的边界，例如：使用 TCP 协议发送 JSON 数据，接收方可以根据接收到的数据是否能够被解析成合法的 JSON 判断消息是否终结。</p>
<p>但值得注意的是，<strong>粘包并不是 TCP 协议本身的“问题”，而是一个“现象”</strong>。TCP 本身面向字节流的特性，导致会有所谓的“粘包”问题，需要应用层进行拆分。所以也有一种说法是“TCP 粘包是一个伪命题”。</p>
<p>**为什么 UDP 协议没有粘包问题？**UDP 是面向报文的，应用层交给 UDP 多长的报文，UDP 就照样发送，既不合并，也不拆分，而是保留这些报文的边界。</p>
<h2 id="tcp-如何保证传输的可靠性">TCP 如何保证传输的可靠性？</h2>
<ol>
<li>序列号：解决乱序问题</li>
<li>确认号 / 超时重传机制：解决丢包问题</li>
</ol>
<h2 id="tcp-udp-对比">TCP、UDP 对比</h2>
<ol>
<li>TCP：面向连接的、可靠的、基于字节流的传输层通信协议</li>
<li>UDP：无连接的、不可靠的、基于报文的传输层通信协议</li>
<li>面向字节流：TCP 将要发送的数据视为无结构的字节流，如果发送的数据太长，就拆分发送，如果发送的数据太短，则积累较多的字节后再发送</li>
<li>面向报文：UDP 一次发送一个报文，不管多大，都以报文为发送单位</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody>
<tr>
<td>连接性</td>
<td>面向连接</td>
<td>无连接</td>
</tr>
<tr>
<td>可靠性</td>
<td>可靠</td>
<td>不可靠</td>
</tr>
<tr>
<td>传输方式</td>
<td>面向字节流</td>
<td>面向报文（保留报文的边界）</td>
</tr>
<tr>
<td>传输速度</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>双工性</td>
<td>全双工</td>
<td>一对一、一对多、多对一、多对多</td>
</tr>
<tr>
<td>流量控制 / 拥塞控制</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>应用场景</td>
<td>对效率要求相对低，但是对准确性要求高的场景；或是要求有连接的场景。如文件传输、发送邮件等</td>
<td>对效率要求相对高，对准确性要求相对低的场景。如即时通信、直播等</td>
</tr>
<tr>
<td>应用层协议</td>
<td>SMTP（电子邮件）、TELNET（远程登录控制）、HTTP、FTP</td>
<td>DNS、TFTP（文件传输）、DHCP（动态主机配置）...</td>
</tr>
</tbody>
</table>
<h2 id="http-请求方法">HTTP 请求方法</h2>
<p>HTTP 请求方法表明了要对给定资源执行的<strong>操作</strong>，每一个请求方法都实现了不同的<strong>语义</strong>。包括：GET、HEAD、POST、PUT、PATCH、DELETE、OPTIONS，以及不常用的 CONNECT、TRACE。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>获取数据</td>
</tr>
<tr>
<td>HEAD</td>
<td>与 <code>GET</code> 类似，但<strong>只返回响应头</strong></td>
</tr>
<tr>
<td>POST</td>
<td>提交表单</td>
</tr>
<tr>
<td>PUT</td>
<td>用一个新的资源<strong>完全替换</strong>掉服务器的资源</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除资源</td>
</tr>
<tr>
<td>CONNECT</td>
<td>建立一个 tunnel</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>询问服务器支持哪些方法</td>
</tr>
<tr>
<td>TRACE</td>
<td>发起环回诊断，主要用于诊断</td>
</tr>
<tr>
<td>PATCH</td>
<td>对服务器资源进行<strong>部分更新</strong></td>
</tr>
</tbody>
</table>
<h2 id="get-和-post-的区别">GET 和 POST 的区别</h2>
<table>
<thead>
<tr>
<th></th>
<th>GET</th>
<th>POST</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用</td>
<td>获取服务器的指定数据</td>
<td>添加 / 修改服务器的数据</td>
</tr>
<tr>
<td>历史记录 / 书签</td>
<td>可保留在浏览器历史记录中，或者收藏为书签</td>
<td>不可以</td>
</tr>
<tr>
<td>Cacheable</td>
<td>会被浏览器缓存</td>
<td>不会缓存</td>
</tr>
<tr>
<td>幂等</td>
<td>幂等，不会改变服务器上的资源</td>
<td>非幂等，会对服务器资源进行改变</td>
</tr>
<tr>
<td>后退 / 刷新</td>
<td>后退或刷新时，GET 是无害的</td>
<td>后退或刷新时，POST 会重新提交表单</td>
</tr>
<tr>
<td>参数位置</td>
<td>query 中（直接明文暴露在链接中）</td>
<td>query 或 body 中</td>
</tr>
<tr>
<td>参数长度</td>
<td>2KB（2048 个字符）</td>
<td>无限制</td>
</tr>
</tbody>
</table>
<h2 id="cookie-与-session-的区别">Cookie 与 Session 的区别</h2>
<p>二者都是用来跟踪浏览器用户身份的会话方式。</p>
<p>Cookie：</p>
<ol>
<li>存在浏览器里，可以设置过期时间</li>
<li>每次访问服务器时，浏览器会自动在 header 中携带 cookie</li>
<li>如果浏览器禁用了 cookie，可以使用 <strong>URL 重写机制</strong>，将信息保存在 URL 里</li>
</ol>
<p>Session:</p>
<ol>
<li>存在服务端，由服务器维护，一段时间后 session 就失效了</li>
<li><strong>本质上，session 还是通过 cookie 实现的</strong>。浏览器的 cookie 中只保存一个 <code>sessionId</code>，所有其他信息均保存在服务端，由 <code>sessionId</code> 标识</li>
<li>Session 失效，其实是服务器设置了失效时间。如果用户长时间不和服务器交互（比如 30 分钟），那么 session 就会被销毁；交互的话，就会刷新 session</li>
</ol>
<h2 id="从输入一个-url-到页面加载完成的过程">从输入一个 URL 到页面加载完成的过程</h2>
<img src="/Users/qlzhou/Desktop/C.png" alt="C" style="zoom:87%;" />
<ol>
<li>用户在某个标签页输入 URL 并回车后，浏览器主进程会新开一个网络线程，发起 HTTP 请求</li>
<li>浏览器会进行 DNS 查询，将域名解析为 IP 地址</li>
<li>浏览器获得 IP 地址后，向服务器请求建立 TCP 连接</li>
<li>浏览器向服务器发起 HTTP 请求</li>
<li>服务器处理请求，返回 HTTP 响应</li>
<li>浏览器的渲染进程解析并绘制页面</li>
<li>如果遇到 JS/CSS/图片 等静态资源的引用链接，重复上述过程，向服务器请求这些资源</li>
</ol>
<h2 id="介绍一下-http-协议">介绍一下 HTTP 协议</h2>
<p>HTTP 协议是<strong>基于 TCP 协议</strong>实现的，它是一个<strong>超文本传输协议</strong>，其实就是一个简单的请求-响应协议，它<strong>指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应</strong>。</p>
<p>它主要是<strong>负责点对点之间通信</strong>的。</p>
<p><strong>超文本</strong>就是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本。比如说html，内部定义了很多图片视频的链接，放在浏览器上就呈现出了画面。</p>
<p><strong>协议</strong>就是约定俗称的东西，比如说 moon 要给读者送一本书，读者那里只接受顺丰快递，那么 moon 觉得可以，发快递的时候选择的顺丰，那么我们彼此之间共同约定好的就叫做协议。</p>
<p><strong>传输</strong>这个就很好理解了，比如刚才举的例子，将书发给读者，要通过骑车或者飞机的方式，传递的这个过程就是运输。</p>
<h2 id="get-和-post有什么区别">GET 和 POST有什么区别？</h2>
<p><strong>GET 和 POST 本质上就是 TCP 链接，并无差别。</strong></p>
<p><strong>但是由于 HTTP 的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">区别</th>
<th style="text-align:center">GET</th>
<th style="text-align:right">POST</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">数据传输方式</td>
<td style="text-align:center">从服务器获取数据</td>
<td style="text-align:right">向服务器提交数据</td>
</tr>
<tr>
<td style="text-align:left">对数据长度的限制</td>
<td style="text-align:center">当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）</td>
<td style="text-align:right">无限制</td>
</tr>
<tr>
<td style="text-align:left">对数据类型的限制</td>
<td style="text-align:center">只允许 ASCII 字符</td>
<td style="text-align:right">无限制</td>
</tr>
<tr>
<td style="text-align:left">安全性</td>
<td style="text-align:center">较差，所发送的数据是 URL 的一部分，会显示在网页上</td>
<td style="text-align:right">较好 参数不会被保存在浏览器历史或 WEB 服务器日志中</td>
</tr>
<tr>
<td style="text-align:left">可见性</td>
<td style="text-align:center">显示在 URL 上</td>
<td style="text-align:right">不显示</td>
</tr>
<tr>
<td style="text-align:left">收藏为书签</td>
<td style="text-align:center">可以</td>
<td style="text-align:right">不可以</td>
</tr>
<tr>
<td style="text-align:left">历史记录</td>
<td style="text-align:center">可以被保留在历史记录当中</td>
<td style="text-align:right">不可以被保留</td>
</tr>
<tr>
<td style="text-align:left">缓存</td>
<td style="text-align:center">能被缓存</td>
<td style="text-align:right">不可以被缓存</td>
</tr>
</tbody>
</table>
<h2 id="ping-的作用">PING 的作用？</h2>
<p>PING 主要的作用就是<strong>测试在两台主机之间能否建立连接</strong>，如果 PING 不通就无法建立连接。</p>
<p>它其实就是向目的主机发送多个 ICMP 回送请求报文</p>
<ol>
<li>如果没有响应则无法建立连接</li>
<li>如果有响应就可以根据目的主机返回的回送报文的时间和成功响应的次数估算出数据包<strong>往返时间及丢包率</strong></li>
</ol>
<h2 id="http11-和-http10-的区别有哪些">HTTP1.1 和 HTTP1.0 的区别有哪些？</h2>
<img src="/Users/qlzhou/Desktop/D.png" alt="D" style="zoom:67%;" />
<ol>
<li>
<p><strong>长链接</strong></p>
<ol>
<li>早期 HTTP1.0 的每一次请求都伴随着一次三次握手的过程，并且是<strong>串行的请求</strong>，增加了不必要的性能开销</li>
<li>HTTP1.1 <strong>新增了长链接</strong>的通讯方式，减少了性能损耗</li>
</ol>
</li>
<li>
<p><strong>管道</strong></p>
<ol>
<li>HTTP1.0 只有串行发送，没有管道</li>
<li>HTTP1.1 增加了<strong>管道</strong>的概念，使得在同一个 TCP 链接当中可以同时发出多个请求</li>
</ol>
</li>
<li>
<p><strong>断点续传</strong></p>
<ol>
<li>HTTP1.0 <strong>不支持断点续传</strong></li>
<li>HTTP1.1 新增了 <strong>range</strong> 字段，用来指定数据字节位置，开启了断点续传的时代</li>
</ol>
</li>
<li>
<p><strong>Host头处理</strong></p>
<ol>
<li>HTTP1.0 任务主机只有一个节点，所以并<strong>没有传 HOST</strong></li>
<li>HTTP1.1 时代，虚拟机技术越来越发达，一台机器上也有可能有很多节点，故<strong>增加了 HOST 信息</strong></li>
</ol>
</li>
<li>
<p><strong>缓存处理</strong></p>
<ol>
<li>在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准</li>
<li>HTTP1.1则<strong>引入了更多的缓存控制策略</strong>例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>
</ol>
</li>
<li>
<p><strong>错误状态响应码</strong></p>
<ol>
<li>在HTTP1.1中<strong>新增了24个错误状态响应码</strong>，如410（Gone）表示服务器上的某个资源被永久性的删除等。</li>
</ol>
</li>
</ol>
<h2 id="https-和-http-的区别是什么">HTTPS 和 HTTP 的区别是什么？</h2>
<img src="/Users/qlzhou/Desktop/E.png" alt="E" style="zoom:67%;" />
<ol>
<li>
<p><strong>SSL安全协议</strong></p>
<p>HTTP 是超⽂本传输协议，信息是<strong>明⽂传输</strong>，存在安全⻛险的问题。</p>
<p>HTTPS 则解决 HTTP 不安全的缺陷，在TCP 和 HTTP ⽹络层之间加⼊了 SSL/TLS 安全协议，使得报⽂能够<strong>加密传输</strong>。</p>
</li>
<li>
<p><strong>建立连接</strong></p>
<p>HTTP 连接建⽴相对简单， TCP <strong>三次握⼿</strong>之后便可进⾏ HTTP 的报⽂传输。</p>
<p>HTTPS 在 TCP <strong>三次握⼿</strong>之后，还需进⾏ <strong>SSL/TLS</strong> 的<strong>握⼿</strong>过程，才可进⼊加密报⽂传输。</p>
</li>
<li>
<p><strong>端口号</strong></p>
<p>HTTP 的端⼝号是 <strong>80</strong>。</p>
<p>HTTPS 的端⼝号是 <strong>443</strong>。</p>
</li>
<li>
<p><strong>CA证书</strong></p>
<p>*HTTPS 协议需要向 CA（证书权威。机构）申请数字证书**来保证服务器的身份是可信的。</p>
</li>
</ol>
<h2 id="http2-和-http11-的区别是什么">HTTP2 和 HTTP1.1 的区别是什么？</h2>
<img src="/Users/qlzhou/Desktop/G.png" alt="G" style="zoom:67%;" />
<ol>
<li>
<p><strong>头部压缩</strong></p>
<ol>
<li>在 HTTP2 当中，如果你发出了<strong>多个请求</strong>，并且它们的<strong>头部(header)是相同的</strong>，那么 HTTP2 协议会帮你<strong>消除同样的部分</strong>。(其实就是在客户端和服务端维护一张索引表来实现)</li>
</ol>
</li>
<li>
<p><strong>二进制格式</strong></p>
<p>HTTP1.1 采用<strong>明文</strong>的形式</p>
<p>HTTP/2 全⾯采⽤了<strong>⼆进制格式</strong>，头信息和数据体都是⼆进制</p>
</li>
<li>
<p><strong>数据流</strong></p>
<p>HTTP/2 的数据包不是按顺序发送的，同⼀个连接⾥⾯连续的数据包，可能属于不同的回应。(对数据包做了标记，标志其属于哪一个请求，其中规定客户端发出的数据流编号为奇数，服务器发出的数据流编号为偶数。<strong>客户端还可以指定数据流的优先级</strong>，优先级⾼的请求，服务器就先响应该请求)</p>
</li>
<li>
<p><strong>IO多路复用</strong></p>
<p>如:在⼀个连接中，服务器收到了客户端 A 和 B 的两个请求，但是发现在处理 A 的过程中⾮常耗时，索性就先回应 A 已经处理好的部分，再接着回应 B 请求，最后再回应 A 请求剩下的部分。</p>
<p>HTTP/2 可以<strong>在⼀个连接中并发多个请求或回应</strong>。</p>
</li>
<li>
<p><strong>服务器推送</strong></p>
<p>服务器可以主动向客户端发送请求</p>
</li>
</ol>
<h2 id="http2与http1相比改进在哪为什么会更快">HTTP/2与HTTP/1相比，改进在哪？为什么会更快？</h2>
<p>主要的改进包括：</p>
<ol>
<li>多路复用，允许通过单一的HTTP/2连接发起多重的请求-响应消息。而HTTP/1.1协议中，<br>
浏览器客户端在同一时间内，针对同一域名下的请求数量有一定的数量限制。超过限制数目<br>
的请求会被阻塞。(解决办法：CDN使用多个域名)</li>
<li>二进制分帧，HTTP/2会将所有传输的信息分割成更小的消息和帧，并对他们采用二进制<br>
格式的编码，其中HTTP/1.1中的首部信息会被封装到HEADER frame，而body则会封装进<br>
DATA frame。头部进行压缩，使用<a href="https://www.jianshu.com/p/f44b930cfcac">HPACK</a>算法。</li>
</ol>
<h2 id="http3-和-http2-的区别是什么">HTTP3 和 HTTP2 的区别是什么？</h2>
<img src="/Users/qlzhou/Desktop/H.png" alt="H" style="zoom:67%;" />
<ol>
<li>
<p><strong>协议不同</strong></p>
<p>HTTP2 是基于 <strong>TCP</strong> 协议实现的</p>
<p>HTTP3 是基于 <strong>UDP</strong> 协议实现的</p>
</li>
<li>
<p><strong>QUIC</strong></p>
<p>HTTP3 新增了 QUIC 协议**来实现可靠性的传输</p>
</li>
<li>
<p><strong>握手次数</strong></p>
<p>HTTP2 是基于 HTTPS 实现的，建立连接需要先进行 TCP 3次握手，然后再进行 TLS 3次握手，<strong>总共6次握手</strong></p>
<p>HTTP3 只需要 QUIC 的<strong>3次握手</strong></p>
</li>
</ol>
<h2 id="tcp-半连接队列和全连接队列是什么">TCP 半连接队列和全连接队列是什么？</h2>
<img src="/Users/qlzhou/Desktop/AA.png" alt="AA" style="zoom:67%;" />
<p>服务端收到客户端发出的 SYN 请求后，会把这个连接信息存储到<strong>半链接队列(SYN 队列)</strong>。</p>
<p>服务端收到第三次握⼿的 ACK 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到<strong>全连接队列</strong>(accept 队列)，等待进程调⽤ accept 函数时把连接取出来。</p>
<p>这两个队列都是有大小限制的，当超过容量后就会将链接丢弃，或者返回 RST 包。</p>
<h2 id="粘包拆包是怎么发生的怎么解决这个问题">粘包/拆包是怎么发生的？怎么解决这个问题？</h2>
<p>TCP 发送数据时会根据 TCP 缓冲区的实际情况进行包的划分，一个完整的包<strong>可能会被 TCP 拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送</strong>，这就是 TCP 粘包和拆包问题。</p>
<img src="/Users/qlzhou/Desktop/BB.png" alt="BB" style="zoom:67%;" />
<p>发生 TCP <strong>粘包</strong>的<strong>原因</strong>:<br>
1. <strong>发送的数据小于 TCP 缓冲区大小</strong>，TCP将缓冲区中的数据(数据属于多条业务内容)一次发送出去可能就会发生粘包。<br>
2. 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</p>
<p>发生 TCP <strong>拆包</strong>的<strong>原因</strong>:<br>
1. <strong>待发送数据大于最大报文长度</strong>，TCP 在传输前将进行拆包。<br>
2. <strong>发送的数据大于 TCP 发送缓冲区剩余空间大小</strong>，将会发生拆包。</p>
<p><strong>解决方案</strong>:</p>
<figure data-type="image" tabindex="4"><img src="/Users/qlzhou/Desktop/CC.png" alt="CC" loading="lazy"></figure>
<ol>
<li><strong>发送端给每个数据包添加包首部</strong>，首部中包含数据包的长度，这样接收端在接收到数据后，通过该字段就可以知道每个数据包的实际长度了。</li>
<li>发送端将每个数据包<strong>设置固定长度</strong>，这样接收端每次从读取固定长度的数据把每个数据包拆分开。</li>
<li>可以在数据包之间<strong>设置边界</strong>，如添加特殊符号，接收端可以通过这个特殊符号来拆分包。</li>
</ol>
<h2 id="浏览器地址栏输入网站按回车后发生了什么">浏览器地址栏输入网站按回车后发生了什么？</h2>
<img src="/Users/qlzhou/Desktop/DD.png" alt="DD" style="zoom:67%;" />
<ol>
<li><strong>解析网址</strong>,生成 HTTP 请求信息</li>
<li>根据 DNS 服务器<strong>查询真实请求的 IP 地址</strong>，如果本地服务器有缓存则直接返回</li>
<li>得到了 IP 以后，向服务器<strong>发送 TCP 连接</strong>，TCP 连接经过三次握手。</li>
<li>接受 TCP 报文后，对<strong>连接进行处理</strong>，对 HTTP 协议解析</li>
<li>服务器<strong>返回响应</strong></li>
<li><em>浏览器*<em>接受响应，显示页面，渲染页面*</em></em>*</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Golang】堆栈与逃逸分析]]></title>
        <id>https://flyingchase.github.io/post/golang-dui-zhan-yu-tao-yi-fen-xi/</id>
        <link href="https://flyingchase.github.io/post/golang-dui-zhan-yu-tao-yi-fen-xi/">
        </link>
        <updated>2021-10-26T13:37:16.000Z</updated>
        <content type="html"><![CDATA[<p>``# Go 的堆栈与逃逸分析</p>
<h2 id="堆栈">堆栈</h2>
<p>计算机中堆栈的区别</p>
<img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/UvOwW0.png" alt="UvOwW0" style="zoom:34%;" />
<ol>
<li>栈归 OS 分配和创建，堆由程序员使用语言来申请创建与释放</li>
<li>栈存储函数参数、返回值 、局部变量、函数调用时的临时上下文；堆存放全局变量
<ol>
<li>局部、占空间确定的数据放置在<code>Stack</code>上；否则放在<code>堆</code>上（动态内存分配）</li>
</ol>
</li>
<li>栈的访问比堆快</li>
<li>每个<strong>线程</strong>分配一个<strong>栈</strong>，每个<strong>进程</strong>分配一个<strong>堆</strong>；
<ol>
<li>stack 是线程独占的，heap 是线程共用的</li>
</ol>
</li>
<li>栈创建时大小确定，超过数据存储则<code>stack overflow</code>，heap 大小可以动态增加</li>
<li>栈由高地址向低地址增长，堆由低地址向高地址增长</li>
</ol>
<h2 id="go-的堆栈">Go 的堆栈</h2>
<p>变量存储在 heap 还是 stack 由编译器决定</p>
<ul>
<li>无法证明函数返回后变量是否被引用则必须在 heap 上分配，避免指针悬空</li>
<li>局部变量过大也会分配在 heap 上</li>
<li>变量具有地址，作为堆分配的候选，逃逸分析确定其生存周期不会超过函数返回，就被分配在栈上</li>
</ul>
<p><code>go tool compile</code>命令查看汇编判断存储位置</p>
<p>示例：</p>
<pre><code class="language-go">package main
import &quot;fmt&quot;
func main() {
	var a [1]int
	c := a[:]
	fmt.Println(c)
}
</code></pre>
<p><code>go tool compile -m heapAndStackAnalyse.go</code>显示</p>
<pre><code class="language-shell">heapAndStackAnalyse.go:8:13: inlining call to fmt.Println
heapAndStackAnalyse.go:6:6: moved to heap: a
heapAndStackAnalyse.go:8:13: c escapes to heap
heapAndStackAnalyse.go:8:13: []interface {}{...} does not escape
&lt;autogenerated&gt;:1: .this does not escape
</code></pre>
<h3 id="go-逃逸分析">Go 逃逸分析</h3>
<p>Go 中的变量存储分配由编译器决定；生命周期延长则会分配到<code>heap</code>发生逃逸</p>
<p>**定义：**编译器通过分析自动判断变量的生命周期是否被延长，判断过程即为逃逸分析</p>
<p>上述代码<code>fmt.Println(c)</code> 发现调用<code>fmt</code>包的<code>Println</code>函数 ，扩展了生命周期使得 c <code>escape to heap</code></p>
<p>改为 <code>Println(c)</code>则不会发生逃逸</p>
<h2 id="go-的调用栈">Go 的调用栈</h2>
<p>了解 Go 调试时追踪堆栈的跟踪信息和识别传递的参数</p>
<p>示例：</p>
<pre><code class="language-go">package main
import &quot;runtime/debug&quot;

func main() {
	slice := make([]string, 2, 4)
	Example(slice, &quot;hello&quot;, 10)
}
func Example(slice []string, str string, i int) {
	debug.PrintStack()
}
</code></pre>
<p>Go 中程序的启动使用 goroutine 下述第一行表明，goroutineID=1；</p>
<p>后续为不同层次的调用</p>
<ul>
<li>最深层调用最先打印，最后打印最浅调用。</li>
</ul>
<pre><code class="language-shell">goroutine 1 [running]:
runtime/debug.Stack(0xc000046778, 0xc000070f78, 0x1004685)
        /usr/local/Cellar/go/1.16.6/libexec/src/runtime/debug/stack.go:24 +0x9f
runtime/debug.PrintStack()
        /usr/local/Cellar/go/1.16.6/libexec/src/runtime/debug/stack.go:16 +0x25
main.Example(...)
        //...go:11
main.main()
        //....go:7 +0x25
</code></pre>
<h2 id="总结">总结</h2>
<ol>
<li>在方法内把<strong>局部变量指针返回</strong>逃逸
<ul>
<li>局部变量本应该在栈上分配、回收，但是返回时被外部引用则生命周期大于栈</li>
</ul>
</li>
<li><strong>发送指针、带指针值到 channel</strong> 逃逸
<ul>
<li>编译时无法判断 goroutine 会在 channel 接收数据，则声明周期无法断定</li>
</ul>
</li>
<li><strong>切片存储指针/带指针的值</strong> 逃逸
<ul>
<li><code>[]*string</code>导致切片的内容逃逸，可能其背后的数组在栈上分配，但引用的值一定在heap 上</li>
</ul>
</li>
<li><strong>slice 底层的数组被重新分配</strong> 逃逸
<ul>
<li>slice 初始化时候会在栈上被分配，当其扩充时会在 heap 上分配，<code>append</code>时可能超出容量 cap</li>
</ul>
</li>
<li><strong>在 interface{}类型上调用方法</strong> 逃逸
<ul>
<li>interface{}上的方法调用都是动态的，方法的实现只有在运行时知道</li>
</ul>
</li>
</ol>
<p>``</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Golang 详解】slice 切片]]></title>
        <id>https://flyingchase.github.io/post/golang-xiang-jie-slice-qie-pian/</id>
        <link href="https://flyingchase.github.io/post/golang-xiang-jie-slice-qie-pian/">
        </link>
        <updated>2021-10-17T12:19:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="slice">slice</h2>
<p>在切片的 index 位置插入元素</p>
<pre><code class="language-go">copy(res[index+1:],res[index：])	// 将 slice 从 index 位置后移，空出 index 位置
res[index]=value
</code></pre>
<h4 id="底层">底层</h4>
<pre><code class="language-go">type slice struct {
// 指针指向底层的数组
    array unsafe.Pointer
	// 当前切片所使用的长度
    len   int
    // 底层数组的长度
	cap   int
}
</code></pre>
<img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/qv8Q5C.png" alt="qv8Q5C" style="zoom:50%;" />
<p>在复制切片时，底层的数组也被复制，导致在新的复制生成的切片发生扩容前，其内部的 <code>array unsafe.Pointer</code> 与原切片的 array 指针指向的是同一底层数组，此时对newSlice 的修改会影响oldSlice——&gt;发生扩容后则不会</p>
<p><strong>扩容算法：</strong></p>
<ul>
<li>
<p>所需最小 MinCap&gt;2*oldCap newCap=Mincap</p>
</li>
<li>
<p>原 slice 长度 len&lt;1024则两倍扩容</p>
</li>
<li>
<p>原 slice 长度len&gt;1024 则 1.25 倍扩容</p>
</li>
<li>
<p>最后进行内存对齐</p>
</li>
</ul>
<pre><code class="language-go">    // 扩容算法
	newcap := old.cap
	doublecap := newcap + newcap
	if cap &gt; doublecap {
		newcap = cap
	} else {
		if old.len &lt; 1024 {
			newcap = doublecap
		} else {
			// Check 0 &lt; newcap to detect overflow
			// and prevent an infinite loop.
			for 0 &lt; newcap &amp;&amp; newcap &lt; cap {
				newcap += newcap / 4
			}
			// Set newcap to the requested cap when
			// the newcap calculation overflowed.
			if newcap &lt;= 0 {
				newcap = cap
			}
		}
	}
</code></pre>
<p><strong>Tips:</strong></p>
<ul>
<li>打印<code>%p</code>可以输出 slice 指向的底层数组的地址</li>
<li>创建 slice 时候使用<code>mallocgc</code>函数分配内存，如果创建的 size==0则返回固定的 slice 的底层数组地址
<ul>
<li>使用 <code>s:=make([]int,0)</code>和<code>s:=[]int{}</code> 创建则 len==0 默认地址</li>
<li>使用<code>var s []int</code> 则底层数组指针为 nil</li>
</ul>
</li>
</ul>
<h3 id="逆序slice">逆序slice</h3>
<pre><code class="language-go">// 辅助空间
resTrue:=make([] int,len(res))
for index:=range res {
    resTrue[index]=res[len(res) - 1-index]
}

// 原地逆序

for i:=0;i&lt;len(res)&gt;&gt;1; i++{
    res[i],res[len(res) - 1-i]=res[len(res) - 1-i],res[i]
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Golang 数据结构】实现 LRU]]></title>
        <id>https://flyingchase.github.io/post/golang-shu-ju-jie-gou-shi-xian-lru/</id>
        <link href="https://flyingchase.github.io/post/golang-shu-ju-jie-gou-shi-xian-lru/">
        </link>
        <updated>2021-10-08T12:04:23.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-go">package LRU

import &quot;fmt&quot;

// LRU represent Least Recently Used strategy
// means
// cap 固定的双向链表
// 每次插入均在头部,已经存在的元素则更新元素结点并移至头部,不存在则新建结点插入,超容则删掉最后一个结点
// 每次查询则移动待查元素到头部(更新使用频率) 不存在
type Node struct {
	prev, next *Node
	// 代表当前 LRU 的归属
	list *LRU

	key   string
	value interface{}
}
type LRU struct {
	root *Node
	cap  int
	len  int
}

func NewLRU(cap int) *LRU {
	l := &amp;LRU{
		root: &amp;Node{},
		cap:  cap,
	}
	l.root.prev = l.root
	l.root.next = l.root
	l.root.list = l
	return l
}

// Get  获得缓存数据
// 获取到则将该节点移动至链表头部
// 为获取到则 nil
func (l *LRU) Get(key string) interface{} {
	defer l.debug()
	n := l.get(key)
	if n == nil {
		return nil
	}
	return n.value
}

func (l *LRU) get(key string) *Node {
	for n := l.root.next; n != l.root; n = n.next {
		if n.key == key {
			n.prev.next = n.next
			n.next.prev = n.prev

			n.next = l.root.next
			l.root.next.prev = n
			l.root.next = n
			n.prev = l.root
			return n
		}
	}
	return nil
}

// 将 key 构造为结点插入头部,若存在对应的 key 则更新结点值
// 缓存满则删掉最后结点(LRU)最少使用

func (l *LRU) Put(key string, value interface{}) {
	defer l.debug()
	n := l.get(key)
	if n != nil {
		n.value = value
		return
	}
	// 缓存 cap 满
	// delete the last node and l.len--
	if l.len == l.cap {
		last := l.root.prev
		last.prev.next = l.root
		l.root.prev = last.prev
		last.prev = nil
		last.next = nil
		last.list = nil
		l.len--
	}
	// construct newNode to insert the head of the list
	// update the l.len and newNode'list
	node := &amp;Node{
		key:   key,
		value: value,
	}
	head := l.root.next
	head.prev = node
	node.next = head
	node.prev = l.root
	l.root.next = node
	l.len++
	node.list = l
}
func (l *LRU) debug() {
	fmt.Println(&quot;lru len: &quot;, l.len)

	fmt.Println(&quot;lru cap: &quot;, l.cap)
	for n := l.root.next; n != l.root; n = n.next {
		fmt.Printf(&quot;%s:%v -&gt; &quot;, n.key, n.value)
	}
	fmt.Println()
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[gdb 调试 go 程序]]></title>
        <id>https://flyingchase.github.io/post/gdb-diao-shi-go-cheng-xu/</id>
        <link href="https://flyingchase.github.io/post/gdb-diao-shi-go-cheng-xu/">
        </link>
        <updated>2021-10-08T12:03:47.000Z</updated>
        <content type="html"><![CDATA[<p>gdb 调试 go</p>
<h1 id="gdb-调试-go-程序">gdb 调试 go 程序</h1>
<h2 id="准备">准备</h2>
<h3 id="安装-gdb">安装 gdb</h3>
<p><code>brew install gdb</code></p>
<h3 id="自签">自签</h3>
<p>注意证书名称和 codesign 内 gdb 的安装位置</p>
<p><code>codesign -fs gdb /usr/local/bin/gdb</code></p>
<p>📢：reboot</p>
<h2 id="调试流程">调试流程</h2>
<h3 id="编译代码">编译代码</h3>
<pre><code class="language-shell">go build -o bin/03_q1_slice_cap -gcflags=all=&quot;-N -l&quot; -ldflags='-compressdwarf=false' main.go
</code></pre>
<p>最后为代码所在位置</p>
<h4 id="gdb-调试窗口">GDB 调试窗口</h4>
<pre><code class="language-shell">gdb -tui ./bin/*cap*
</code></pre>
<p>./bin 内文件为 main.go 编译生成</p>
<img src="/Users/qlzhou/Library/Application Support/typora-user-images/image-20211008200005280.png" alt="image-20211008200005280" style="zoom:50%;" />
<ul>
<li>
<p><code>b main.go:7</code> 在 main.go 第 7 行打断点</p>
</li>
<li>
<p><code>r</code> 执行到断点处</p>
</li>
<li>
<p><code>n</code> 单步执行（函数调用不进入内部）</p>
</li>
<li>
<p><code>info locals</code> 打印当前堆栈变量</p>
</li>
</ul>
<h2 id="常用调试命令">常用调试命令</h2>
<ul>
<li><code>b 文件名:行数</code> 打断点</li>
<li><code>info b</code> 当前的断点情况</li>
<li><code>r</code> 运行程序知道断点处</li>
<li><code>c</code> 继续执行到下一个断点</li>
<li><code>s</code> 单步执行，如果有调用函数则进入函数，注意和 n 的区别</li>
<li><code>n</code> 单步执行，如果有调用的函数不会进入函数内部</li>
<li><code>until</code> 退出循环</li>
<li><code>until:行号</code> 执行到指定行</li>
<li><code>info locals</code> 当前堆栈的所有变量</li>
<li><code>info args</code> 打印参数</li>
<li><code>info goroutines</code> 查看所有的 goroutine 及其 ID</li>
<li><code>help</code> 帮助</li>
<li><code>q</code> 退出</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Golang 数据结构】实现堆 Heap]]></title>
        <id>https://flyingchase.github.io/post/golang-shu-ju-jie-gou-shi-xian-dui-heap/</id>
        <link href="https://flyingchase.github.io/post/golang-shu-ju-jie-gou-shi-xian-dui-heap/">
        </link>
        <updated>2021-10-03T11:45:21.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-go">
import (
	&quot;errors&quot;
)

/*
实现二叉堆
	- 添加
	- 删除堆顶
	- 获取堆顶
	- 堆化
*/

const DefaultCapacity = 16

type BinaryHeap struct {
	data     []int
	size     int
	capacity int
}

func Default() *BinaryHeap {
	return New(DefaultCapacity)
}

func New(capacity int) *BinaryHeap {
	return &amp;BinaryHeap{
		data:     make([]int, capacity),
		size:     0,
		capacity: capacity,
	}
}

// 添加元素
//  现将元素添加到堆尾 再自下而上不断比较 (index-1)/2比较 移至合适位置
func (h *BinaryHeap) Add(val int) bool {
	if h.size &gt;= h.capacity {
		return false
	}
	// 将 val 加入堆尾 再自下向上调整 不断与 parent=(index-1)/2 比较
	h.data[h.size] = val
	h.size++
	index := h.size - 1
	parent := (index - 1) / 2
	for parent &gt;= 0 &amp;&amp; h.data[index] &lt; h.data[parent] {
		h.data[index], h.data[parent] = h.data[parent], h.data[index]
		index, parent = parent, (index-1)/2
	}
	return true
}

// 删除堆顶元素
func (h *BinaryHeap) Remove() error {
	if h.size &lt;= 0 {
		return errors.New(&quot;heap is null&quot;)
	}
	h.size--
	if h.size &gt; 0 {
		h.data[0] = h.data[h.size-1]
		shiftDown(h, 0, h.size)
	}
	return nil

}

func shiftDown(h *BinaryHeap, index int, size int) {
	left, right := 2*index+1, 2*index+2
	largest := left
	for index &lt; size {
		if right &lt; size &amp;&amp; h.data[right] &lt; h.data[left] {
			largest = right
		}
		if h.data[index] &gt; h.data[largest] {
			largest = index
			break
		}
		h.data[index],h.data[largest]=h.data[largest],h.data[index]
		index=largest
		left=2*index+1
		right=2*index+2
	}
}

// 获取堆顶元素

func (h BinaryHeap)GetTop()int  {
	if h.size&lt;=0 {
		panic(&quot;heap is null&quot;)
	}
	return h.data[0]
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Golang 数据结构】实现单链表]]></title>
        <id>https://flyingchase.github.io/post/golang-shu-ju-jie-gou-shi-xian-dan-lian-biao/</id>
        <link href="https://flyingchase.github.io/post/golang-shu-ju-jie-gou-shi-xian-dan-lian-biao/">
        </link>
        <updated>2021-10-03T11:44:01.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-go">
import &quot;fmt&quot;

/*
实现单链表
	- append
	- 结点前后插入
	- 依值查找
	- 删除结点
	- 打印链表值
*/

type ListNode struct {
	Val  interface{}
	Next *ListNode
}
type LinkedList struct {
	head *ListNode
	size int
}

// 创建结点
func newNode(val interface{}) *ListNode {
	return &amp;ListNode{

		Val:  val,
		Next: nil,
	}
}
func New() *LinkedList {
	return &amp;LinkedList{
		head: nil,
		size: 0,
	}
}

//添加至链尾 并返回生成的结点
func (lists *LinkedList) PushBack(val interface{}) *ListNode {
	head := lists.head
	// 将待插入值转化为 node
	node := newNode(val)
	if head == nil {
		lists.head = node
	} else {
		for head.Next != nil {
			head = head.Next
		}
		head.Next = node
	}
	lists.size++
	return node
}

//结点前插入
func (lists *LinkedList) PushBefore(p *ListNode, val interface{}) *ListNode {
	if p == nil || lists.head == nil {
		return nil
	}
	node := newNode(val)
	// 在头结点之前插入情况
	if p == lists.head {
		node.Next = lists.head
		lists.head = node
	} else {
		prev := lists.head
		// 找到待插入节点的前一个节点
		for ; prev.Next != p; prev = prev.Next {
		}
		node.Next = p
		prev.Next = node
	}
	lists.size++
	return node
}

//结点后插入
func (lists *LinkedList) PushAfter(p *ListNode, val interface{}) *ListNode {

	if p == nil {
		return nil
	}
	node := newNode(val)
	node.Next = p.Next
	p.Next = node
	lists.size++
	return node
}

//查找结点
func (lists *LinkedList) Find(val interface{}) *ListNode {
	cur := lists.head
	for cur != nil &amp;&amp; cur.Val != val {
		cur = cur.Next
	}
	return cur
}

//删除指定结点
func (lists *LinkedList) Delete(p *ListNode) {
	if p == nil {
		return
	}
	if p == lists.head {
		// 待删结点为头结点
		lists.head = lists.head.Next
		lists.size--
	} else {
		// 非删除头结点时 找到待删结点的 prev 结点
		prev := lists.head
		for prev != nil &amp;&amp; prev.Next != p {
			prev = prev.Next
		}
		// 保证找到 而非 prev 走到链尾
		if prev != nil {
			prev.Next = p.Next
			lists.size--
		}
	}
}

//删除指定值结点 调用 find 找到指定值的结点再删除结点即可
func (lists *LinkedList)DeleteVal(val interface{})  {
	lists.Delete(lists.Find(val))
}
//打印链表值
func (lists *LinkedList)PrintDara()  {
	if lists.size==0 {
		return
	}
	for node:=lists.head;node!=nil;node = node.Next {
		fmt.Print(node.Val,&quot; &quot;)
	}
	fmt.Println()
}

</code></pre>
<pre><code class="language-go">package doublyLinkedlist

import &quot;fmt&quot;

/*
实现双向链表
	- CRUD
	- 表头和表尾的追加
*/
type ListNode struct {
    Val interface{}
    prev,next *ListNode
}
type LinkedList struct {
    head *ListNode
    size int
}

func New()*LinkedList  {
   return &amp; LinkedList {
       head: nil,
       size: 0,
   }
}
// 插入到表头 区分表头是否空
func (lists * LinkedList)PushFront(val interface{}) *ListNode  {
   node:=newNode(val)
	if lists.head!=nil {
		lists.head.prev=node
		node.next=lists.head
	}
	lists.head=node
	lists.size++
	return node
}

func newNode(val interface{}) *ListNode{
	return &amp; ListNode {
	    Val: val,
	    prev: nil,
	    next: nil,
	}
}

// 插入数据到链尾
func (lists * LinkedList) PushBack(val interface{}) *ListNode{
	//  空表则调用链首插入
	if lists.head==nil {
		lists.PushFront(val)
	}
	node:=newNode(val)
	cur:=lists.head
	for cur.next != nil {
		cur=cur.next
	}
	cur.next=node
	node.prev=cur
	lists.size++
	return node
}
//节点后插入数据
func (lists * LinkedList) PushAfter(p *ListNode, val interface{})  *ListNode {

	if p==nil {
		return nil
	}
	// 找到要插入位置的前后结点
	next:=p.next
	node:=newNode(val)
	// 插入 注意判断 next 为空时next.prev 不存在 无须链接 新插入的 node 即为最后一个节点
	node.next=next
	p.next=node
	node.prev=p
	if next!=nil {
		next.prev=node
	}
	lists.size++
	return node
}
//结点前插入数据
func (lists * LinkedList)PushBefore(p *ListNode,val interface{}) *ListNode {
	if p==nil {
		return nil
	}
	node:=newNode(val)
	prev:=p.prev
	// 待插入的链表为空则调用链首插入函数
	if prev==nil {
		lists.PushFront(val)
	}else {
		// 在指定结点前插入需找到prevNode
		p.prev=node
		node.next=p
		prev.next=node
		node.prev=prev
		lists.size++
	}

	return node
}
//删除结点
func (lists * LinkedList) Delete(p *ListNode)  {
	if p == nil|| lists.head==nil {
		return
	}
	// 删除结点为头结点则直接跳过即可
	if p==lists.head {
		lists.head=p.next
	}else {
		//  注意待删结点的 nextNode 为链尾空节点时 无须链接 nextNode.prev=prevNode
		prevNode,nextNode:=p.prev,p.next
		prevNode.next=nextNode
		if nextNode!=nil {
			nextNode.prev=prevNode
		}
	}
	lists.size--

}
//依值查找结点
func (lists * LinkedList)Find(val interface{}) *ListNode  {
	if lists.head==nil{
		return nil
	}
	cur:=lists.head
	for cur!=nil&amp;&amp;cur.Val!=val {
		cur=cur.next
	}
	return cur
}
//打印链表数据
func (lists * LinkedList)PrintDara()  {
	for p:=lists.head;p!=nil;p=p.next {
		fmt.Print(p.Val,&quot; &quot;)
	}
	fmt.Println()
}
func (lists * LinkedList)Size() int  {
	return lists.size
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Golang 数据结构】实现动态扩容数组]]></title>
        <id>https://flyingchase.github.io/post/golang-shu-ju-jie-gou-shi-xian-dong-tai-kuo-rong-lian-biao/</id>
        <link href="https://flyingchase.github.io/post/golang-shu-ju-jie-gou-shi-xian-dong-tai-kuo-rong-lian-biao/">
        </link>
        <updated>2021-10-03T11:42:19.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-go">
import (
	&quot;errors&quot;
	&quot;fmt&quot;
)

const DefaultCapacity = 16

// capacity最大值
const CapacityThreshold = 1024

type Array struct {
	data     []interface{}
	capacity int
	size     int
}

func New(capacity int) *Array {
	if capacity == 0 {
		return nil

	}
	return &amp;Array{
		capacity: capacity,
		data:     make([]interface{}, capacity, capacity),
		size:     0,
	}
}
func Default() *Array {
	return New(DefaultCapacity)
}

// insert element 注意扩容
func (arr *Array) Add(index int, val interface{}) error {
	err := arr.checkIndex(index)
	if err != nil {
		return err
	}
	//	扩容j
	if arr.size &gt;= arr.capacity {
		if arr.capacity &gt;= CapacityThreshold {
			// 1.25倍扩容 传入的是容量
			arr.resize(int(float64(arr.capacity) * 1.25))
		} else {
			// 2 倍扩容
			arr.resize(arr.capacity &lt;&lt; 1)
		}
	}
	// 移出待插入的位置
	copy(arr.data[index+1:], arr.data[index:])
	arr.data[index] = val
	arr.size++
	return nil
}

// 追加 append
func (arr *Array) Append(val interface{}) error {
	// 在数组最后位置追加
	return arr.Add(arr.size, val)
}

// 查找
func (arr *Array) Find(index int) (interface{}, error) {
	err := arr.checkIndex(index)
	if err != nil {
		return nil, err
	}
	return arr.data[index], nil
}

func (arr *Array) checkIndex(index int) error {
	if index &lt; 0 || index &gt; arr.capacity {
		return errors.New(&quot;index out of range error&quot;)
	}
	return nil
}
func (arr *Array) resize(newCap int) {
	// 创建新的 data 数组再覆盖即可
	data := make([]interface{}, newCap, newCap)
	copy(data, arr.data)
	arr.data = data
	arr.capacity = newCap
}
// 是否包含特定元素 遍历查找
func (arr *Array)Contains(val interface{}) bool  {
	if arr.Empty()  {
		return false
	}
	for _,v:=range arr.data {
		if v==val {
			return true
		}
	}
	return false

}

func (arr *Array) Empty() bool {
	return arr.size==0
}
// 删除 idnex 的值
func (arr *Array) Delete (index int) error {
	err:=arr.checkIndex(index)
	if err != nil {
		return err
	}
	if arr.data[index]==nil {
		return nil
	}
	// index 下表位置置空并前移数组
	arr.data[index]=nil
	copy(arr.data[index:],arr.data[index+1:])
	// 处理 size 和数组的最后一位
	arr.data[arr.size-1]=nil
	arr.size--
	return nil
}
func (arr *Array)Size() int  {
	return arr.size
}
func (arr *Array)PrintData()  {
	for i:=0;i&lt;arr.capacity;i++ {
		if arr.data[i]!=nil {
			fmt.Print(arr.data[i],&quot; &quot;)
		}
	}
	fmt.Println()
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Neovim 配置]]></title>
        <id>https://flyingchase.github.io/post/neovim-pei-zhi/</id>
        <link href="https://flyingchase.github.io/post/neovim-pei-zhi/">
        </link>
        <updated>2021-10-02T10:08:13.000Z</updated>
        <content type="html"><![CDATA[<p>neovim 配置</p>
<h2 id="前言">前言</h2>
<p>最近纠正完自己的指法后重新捡起了 vim</p>
<p>考虑到自己的需求和刷题的要求，在 idea 和 goland 中均配置了 <code>.ideavimrc</code></p>
<p>选择 neovim 配置 go 的开发环境</p>
<p>个人向配置，因此略过相关依赖的安装教程，大量参考其他配置</p>
<h2 id="安装">安装</h2>
<h3 id="检查">检查</h3>
<p>nvim 中输入<code>:checkhealth</code>检查依赖完成度</p>
<h3 id="插件管理器">插件管理器</h3>
<p><code>vim-plug</code> 注意安装的位置</p>
<pre><code class="language-shell">call plug#begin()

call plug#end()
</code></pre>
<ul>
<li>安装插件：<code>:PlugInstall</code></li>
<li>更新插件：<code>:PlugUpdate</code></li>
<li>删除插件：<code>:PlugClean</code> （首先在 <code>init.vim</code> 中，注释掉该插件，然后打开 Nvim， 使用 <code>:PlugClean</code> 命令清除该插件）</li>
<li>查看插件状态：<code>:PlugStatus</code></li>
<li>升级 vim-plug：<code>:PlugUpgrade</code></li>
</ul>
<h2 id="插件">插件</h2>
<h3 id="vim-airline">vim-airline</h3>
<p>底部状态栏</p>
<p>底部状态栏的主题美化需要配合<code>vim-arilene-themes</code>插件</p>
<p>状态栏主题：<code>let g:airline_theme='themeName'</code></p>
<h3 id="nerdtree">nerdtree</h3>
<p>文件管理器</p>
<pre><code class="language-shell">&quot;==============================================================================
&quot; 项目管理 nerdtree 设置

nnoremap &lt;leader&gt;v :NERDTreeFind&lt;cr&gt;
highlight NERDTreeFile ctermfg=14
nnoremap &lt;leader&gt;g :NERDTreeToggle&lt;cr&gt;
</code></pre>
<p><code>leader+v/g</code> 找到当前文件所在的目录和打开侧边栏目录</p>
<p><code>gi/gs</code> 目录树中以分割视图打开文件</p>
<h3 id="cocnvim">coc.nvim</h3>
<p>代码补全插件</p>
<p>默认路径在<code>~/.config/nvim/coc-settings.json</code> 配置文件添加 golang 相关配置</p>
<pre><code class="language-json">{
    &quot;languageserver&quot;: {
        &quot;golang&quot;: {
            &quot;command&quot;: &quot;gopls&quot;,
            &quot;rootPatterns&quot;: [
                &quot;go.mod&quot;
            ],
            &quot;filetypes&quot;: [
                &quot;go&quot;
            ]
        }
    },
    &quot;suggest.noselect&quot;: false,
    &quot;coc.preferences.diagnostic.displayByAle&quot;: true,
    &quot;suggest.floatEnable&quot;: true
}
</code></pre>
<p>使用<code>ctr+n/p</code>上下移动 回车选择补全代码</p>
<p>在<code>init.vim</code> 可选配置</p>
<pre><code class="language-shell">&quot;==============================================================================
&quot; coc.nvim 配置
&quot; Remap keys for gotos
&quot; nmap &lt;silent&gt; gd &lt;Plug&gt;(coc-definition)
nmap &lt;silent&gt; gy &lt;Plug&gt;(coc-type-definition)
nmap &lt;silent&gt; gm &lt;Plug&gt;(coc-implementation)
nmap &lt;silent&gt; gr &lt;Plug&gt;(coc-references)
inoremap &lt;expr&gt; &lt;cr&gt; pumvisible() ? &quot;\&lt;C-y&gt;&quot; : &quot;\&lt;C-g&gt;u\&lt;CR&gt;&quot;

nnoremap &lt;silent&gt; K :call &lt;SID&gt;show_documentation()&lt;CR&gt;
function! s:show_documentation()
  if (index(['vim','help'], &amp;filetype) &gt;= 0)
    execute 'h '.expand('&lt;cword&gt;')
  else
    call CocAction('doHover')
  endif
endfunction
&quot;==============================================================================
</code></pre>
<h3 id="ale-代码错误插件">ale 代码错误插件</h3>
<p>在 <code>coc-settings.json</code>中关闭 coc的错误处理 <code>&quot;coc.preferences.diagnostic.displayByAle&quot;: true</code></p>
<p>在<code>init.vim</code>配置</p>
<pre><code class="language-shell">&quot;==============================================================================
&quot; ale 错误处理配置
let g:ale_set_highlights = 1
let g:ale_set_quickfix = 1
&quot;自定义error和warning图标
let g:ale_sign_error = '✗'
let g:ale_sign_warning = '⚡'
&quot;在vim自带的状态栏中整合ale
let g:ale_statusline_format = ['✗ %d', '⚡ %d', '✔ OK']
&quot;显示Linter名称,出错或警告等相关信息
let g:ale_echo_msg_error_str = 'E'
let g:ale_echo_msg_warning_str = 'W'
let g:ale_echo_msg_format = '[%linter%] %s [%severity%]'
&quot;打开文件时不进行检查
let g:ale_lint_on_enter = 1

&quot;普通模式下，sp前往上一个错误或警告，sn前往下一个错误或警告
nmap sp &lt;Plug&gt;(ale_previous_wrap)
nmap sn &lt;Plug&gt;(ale_next_wrap)
&quot;&lt;Leader&gt;d查看错误或警告的详细信息
nmap &lt;Leader&gt;d :ALEDetail&lt;CR&gt;
let g:ale_linters = {
    \ 'go': ['golint', 'go vet', 'go fmt'],
    \ }
&quot;==============================================================================
</code></pre>
<p>使用<code>sn/sp</code>在错误之间跳转</p>
<h3 id="查找-fzf">查找 fzf</h3>
<p>与本地内 fzf 联动</p>
<pre><code class="language-shell">Plug '/usr/local/opt/fzf'
Plug 'junegunn/fzf.vim'
</code></pre>
<p>在<code>init.vim</code>配置</p>
<pre><code class="language-shell">map &lt;leader&gt;f :Files&lt;CR&gt;
map &lt;leader&gt;b :Buffers&lt;CR&gt;
let g:fzf_action = { 'ctrl-e': 'edit' }
&quot; 用 leader+ag 搜索当前 cursor 下单词 
nnoremap &lt;silent&gt; &lt;Leader&gt;ag :Ag &lt;C-R&gt;&lt;C-W&gt;&lt;CR&gt;
</code></pre>
<p>直接<code>leader+ag</code> 搜索当前光标下的单词</p>
<p><code>leader+f</code> 搜索项目内文件</p>
<p><code>leader+b</code>搜索 buffer 列表切换 <code>ctrl+n/p</code>选择</p>
<p>全局项目搜索：<code>:Ag</code> 在项目中查找</p>
<h3 id="others">others</h3>
<table>
<thead>
<tr>
<th>插件</th>
<th>作用</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>vim-commentary</code></td>
<td>注释插件</td>
<td><code>gcc/gc</code>注释当前行/所选代码块</td>
</tr>
<tr>
<td><code>vim-easymotion</code></td>
<td>快速移动光标</td>
<td><code>ss</code> nmap 下 ss+目标单词的 2 个字母两次 跳转到显示区域内的首目标单词</td>
</tr>
<tr>
<td><code>vim-surround</code></td>
<td>CRUD{[(“‘</td>
<td><code>di/da/ci/ca/yi/ya+*</code></td>
</tr>
<tr>
<td><code>vim-auto-pairs</code></td>
<td>成对括号</td>
<td></td>
</tr>
<tr>
<td><code>vim-ultisnips+vim-snippets</code></td>
<td>代码块生成</td>
<td><code>forr+tab</code> 即可<code>for range</code></td>
</tr>
<tr>
<td><code>tagbar</code></td>
<td>ctag</td>
<td><code>leader+t</code>显示 tag</td>
</tr>
</tbody>
</table>
<h2 id="总结">总结</h2>
<p>不建议直接 copy 巨佬们的配置</p>
<p>尽量了解每个插件的作用和快捷键，避免插件之间的快捷键冲突，在使用中记忆快捷键。</p>
<p>将 IDE 于<code>vim</code>配合使用，项目开发还是 Goland 香。</p>
<h2 id="reference">Reference</h2>
]]></content>
    </entry>
</feed>