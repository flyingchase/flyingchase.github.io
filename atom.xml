<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://flyingchase.github.io</id>
    <title>flyingchase</title>
    <updated>2021-10-08T12:06:59.240Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://flyingchase.github.io"/>
    <link rel="self" href="https://flyingchase.github.io/atom.xml"/>
    <subtitle>è®°å½•æˆé•¿çš„è„šå°</subtitle>
    <logo>https://flyingchase.github.io/images/avatar.png</logo>
    <icon>https://flyingchase.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, flyingchase</rights>
    <entry>
        <title type="html"><![CDATA[ã€Golang æ•°æ®ç»“æ„ã€‘å®ç° LRU]]></title>
        <id>https://flyingchase.github.io/post/golang-shu-ju-jie-gou-shi-xian-lru/</id>
        <link href="https://flyingchase.github.io/post/golang-shu-ju-jie-gou-shi-xian-lru/">
        </link>
        <updated>2021-10-08T12:04:23.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-go">package LRU

import &quot;fmt&quot;

// LRU represent Least Recently Used strategy
// means
// cap å›ºå®šçš„åŒå‘é“¾è¡¨
// æ¯æ¬¡æ’å…¥å‡åœ¨å¤´éƒ¨,å·²ç»å­˜åœ¨çš„å…ƒç´ åˆ™æ›´æ–°å…ƒç´ ç»“ç‚¹å¹¶ç§»è‡³å¤´éƒ¨,ä¸å­˜åœ¨åˆ™æ–°å»ºç»“ç‚¹æ’å…¥,è¶…å®¹åˆ™åˆ æ‰æœ€åä¸€ä¸ªç»“ç‚¹
// æ¯æ¬¡æŸ¥è¯¢åˆ™ç§»åŠ¨å¾…æŸ¥å…ƒç´ åˆ°å¤´éƒ¨(æ›´æ–°ä½¿ç”¨é¢‘ç‡) ä¸å­˜åœ¨
type Node struct {
	prev, next *Node
	// ä»£è¡¨å½“å‰ LRU çš„å½’å±
	list *LRU

	key   string
	value interface{}
}
type LRU struct {
	root *Node
	cap  int
	len  int
}

func NewLRU(cap int) *LRU {
	l := &amp;LRU{
		root: &amp;Node{},
		cap:  cap,
	}
	l.root.prev = l.root
	l.root.next = l.root
	l.root.list = l
	return l
}

// Get  è·å¾—ç¼“å­˜æ•°æ®
// è·å–åˆ°åˆ™å°†è¯¥èŠ‚ç‚¹ç§»åŠ¨è‡³é“¾è¡¨å¤´éƒ¨
// ä¸ºè·å–åˆ°åˆ™ nil
func (l *LRU) Get(key string) interface{} {
	defer l.debug()
	n := l.get(key)
	if n == nil {
		return nil
	}
	return n.value
}

func (l *LRU) get(key string) *Node {
	for n := l.root.next; n != l.root; n = n.next {
		if n.key == key {
			n.prev.next = n.next
			n.next.prev = n.prev

			n.next = l.root.next
			l.root.next.prev = n
			l.root.next = n
			n.prev = l.root
			return n
		}
	}
	return nil
}

// å°† key æ„é€ ä¸ºç»“ç‚¹æ’å…¥å¤´éƒ¨,è‹¥å­˜åœ¨å¯¹åº”çš„ key åˆ™æ›´æ–°ç»“ç‚¹å€¼
// ç¼“å­˜æ»¡åˆ™åˆ æ‰æœ€åç»“ç‚¹(LRU)æœ€å°‘ä½¿ç”¨

func (l *LRU) Put(key string, value interface{}) {
	defer l.debug()
	n := l.get(key)
	if n != nil {
		n.value = value
		return
	}
	// ç¼“å­˜ cap æ»¡
	// delete the last node and l.len--
	if l.len == l.cap {
		last := l.root.prev
		last.prev.next = l.root
		l.root.prev = last.prev
		last.prev = nil
		last.next = nil
		last.list = nil
		l.len--
	}
	// construct newNode to insert the head of the list
	// update the l.len and newNode'list
	node := &amp;Node{
		key:   key,
		value: value,
	}
	head := l.root.next
	head.prev = node
	node.next = head
	node.prev = l.root
	l.root.next = node
	l.len++
	node.list = l
}
func (l *LRU) debug() {
	fmt.Println(&quot;lru len: &quot;, l.len)

	fmt.Println(&quot;lru cap: &quot;, l.cap)
	for n := l.root.next; n != l.root; n = n.next {
		fmt.Printf(&quot;%s:%v -&gt; &quot;, n.key, n.value)
	}
	fmt.Println()
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[gdb è°ƒè¯• go ç¨‹åº]]></title>
        <id>https://flyingchase.github.io/post/gdb-diao-shi-go-cheng-xu/</id>
        <link href="https://flyingchase.github.io/post/gdb-diao-shi-go-cheng-xu/">
        </link>
        <updated>2021-10-08T12:03:47.000Z</updated>
        <content type="html"><![CDATA[<p>gdb è°ƒè¯• go</p>
<h1 id="gdb-è°ƒè¯•-go-ç¨‹åº">gdb è°ƒè¯• go ç¨‹åº</h1>
<h2 id="å‡†å¤‡">å‡†å¤‡</h2>
<h3 id="å®‰è£…-gdb">å®‰è£… gdb</h3>
<p><code>brew install gdb</code></p>
<h3 id="è‡ªç­¾">è‡ªç­¾</h3>
<p>æ³¨æ„è¯ä¹¦åç§°å’Œ codesign å†… gdb çš„å®‰è£…ä½ç½®</p>
<p><code>codesign -fs gdb /usr/local/bin/gdb</code></p>
<p>ğŸ“¢ï¼šreboot</p>
<h2 id="è°ƒè¯•æµç¨‹">è°ƒè¯•æµç¨‹</h2>
<h3 id="ç¼–è¯‘ä»£ç ">ç¼–è¯‘ä»£ç </h3>
<pre><code class="language-shell">go build -o bin/03_q1_slice_cap -gcflags=all=&quot;-N -l&quot; -ldflags='-compressdwarf=false' main.go
</code></pre>
<p>æœ€åä¸ºä»£ç æ‰€åœ¨ä½ç½®</p>
<h4 id="gdb-è°ƒè¯•çª—å£">GDB è°ƒè¯•çª—å£</h4>
<pre><code class="language-shell">gdb -tui ./bin/*cap*
</code></pre>
<p>./bin å†…æ–‡ä»¶ä¸º main.go ç¼–è¯‘ç”Ÿæˆ</p>
<img src="/Users/qlzhou/Library/Application Support/typora-user-images/image-20211008200005280.png" alt="image-20211008200005280" style="zoom:50%;" />
<ul>
<li>
<p><code>b main.go:7</code> åœ¨ main.go ç¬¬ 7 è¡Œæ‰“æ–­ç‚¹</p>
</li>
<li>
<p><code>r</code> æ‰§è¡Œåˆ°æ–­ç‚¹å¤„</p>
</li>
<li>
<p><code>n</code> å•æ­¥æ‰§è¡Œï¼ˆå‡½æ•°è°ƒç”¨ä¸è¿›å…¥å†…éƒ¨ï¼‰</p>
</li>
<li>
<p><code>info locals</code> æ‰“å°å½“å‰å †æ ˆå˜é‡</p>
</li>
</ul>
<h2 id="å¸¸ç”¨è°ƒè¯•å‘½ä»¤">å¸¸ç”¨è°ƒè¯•å‘½ä»¤</h2>
<ul>
<li><code>b æ–‡ä»¶å:è¡Œæ•°</code> æ‰“æ–­ç‚¹</li>
<li><code>info b</code> å½“å‰çš„æ–­ç‚¹æƒ…å†µ</li>
<li><code>r</code> è¿è¡Œç¨‹åºçŸ¥é“æ–­ç‚¹å¤„</li>
<li><code>c</code> ç»§ç»­æ‰§è¡Œåˆ°ä¸‹ä¸€ä¸ªæ–­ç‚¹</li>
<li><code>s</code> å•æ­¥æ‰§è¡Œï¼Œå¦‚æœæœ‰è°ƒç”¨å‡½æ•°åˆ™è¿›å…¥å‡½æ•°ï¼Œæ³¨æ„å’Œ n çš„åŒºåˆ«</li>
<li><code>n</code> å•æ­¥æ‰§è¡Œï¼Œå¦‚æœæœ‰è°ƒç”¨çš„å‡½æ•°ä¸ä¼šè¿›å…¥å‡½æ•°å†…éƒ¨</li>
<li><code>until</code> é€€å‡ºå¾ªç¯</li>
<li><code>until:è¡Œå·</code> æ‰§è¡Œåˆ°æŒ‡å®šè¡Œ</li>
<li><code>info locals</code> å½“å‰å †æ ˆçš„æ‰€æœ‰å˜é‡</li>
<li><code>info args</code> æ‰“å°å‚æ•°</li>
<li><code>info goroutines</code> æŸ¥çœ‹æ‰€æœ‰çš„ goroutine åŠå…¶ ID</li>
<li><code>help</code> å¸®åŠ©</li>
<li><code>q</code> é€€å‡º</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ã€Golang æ•°æ®ç»“æ„ã€‘å®ç°å † Heap]]></title>
        <id>https://flyingchase.github.io/post/golang-shu-ju-jie-gou-shi-xian-dui-heap/</id>
        <link href="https://flyingchase.github.io/post/golang-shu-ju-jie-gou-shi-xian-dui-heap/">
        </link>
        <updated>2021-10-03T11:45:21.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-go">
import (
	&quot;errors&quot;
)

/*
å®ç°äºŒå‰å †
	- æ·»åŠ 
	- åˆ é™¤å †é¡¶
	- è·å–å †é¡¶
	- å †åŒ–
*/

const DefaultCapacity = 16

type BinaryHeap struct {
	data     []int
	size     int
	capacity int
}

func Default() *BinaryHeap {
	return New(DefaultCapacity)
}

func New(capacity int) *BinaryHeap {
	return &amp;BinaryHeap{
		data:     make([]int, capacity),
		size:     0,
		capacity: capacity,
	}
}

// æ·»åŠ å…ƒç´ 
//  ç°å°†å…ƒç´ æ·»åŠ åˆ°å †å°¾ å†è‡ªä¸‹è€Œä¸Šä¸æ–­æ¯”è¾ƒ (index-1)/2æ¯”è¾ƒ ç§»è‡³åˆé€‚ä½ç½®
func (h *BinaryHeap) Add(val int) bool {
	if h.size &gt;= h.capacity {
		return false
	}
	// å°† val åŠ å…¥å †å°¾ å†è‡ªä¸‹å‘ä¸Šè°ƒæ•´ ä¸æ–­ä¸ parent=(index-1)/2 æ¯”è¾ƒ
	h.data[h.size] = val
	h.size++
	index := h.size - 1
	parent := (index - 1) / 2
	for parent &gt;= 0 &amp;&amp; h.data[index] &lt; h.data[parent] {
		h.data[index], h.data[parent] = h.data[parent], h.data[index]
		index, parent = parent, (index-1)/2
	}
	return true
}

// åˆ é™¤å †é¡¶å…ƒç´ 
func (h *BinaryHeap) Remove() error {
	if h.size &lt;= 0 {
		return errors.New(&quot;heap is null&quot;)
	}
	h.size--
	if h.size &gt; 0 {
		h.data[0] = h.data[h.size-1]
		shiftDown(h, 0, h.size)
	}
	return nil

}

func shiftDown(h *BinaryHeap, index int, size int) {
	left, right := 2*index+1, 2*index+2
	largest := left
	for index &lt; size {
		if right &lt; size &amp;&amp; h.data[right] &lt; h.data[left] {
			largest = right
		}
		if h.data[index] &gt; h.data[largest] {
			largest = index
			break
		}
		h.data[index],h.data[largest]=h.data[largest],h.data[index]
		index=largest
		left=2*index+1
		right=2*index+2
	}
}

// è·å–å †é¡¶å…ƒç´ 

func (h BinaryHeap)GetTop()int  {
	if h.size&lt;=0 {
		panic(&quot;heap is null&quot;)
	}
	return h.data[0]
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ã€Golang æ•°æ®ç»“æ„ã€‘å®ç°å•é“¾è¡¨]]></title>
        <id>https://flyingchase.github.io/post/golang-shu-ju-jie-gou-shi-xian-dan-lian-biao/</id>
        <link href="https://flyingchase.github.io/post/golang-shu-ju-jie-gou-shi-xian-dan-lian-biao/">
        </link>
        <updated>2021-10-03T11:44:01.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-go">
import &quot;fmt&quot;

/*
å®ç°å•é“¾è¡¨
	- append
	- ç»“ç‚¹å‰åæ’å…¥
	- ä¾å€¼æŸ¥æ‰¾
	- åˆ é™¤ç»“ç‚¹
	- æ‰“å°é“¾è¡¨å€¼
*/

type ListNode struct {
	Val  interface{}
	Next *ListNode
}
type LinkedList struct {
	head *ListNode
	size int
}

// åˆ›å»ºç»“ç‚¹
func newNode(val interface{}) *ListNode {
	return &amp;ListNode{

		Val:  val,
		Next: nil,
	}
}
func New() *LinkedList {
	return &amp;LinkedList{
		head: nil,
		size: 0,
	}
}

//æ·»åŠ è‡³é“¾å°¾ å¹¶è¿”å›ç”Ÿæˆçš„ç»“ç‚¹
func (lists *LinkedList) PushBack(val interface{}) *ListNode {
	head := lists.head
	// å°†å¾…æ’å…¥å€¼è½¬åŒ–ä¸º node
	node := newNode(val)
	if head == nil {
		lists.head = node
	} else {
		for head.Next != nil {
			head = head.Next
		}
		head.Next = node
	}
	lists.size++
	return node
}

//ç»“ç‚¹å‰æ’å…¥
func (lists *LinkedList) PushBefore(p *ListNode, val interface{}) *ListNode {
	if p == nil || lists.head == nil {
		return nil
	}
	node := newNode(val)
	// åœ¨å¤´ç»“ç‚¹ä¹‹å‰æ’å…¥æƒ…å†µ
	if p == lists.head {
		node.Next = lists.head
		lists.head = node
	} else {
		prev := lists.head
		// æ‰¾åˆ°å¾…æ’å…¥èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹
		for ; prev.Next != p; prev = prev.Next {
		}
		node.Next = p
		prev.Next = node
	}
	lists.size++
	return node
}

//ç»“ç‚¹åæ’å…¥
func (lists *LinkedList) PushAfter(p *ListNode, val interface{}) *ListNode {

	if p == nil {
		return nil
	}
	node := newNode(val)
	node.Next = p.Next
	p.Next = node
	lists.size++
	return node
}

//æŸ¥æ‰¾ç»“ç‚¹
func (lists *LinkedList) Find(val interface{}) *ListNode {
	cur := lists.head
	for cur != nil &amp;&amp; cur.Val != val {
		cur = cur.Next
	}
	return cur
}

//åˆ é™¤æŒ‡å®šç»“ç‚¹
func (lists *LinkedList) Delete(p *ListNode) {
	if p == nil {
		return
	}
	if p == lists.head {
		// å¾…åˆ ç»“ç‚¹ä¸ºå¤´ç»“ç‚¹
		lists.head = lists.head.Next
		lists.size--
	} else {
		// éåˆ é™¤å¤´ç»“ç‚¹æ—¶ æ‰¾åˆ°å¾…åˆ ç»“ç‚¹çš„ prev ç»“ç‚¹
		prev := lists.head
		for prev != nil &amp;&amp; prev.Next != p {
			prev = prev.Next
		}
		// ä¿è¯æ‰¾åˆ° è€Œé prev èµ°åˆ°é“¾å°¾
		if prev != nil {
			prev.Next = p.Next
			lists.size--
		}
	}
}

//åˆ é™¤æŒ‡å®šå€¼ç»“ç‚¹ è°ƒç”¨ find æ‰¾åˆ°æŒ‡å®šå€¼çš„ç»“ç‚¹å†åˆ é™¤ç»“ç‚¹å³å¯
func (lists *LinkedList)DeleteVal(val interface{})  {
	lists.Delete(lists.Find(val))
}
//æ‰“å°é“¾è¡¨å€¼
func (lists *LinkedList)PrintDara()  {
	if lists.size==0 {
		return
	}
	for node:=lists.head;node!=nil;node = node.Next {
		fmt.Print(node.Val,&quot; &quot;)
	}
	fmt.Println()
}

</code></pre>
<pre><code class="language-go">package doublyLinkedlist

import &quot;fmt&quot;

/*
å®ç°åŒå‘é“¾è¡¨
	- CRUD
	- è¡¨å¤´å’Œè¡¨å°¾çš„è¿½åŠ 
*/
type ListNode struct {
    Val interface{}
    prev,next *ListNode
}
type LinkedList struct {
    head *ListNode
    size int
}

func New()*LinkedList  {
   return &amp; LinkedList {
       head: nil,
       size: 0,
   }
}
// æ’å…¥åˆ°è¡¨å¤´ åŒºåˆ†è¡¨å¤´æ˜¯å¦ç©º
func (lists * LinkedList)PushFront(val interface{}) *ListNode  {
   node:=newNode(val)
	if lists.head!=nil {
		lists.head.prev=node
		node.next=lists.head
	}
	lists.head=node
	lists.size++
	return node
}

func newNode(val interface{}) *ListNode{
	return &amp; ListNode {
	    Val: val,
	    prev: nil,
	    next: nil,
	}
}

// æ’å…¥æ•°æ®åˆ°é“¾å°¾
func (lists * LinkedList) PushBack(val interface{}) *ListNode{
	//  ç©ºè¡¨åˆ™è°ƒç”¨é“¾é¦–æ’å…¥
	if lists.head==nil {
		lists.PushFront(val)
	}
	node:=newNode(val)
	cur:=lists.head
	for cur.next != nil {
		cur=cur.next
	}
	cur.next=node
	node.prev=cur
	lists.size++
	return node
}
//èŠ‚ç‚¹åæ’å…¥æ•°æ®
func (lists * LinkedList) PushAfter(p *ListNode, val interface{})  *ListNode {

	if p==nil {
		return nil
	}
	// æ‰¾åˆ°è¦æ’å…¥ä½ç½®çš„å‰åç»“ç‚¹
	next:=p.next
	node:=newNode(val)
	// æ’å…¥ æ³¨æ„åˆ¤æ–­ next ä¸ºç©ºæ—¶next.prev ä¸å­˜åœ¨ æ— é¡»é“¾æ¥ æ–°æ’å…¥çš„ node å³ä¸ºæœ€åä¸€ä¸ªèŠ‚ç‚¹
	node.next=next
	p.next=node
	node.prev=p
	if next!=nil {
		next.prev=node
	}
	lists.size++
	return node
}
//ç»“ç‚¹å‰æ’å…¥æ•°æ®
func (lists * LinkedList)PushBefore(p *ListNode,val interface{}) *ListNode {
	if p==nil {
		return nil
	}
	node:=newNode(val)
	prev:=p.prev
	// å¾…æ’å…¥çš„é“¾è¡¨ä¸ºç©ºåˆ™è°ƒç”¨é“¾é¦–æ’å…¥å‡½æ•°
	if prev==nil {
		lists.PushFront(val)
	}else {
		// åœ¨æŒ‡å®šç»“ç‚¹å‰æ’å…¥éœ€æ‰¾åˆ°prevNode
		p.prev=node
		node.next=p
		prev.next=node
		node.prev=prev
		lists.size++
	}

	return node
}
//åˆ é™¤ç»“ç‚¹
func (lists * LinkedList) Delete(p *ListNode)  {
	if p == nil|| lists.head==nil {
		return
	}
	// åˆ é™¤ç»“ç‚¹ä¸ºå¤´ç»“ç‚¹åˆ™ç›´æ¥è·³è¿‡å³å¯
	if p==lists.head {
		lists.head=p.next
	}else {
		//  æ³¨æ„å¾…åˆ ç»“ç‚¹çš„ nextNode ä¸ºé“¾å°¾ç©ºèŠ‚ç‚¹æ—¶ æ— é¡»é“¾æ¥ nextNode.prev=prevNode
		prevNode,nextNode:=p.prev,p.next
		prevNode.next=nextNode
		if nextNode!=nil {
			nextNode.prev=prevNode
		}
	}
	lists.size--

}
//ä¾å€¼æŸ¥æ‰¾ç»“ç‚¹
func (lists * LinkedList)Find(val interface{}) *ListNode  {
	if lists.head==nil{
		return nil
	}
	cur:=lists.head
	for cur!=nil&amp;&amp;cur.Val!=val {
		cur=cur.next
	}
	return cur
}
//æ‰“å°é“¾è¡¨æ•°æ®
func (lists * LinkedList)PrintDara()  {
	for p:=lists.head;p!=nil;p=p.next {
		fmt.Print(p.Val,&quot; &quot;)
	}
	fmt.Println()
}
func (lists * LinkedList)Size() int  {
	return lists.size
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ã€Golang æ•°æ®ç»“æ„ã€‘å®ç°åŠ¨æ€æ‰©å®¹é“¾è¡¨]]></title>
        <id>https://flyingchase.github.io/post/golang-shu-ju-jie-gou-shi-xian-dong-tai-kuo-rong-lian-biao/</id>
        <link href="https://flyingchase.github.io/post/golang-shu-ju-jie-gou-shi-xian-dong-tai-kuo-rong-lian-biao/">
        </link>
        <updated>2021-10-03T11:42:19.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-go">
import (
	&quot;errors&quot;
	&quot;fmt&quot;
)

const DefaultCapacity = 16

// capacityæœ€å¤§å€¼
const CapacityThreshold = 1024

type Array struct {
	data     []interface{}
	capacity int
	size     int
}

func New(capacity int) *Array {
	if capacity == 0 {
		return nil

	}
	return &amp;Array{
		capacity: capacity,
		data:     make([]interface{}, capacity, capacity),
		size:     0,
	}
}
func Default() *Array {
	return New(DefaultCapacity)
}

// insert element æ³¨æ„æ‰©å®¹
func (arr *Array) Add(index int, val interface{}) error {
	err := arr.checkIndex(index)
	if err != nil {
		return err
	}
	//	æ‰©å®¹j
	if arr.size &gt;= arr.capacity {
		if arr.capacity &gt;= CapacityThreshold {
			// 1.25å€æ‰©å®¹ ä¼ å…¥çš„æ˜¯å®¹é‡
			arr.resize(int(float64(arr.capacity) * 1.25))
		} else {
			// 2 å€æ‰©å®¹
			arr.resize(arr.capacity &lt;&lt; 1)
		}
	}
	// ç§»å‡ºå¾…æ’å…¥çš„ä½ç½®
	copy(arr.data[index+1:], arr.data[index:])
	arr.data[index] = val
	arr.size++
	return nil
}

// è¿½åŠ  append
func (arr *Array) Append(val interface{}) error {
	// åœ¨æ•°ç»„æœ€åä½ç½®è¿½åŠ 
	return arr.Add(arr.size, val)
}

// æŸ¥æ‰¾
func (arr *Array) Find(index int) (interface{}, error) {
	err := arr.checkIndex(index)
	if err != nil {
		return nil, err
	}
	return arr.data[index], nil
}

func (arr *Array) checkIndex(index int) error {
	if index &lt; 0 || index &gt; arr.capacity {
		return errors.New(&quot;index out of range error&quot;)
	}
	return nil
}
func (arr *Array) resize(newCap int) {
	// åˆ›å»ºæ–°çš„ data æ•°ç»„å†è¦†ç›–å³å¯
	data := make([]interface{}, newCap, newCap)
	copy(data, arr.data)
	arr.data = data
	arr.capacity = newCap
}
// æ˜¯å¦åŒ…å«ç‰¹å®šå…ƒç´  éå†æŸ¥æ‰¾
func (arr *Array)Contains(val interface{}) bool  {
	if arr.Empty()  {
		return false
	}
	for _,v:=range arr.data {
		if v==val {
			return true
		}
	}
	return false

}

func (arr *Array) Empty() bool {
	return arr.size==0
}
// åˆ é™¤ idnex çš„å€¼
func (arr *Array) Delete (index int) error {
	err:=arr.checkIndex(index)
	if err != nil {
		return err
	}
	if arr.data[index]==nil {
		return nil
	}
	// index ä¸‹è¡¨ä½ç½®ç½®ç©ºå¹¶å‰ç§»æ•°ç»„
	arr.data[index]=nil
	copy(arr.data[index:],arr.data[index+1:])
	// å¤„ç† size å’Œæ•°ç»„çš„æœ€åä¸€ä½
	arr.data[arr.size-1]=nil
	arr.size--
	return nil
}
func (arr *Array)Size() int  {
	return arr.size
}
func (arr *Array)PrintData()  {
	for i:=0;i&lt;arr.capacity;i++ {
		if arr.data[i]!=nil {
			fmt.Print(arr.data[i],&quot; &quot;)
		}
	}
	fmt.Println()
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Neovim é…ç½®]]></title>
        <id>https://flyingchase.github.io/post/neovim-pei-zhi/</id>
        <link href="https://flyingchase.github.io/post/neovim-pei-zhi/">
        </link>
        <updated>2021-10-02T10:08:13.000Z</updated>
        <content type="html"><![CDATA[<p>neovim é…ç½®</p>
<h2 id="å‰è¨€">å‰è¨€</h2>
<p>æœ€è¿‘çº æ­£å®Œè‡ªå·±çš„æŒ‡æ³•åé‡æ–°æ¡èµ·äº† vim</p>
<p>è€ƒè™‘åˆ°è‡ªå·±çš„éœ€æ±‚å’Œåˆ·é¢˜çš„è¦æ±‚ï¼Œåœ¨ idea å’Œ goland ä¸­å‡é…ç½®äº† <code>.ideavimrc</code></p>
<p>é€‰æ‹© neovim é…ç½® go çš„å¼€å‘ç¯å¢ƒ</p>
<p>ä¸ªäººå‘é…ç½®ï¼Œå› æ­¤ç•¥è¿‡ç›¸å…³ä¾èµ–çš„å®‰è£…æ•™ç¨‹ï¼Œå¤§é‡å‚è€ƒå…¶ä»–é…ç½®</p>
<h2 id="å®‰è£…">å®‰è£…</h2>
<h3 id="æ£€æŸ¥">æ£€æŸ¥</h3>
<p>nvim ä¸­è¾“å…¥<code>:checkhealth</code>æ£€æŸ¥ä¾èµ–å®Œæˆåº¦</p>
<h3 id="æ’ä»¶ç®¡ç†å™¨">æ’ä»¶ç®¡ç†å™¨</h3>
<p><code>vim-plug</code> æ³¨æ„å®‰è£…çš„ä½ç½®</p>
<pre><code class="language-shell">call plug#begin()

call plug#end()
</code></pre>
<ul>
<li>å®‰è£…æ’ä»¶ï¼š<code>:PlugInstall</code></li>
<li>æ›´æ–°æ’ä»¶ï¼š<code>:PlugUpdate</code></li>
<li>åˆ é™¤æ’ä»¶ï¼š<code>:PlugClean</code> ï¼ˆé¦–å…ˆåœ¨ <code>init.vim</code> ä¸­ï¼Œæ³¨é‡Šæ‰è¯¥æ’ä»¶ï¼Œç„¶åæ‰“å¼€ Nvimï¼Œ ä½¿ç”¨ <code>:PlugClean</code> å‘½ä»¤æ¸…é™¤è¯¥æ’ä»¶ï¼‰</li>
<li>æŸ¥çœ‹æ’ä»¶çŠ¶æ€ï¼š<code>:PlugStatus</code></li>
<li>å‡çº§ vim-plugï¼š<code>:PlugUpgrade</code></li>
</ul>
<h2 id="æ’ä»¶">æ’ä»¶</h2>
<h3 id="vim-airline">vim-airline</h3>
<p>åº•éƒ¨çŠ¶æ€æ </p>
<p>åº•éƒ¨çŠ¶æ€æ çš„ä¸»é¢˜ç¾åŒ–éœ€è¦é…åˆ<code>vim-arilene-themes</code>æ’ä»¶</p>
<p>çŠ¶æ€æ ä¸»é¢˜ï¼š<code>let g:airline_theme='themeName'</code></p>
<h3 id="nerdtree">nerdtree</h3>
<p>æ–‡ä»¶ç®¡ç†å™¨</p>
<pre><code class="language-shell">&quot;==============================================================================
&quot; é¡¹ç›®ç®¡ç† nerdtree è®¾ç½®

nnoremap &lt;leader&gt;v :NERDTreeFind&lt;cr&gt;
highlight NERDTreeFile ctermfg=14
nnoremap &lt;leader&gt;g :NERDTreeToggle&lt;cr&gt;
</code></pre>
<p><code>leader+v/g</code> æ‰¾åˆ°å½“å‰æ–‡ä»¶æ‰€åœ¨çš„ç›®å½•å’Œæ‰“å¼€ä¾§è¾¹æ ç›®å½•</p>
<p><code>gi/gs</code> ç›®å½•æ ‘ä¸­ä»¥åˆ†å‰²è§†å›¾æ‰“å¼€æ–‡ä»¶</p>
<h3 id="cocnvim">coc.nvim</h3>
<p>ä»£ç è¡¥å…¨æ’ä»¶</p>
<p>é»˜è®¤è·¯å¾„åœ¨<code>~/.config/nvim/coc-settings.json</code> é…ç½®æ–‡ä»¶æ·»åŠ  golang ç›¸å…³é…ç½®</p>
<pre><code class="language-json">{
    &quot;languageserver&quot;: {
        &quot;golang&quot;: {
            &quot;command&quot;: &quot;gopls&quot;,
            &quot;rootPatterns&quot;: [
                &quot;go.mod&quot;
            ],
            &quot;filetypes&quot;: [
                &quot;go&quot;
            ]
        }
    },
    &quot;suggest.noselect&quot;: false,
    &quot;coc.preferences.diagnostic.displayByAle&quot;: true,
    &quot;suggest.floatEnable&quot;: true
}
</code></pre>
<p>ä½¿ç”¨<code>ctr+n/p</code>ä¸Šä¸‹ç§»åŠ¨ å›è½¦é€‰æ‹©è¡¥å…¨ä»£ç </p>
<p>åœ¨<code>init.vim</code> å¯é€‰é…ç½®</p>
<pre><code class="language-shell">&quot;==============================================================================
&quot; coc.nvim é…ç½®
&quot; Remap keys for gotos
&quot; nmap &lt;silent&gt; gd &lt;Plug&gt;(coc-definition)
nmap &lt;silent&gt; gy &lt;Plug&gt;(coc-type-definition)
nmap &lt;silent&gt; gm &lt;Plug&gt;(coc-implementation)
nmap &lt;silent&gt; gr &lt;Plug&gt;(coc-references)
inoremap &lt;expr&gt; &lt;cr&gt; pumvisible() ? &quot;\&lt;C-y&gt;&quot; : &quot;\&lt;C-g&gt;u\&lt;CR&gt;&quot;

nnoremap &lt;silent&gt; K :call &lt;SID&gt;show_documentation()&lt;CR&gt;
function! s:show_documentation()
  if (index(['vim','help'], &amp;filetype) &gt;= 0)
    execute 'h '.expand('&lt;cword&gt;')
  else
    call CocAction('doHover')
  endif
endfunction
&quot;==============================================================================
</code></pre>
<h3 id="ale-ä»£ç é”™è¯¯æ’ä»¶">ale ä»£ç é”™è¯¯æ’ä»¶</h3>
<p>åœ¨ <code>coc-settings.json</code>ä¸­å…³é—­ cocçš„é”™è¯¯å¤„ç† <code>&quot;coc.preferences.diagnostic.displayByAle&quot;: true</code></p>
<p>åœ¨<code>init.vim</code>é…ç½®</p>
<pre><code class="language-shell">&quot;==============================================================================
&quot; ale é”™è¯¯å¤„ç†é…ç½®
let g:ale_set_highlights = 1
let g:ale_set_quickfix = 1
&quot;è‡ªå®šä¹‰errorå’Œwarningå›¾æ ‡
let g:ale_sign_error = 'âœ—'
let g:ale_sign_warning = 'âš¡'
&quot;åœ¨vimè‡ªå¸¦çš„çŠ¶æ€æ ä¸­æ•´åˆale
let g:ale_statusline_format = ['âœ— %d', 'âš¡ %d', 'âœ” OK']
&quot;æ˜¾ç¤ºLinteråç§°,å‡ºé”™æˆ–è­¦å‘Šç­‰ç›¸å…³ä¿¡æ¯
let g:ale_echo_msg_error_str = 'E'
let g:ale_echo_msg_warning_str = 'W'
let g:ale_echo_msg_format = '[%linter%] %s [%severity%]'
&quot;æ‰“å¼€æ–‡ä»¶æ—¶ä¸è¿›è¡Œæ£€æŸ¥
let g:ale_lint_on_enter = 1

&quot;æ™®é€šæ¨¡å¼ä¸‹ï¼Œspå‰å¾€ä¸Šä¸€ä¸ªé”™è¯¯æˆ–è­¦å‘Šï¼Œsnå‰å¾€ä¸‹ä¸€ä¸ªé”™è¯¯æˆ–è­¦å‘Š
nmap sp &lt;Plug&gt;(ale_previous_wrap)
nmap sn &lt;Plug&gt;(ale_next_wrap)
&quot;&lt;Leader&gt;dæŸ¥çœ‹é”™è¯¯æˆ–è­¦å‘Šçš„è¯¦ç»†ä¿¡æ¯
nmap &lt;Leader&gt;d :ALEDetail&lt;CR&gt;
let g:ale_linters = {
    \ 'go': ['golint', 'go vet', 'go fmt'],
    \ }
&quot;==============================================================================
</code></pre>
<p>ä½¿ç”¨<code>sn/sp</code>åœ¨é”™è¯¯ä¹‹é—´è·³è½¬</p>
<h3 id="æŸ¥æ‰¾-fzf">æŸ¥æ‰¾ fzf</h3>
<p>ä¸æœ¬åœ°å†… fzf è”åŠ¨</p>
<pre><code class="language-shell">Plug '/usr/local/opt/fzf'
Plug 'junegunn/fzf.vim'
</code></pre>
<p>åœ¨<code>init.vim</code>é…ç½®</p>
<pre><code class="language-shell">map &lt;leader&gt;f :Files&lt;CR&gt;
map &lt;leader&gt;b :Buffers&lt;CR&gt;
let g:fzf_action = { 'ctrl-e': 'edit' }
&quot; ç”¨ leader+ag æœç´¢å½“å‰ cursor ä¸‹å•è¯ 
nnoremap &lt;silent&gt; &lt;Leader&gt;ag :Ag &lt;C-R&gt;&lt;C-W&gt;&lt;CR&gt;
</code></pre>
<p>ç›´æ¥<code>leader+ag</code> æœç´¢å½“å‰å…‰æ ‡ä¸‹çš„å•è¯</p>
<p><code>leader+f</code> æœç´¢é¡¹ç›®å†…æ–‡ä»¶</p>
<p><code>leader+b</code>æœç´¢ buffer åˆ—è¡¨åˆ‡æ¢ <code>ctrl+n/p</code>é€‰æ‹©</p>
<p>å…¨å±€é¡¹ç›®æœç´¢ï¼š<code>:Ag</code> åœ¨é¡¹ç›®ä¸­æŸ¥æ‰¾</p>
<h3 id="others">others</h3>
<table>
<thead>
<tr>
<th>æ’ä»¶</th>
<th>ä½œç”¨</th>
<th>å¿«æ·é”®</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>vim-commentary</code></td>
<td>æ³¨é‡Šæ’ä»¶</td>
<td><code>gcc/gc</code>æ³¨é‡Šå½“å‰è¡Œ/æ‰€é€‰ä»£ç å—</td>
</tr>
<tr>
<td><code>vim-easymotion</code></td>
<td>å¿«é€Ÿç§»åŠ¨å…‰æ ‡</td>
<td><code>ss</code> nmap ä¸‹ ss+ç›®æ ‡å•è¯çš„ 2 ä¸ªå­—æ¯ä¸¤æ¬¡ è·³è½¬åˆ°æ˜¾ç¤ºåŒºåŸŸå†…çš„é¦–ç›®æ ‡å•è¯</td>
</tr>
<tr>
<td><code>vim-surround</code></td>
<td>CRUD{[(â€œâ€˜</td>
<td><code>di/da/ci/ca/yi/ya+*</code></td>
</tr>
<tr>
<td><code>vim-auto-pairs</code></td>
<td>æˆå¯¹æ‹¬å·</td>
<td></td>
</tr>
<tr>
<td><code>vim-ultisnips+vim-snippets</code></td>
<td>ä»£ç å—ç”Ÿæˆ</td>
<td><code>forr+tab</code> å³å¯<code>for range</code></td>
</tr>
<tr>
<td><code>tagbar</code></td>
<td>ctag</td>
<td><code>leader+t</code>æ˜¾ç¤º tag</td>
</tr>
</tbody>
</table>
<h2 id="æ€»ç»“">æ€»ç»“</h2>
<p>ä¸å»ºè®®ç›´æ¥ copy å·¨ä½¬ä»¬çš„é…ç½®</p>
<p>å°½é‡äº†è§£æ¯ä¸ªæ’ä»¶çš„ä½œç”¨å’Œå¿«æ·é”®ï¼Œé¿å…æ’ä»¶ä¹‹é—´çš„å¿«æ·é”®å†²çªï¼Œåœ¨ä½¿ç”¨ä¸­è®°å¿†å¿«æ·é”®ã€‚</p>
<p>å°† IDE äº<code>vim</code>é…åˆä½¿ç”¨ï¼Œé¡¹ç›®å¼€å‘è¿˜æ˜¯ Goland é¦™ã€‚</p>
<h2 id="reference">Reference</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang context åŒ…]]></title>
        <id>https://flyingchase.github.io/post/golang-context-bao/</id>
        <link href="https://flyingchase.github.io/post/golang-context-bao/">
        </link>
        <updated>2021-10-01T03:55:53.000Z</updated>
        <content type="html"><![CDATA[<p>context åŒ…</p>
<h1 id="contextåŒ…">contextåŒ…</h1>
<p>æ§åˆ¶å¹¶å‘çš„æ–¹å¼ï¼š</p>
<p>â€‹	<code>WaitGroup</code> <code>Context</code></p>
<p><strong>waitGroup</strong></p>
<ul>
<li>å¹¶å‘å¯åŠ¨å¤šä¸ªå­åç¨‹ï¼Œç­‰å¾…æ‰€æœ‰çš„ goroutine å®Œæˆä»»åŠ¡ <code>wg.Wait()</code>ç­‰å¾…æ‰€æœ‰çš„å­åç¨‹å®Œæˆåå†æ‰§è¡Œåç»­ä»£ç </li>
<li>æ— æ³•ä¸»åŠ¨é€šçŸ¥å­åç¨‹çš„é€€å‡º</li>
</ul>
<p>ä½¿ç”¨<code>channel</code>å’Œ<code>select</code>é€šçŸ¥ goroutine çš„å¤„ç†</p>
<p>å­åç¨‹ä½¿ç”¨ for å¾ªç¯å®šæ—¶è½®è¯¢ï¼Œ<code>stop</code>ä¿¡é“æœ‰å€¼ï¼ˆå¯è¯»ï¼‰åˆ™é€€å‡º</p>
<pre><code class="language-go">select {
    case &lt;-stop :
    	...
    	return
	default :
    	...
  
}
</code></pre>
<p>èƒŒæ™¯ï¼š</p>
<p>â€‹	ç½‘ç»œè¯·æ±‚Request éœ€è¦å¼€å¯ goroutine éœ€è¦å»è·Ÿè¸ª goroutine çš„æ–¹æ¡ˆ ä»è€Œè¿›è¡Œæ§åˆ¶	å³ goroutine çš„ä¸Šä¸‹æ–‡</p>
<h2 id="context"><strong>Context</strong></h2>
<ul>
<li>é€šçŸ¥å­åç¨‹é€€å‡ºï¼ˆæ­£å¸¸å’Œè¶…æ—¶ï¼‰</li>
<li>ä¼ é€’å¿…è¦å‚æ•°</li>
</ul>
<p><strong>ä½¿ç”¨åŸåˆ™ï¼š</strong></p>
<ul>
<li>ä»¥å‚æ•°å½¢å¼ä¼ é€’ Context ä¸”ä½äºå…¥å£è¯·æ±‚å’Œå‡ºå£è¯·æ±‚é“¾è·¯çš„æ¯ä¸ªå‡½æ•°çš„é¦–ä½</li>
<li>å‡½æ•°æ–¹æ³•ä¼ é€’ Context ä¸å¯ä¼ é€’ nil â€”â€”&gt;tarce è¿½è¸ªæ—¶æ–­æ‰</li>
<li>Context çº¿ç¨‹å®‰å…¨</li>
<li>Context å¯ä¼ é€’ç»™ä»»æ„ä¸ªæ•°çš„ goroutine å­åç¨‹å—æ ¹ context æ§åˆ¶</li>
</ul>
<h3 id="æ§åˆ¶å•åç¨‹">æ§åˆ¶å•åç¨‹</h3>
<p>å°† chan stop è½¬åŒ–ä¸º Context è¿½è¸ª goroutine</p>
<pre><code class="language-go">	// Background è¿”å›ç©ºçš„ Context ä½œä¸ºæ•´ä¸ª context æ ‘çš„æ ¹èŠ‚ç‚¹
// WithCanclel(parent) åˆ›å»ºå¯å–æ¶ˆçš„å­ context ä½œä¸ºå‚æ•°ä¼ é€’ç»™ goroutine è¿›è¡Œè·Ÿè¸ª
	ctx,cancel:=context.WithCancel(context.Background())

	go func(ctx context.Context) {
		for  {
			select {
                // Done()åˆ¤æ–­æ¥æ”¶åˆ°å€¼åˆ™ç»“æŸ
			case &lt;-ctx.Done():
				fmt.Println(&quot;quit &quot;)
				return
			default:
				fmt.Println(&quot;goroutine is under control&quot;)
				time.Sleep(2*time.Second)
			}
		}
	}(ctx)
	time.Sleep(10*time.Second)
	fmt.Println(&quot;it is time to tell ctx stop control&quot;)

	cancel()
	time.Sleep(5*time.Second)
</code></pre>
<ul>
<li><code>context.Backgroud()</code>åˆ›å»ºæ ¹ Context ä½œä¸ºé¡¶å±‚çš„ Context</li>
<li><code>context.WithCancle(parent)</code> åˆ›å»ºå¯å–æ¶ˆçš„å­ Context è¿”å›å‡½æ•° <code>cancel</code></li>
<li>å­åç¨‹ä¸­ä½¿ç”¨<code>select</code>è°ƒç”¨<code>&lt;-ctx.Done()</code> åˆ¤æ–­æ˜¯å¦éœ€è¦é€€å‡º</li>
<li>ä¸»åç¨‹ä½¿ç”¨<code>cancle()</code>å‡½æ•°é€šçŸ¥å­åç¨‹é€€å‡º</li>
</ul>
<h3 id="æ§åˆ¶å¤šåç¨‹">æ§åˆ¶å¤šåç¨‹</h3>
<pre><code class="language-go">ctx,cancle:=context.WithCancel(context.Background())
go reqTask(ctx,&quot;one&quot;)
go reqTask(ctx,&quot;two&quot;)
go reqTask(ctx,&quot;three&quot;)

time.Sleep(3*time.Second)
cancle()
time.Sleep(3*time.Second)

func reqTask(ctx context.Context,name string)  {
	for  {
		select {
		case &lt;-ctx.Done():
			fmt.Println(&quot;stop&quot;,name)
			return
		default:
			fmt.Println(&quot;send request: &quot;,name)
			time.Sleep(time.Second)
		}

	}

</code></pre>
<p><code>cancle()</code>ç»ˆæ­¢æ‰€æœ‰çš„å­åç¨‹</p>
<p><code>context.Context</code>æ˜¯ä¸€ä¸ªæ¥å£</p>
<pre><code class="language-go">type Context interface {
  Deadline() (deadline time.Time, ok bool)
  Done() &lt;-chan struct{}
  Err() error
  Value(key interface{}) interface{}
}
</code></pre>
<p><code>WithCancel()</code>è¿”å›<code>context.Context</code>æ¥å£</p>
<p><code>func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</code></p>
<pre><code class="language-go">// è¿”å›çš„æ˜¯ parentçš„å‰¯æœ¬newCancleCtx
func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {
	if parent == nil {
		panic(&quot;cannot create context from nil parent&quot;)
	}
	c := newCancelCtx(parent)
    // propagateCancel æ˜¯ç»“æŸå­context
	propagateCancel(parent, &amp;c)
	return &amp;c, func() { c.cancel(true, Canceled) }
}
//  *ctx æœ¬èº«æ˜¯ cancleCtx æ•…è€Œæ˜¯åœ°å€ä¼ é€’
type cancelCtx struct {
	Context

	mu       sync.Mutex            // protects following fields
	done     chan struct{}         // created lazily, closed by first cancel call
	children map[canceler]struct{} // set to nil by the first cancel call
	err      error                 // set to non-nil by the first cancel call
}
</code></pre>
<h3 id="contextwithvalue">Context.WithValue</h3>
<p>å¾€å­åç¨‹ä¸­ä¼ é€’å‚æ•°</p>
<p>å…¶ä¸­keyåº”è¯¥è‡ªå®šä¹‰ é¿å…å†…ç½®æ•°æ®ç±»å‹</p>
<p><code>func WithValue(parent Context, key, val interface{}) Context</code></p>
<pre><code class="language-go">	type favKey string
	f := func(ctx context.Context, k favKey) {
		if v := ctx.Value(k); v != nil {
			fmt.Println(&quot;found value &quot;, v)
			return
		}
		fmt.Println(&quot;not found key &quot;, k)
	}

	k := favKey(&quot;language&quot;)
	ctx = context.WithValue(context.Background(), k, &quot;Go&quot;)
	f(ctx, k)
	f(ctx, favKey(&quot;color&quot;))
</code></pre>
<ul>
<li><code>WithValue()</code>åˆ›å»ºåŸºäº<code>ctx</code>çš„å­ context æºå¸¦å€¼ options</li>
<li>å­åç¨‹ä½¿ç”¨<code>ctx.Value(key)</code> è·å–ä¼ é€’çš„å€¼</li>
</ul>
<h3 id="å¸¸ç”¨-api">å¸¸ç”¨ API</h3>
<p><code>WithTimeout()</code>  è®¾ç½®è¶…æ—¶æ—¶é—´ï¼ˆå­åç¨‹æœ€é•¿æ‰§è¡Œæ—¶é—´ï¼‰</p>
<pre><code class="language-go">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)
</code></pre>
<ul>
<li>å¯èƒ½ä½¿å¾—å­åç¨‹åœ¨ cancle()å‡½æ•°ä¹‹å‰ç»“æŸ</li>
<li>å¯ä½¿ç”¨ <code>ctx.Err()</code> è·å–å­åç¨‹é€€å‡ºåŸå› </li>
</ul>
<p><code>WithDeadline</code> è®¾ç½®æ§åˆ¶å­åç¨‹çš„æœ€é•¿æ¨å‡ºæ—¶é—´</p>
<pre><code class="language-go">func WithDeadline(parent Context, d time.Time) (Context, CancelFunc)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang fmtåŒ…]]></title>
        <id>https://flyingchase.github.io/post/golang-fmt-bao/</id>
        <link href="https://flyingchase.github.io/post/golang-fmt-bao/">
        </link>
        <updated>2021-09-27T07:01:25.000Z</updated>
        <content type="html"><![CDATA[<h1 id="fmt-åŒ…">fmt åŒ…</h1>
<h2 id="è¾“å‡º">è¾“å‡º</h2>
<ul>
<li>
<p>Fprint Fprintln Fprintf</p>
<ul>
<li>å°†ç»“æœå†™å…¥åˆ° w ä¸­ è¿”å›å†™å…¥çš„å­—èŠ‚æ•°</li>
<li><code>func Fprint(w io.Writer, a ...interface{})(n int, err error)</code></li>
</ul>
</li>
<li>
<p>Sprint Sprintln Sprintf</p>
<ul>
<li>è½¬æ¢ç»“æœä»¥å­—ç¬¦ä¸²å½¢å¼è¿”å›</li>
<li><code>func Sprintf(format string, a ...interface{}) string</code></li>
</ul>
</li>
<li>
<p>Errorf åŠŸèƒ½ä¸ Sprintf ç›¸åŒ å­—ç¬¦ä¸²è¢«åŒ…è£…ä¸º error ç±»å‹</p>
</li>
</ul>
<h2 id="è¾“å…¥">è¾“å…¥</h2>
<ul>
<li>
<p>Scan Scanf Scanln</p>
<ul>
<li>ä»æ ‡å‡†è¾“å…¥ä¸­è¯»å– EOF æˆ–æ‰€æœ‰ a â€¦interface{}å˜é‡å‡è¢«å¡«å……åœæ­¢è¯»å…¥</li>
<li><code>scan</code>æ¢è¡Œç¬¦<code>\n</code>ä¸ºç©ºç™½å¤„ç†</li>
<li><code>scanln</code> æ¢è¡Œåˆ™åœæ­¢æ‰«æ</li>
<li><code>scanf</code> ä¾æ® formatå­—ç¬¦ä¸² å¯¹æ•°æ®è¿›è¡Œè§£æ <code>%c</code>æ€»æ˜¯åŒ¹é…ä¸‹ä¸€ä¸ªå­—ç¬¦ åŒ…æ‹¬ç©ºç™½</li>
</ul>
</li>
<li>
<p>Fscan Fscanf Fscanln</p>
<ul>
<li>ä»æ–‡ä»¶è¯»å– <code>r io.Reader</code></li>
</ul>
</li>
<li>
<p>Sscan Sscanf Ssanln</p>
<ul>
<li>ä»å­—ç¬¦ä¸²è¯»å– <code>str string</code></li>
</ul>
</li>
</ul>
<pre><code class="language-go">// Scan ä»æ ‡å‡†è¾“å…¥ä¸­è¯»å–æ•°æ®ï¼Œå¹¶å°†æ•°æ®ç”¨ç©ºç™½åˆ†å‰²å¹¶è§£æåå­˜å…¥ a æä¾›
// çš„å˜é‡ä¸­ï¼ˆæ¢è¡Œç¬¦ä¼šè¢«å½“ä½œç©ºç™½å¤„ç†ï¼‰ï¼Œå˜é‡å¿…é¡»ä»¥æŒ‡é’ˆä¼ å…¥ã€‚
// å½“è¯»åˆ° EOF æˆ–æ‰€æœ‰å˜é‡éƒ½å¡«å†™å®Œæ¯•åˆ™åœæ­¢æ‰«æã€‚
// è¿”å›æˆåŠŸè§£æçš„å‚æ•°æ•°é‡ã€‚
func Scan(a ...interface{}) (n int, err error)

// Scanln å’Œ Scan ç±»ä¼¼ï¼Œåªä¸è¿‡é‡åˆ°æ¢è¡Œç¬¦å°±åœæ­¢æ‰«æã€‚
func Scanln(a ...interface{}) (n int, err error)

// Scanf ä»æ ‡å‡†è¾“å…¥ä¸­è¯»å–æ•°æ®ï¼Œå¹¶æ ¹æ®æ ¼å¼å­—ç¬¦ä¸² format å¯¹æ•°æ®è¿›è¡Œè§£æï¼Œ
// å°†è§£æç»“æœå­˜å…¥å‚æ•° a æ‰€æä¾›çš„å˜é‡ä¸­ï¼Œå˜é‡å¿…é¡»ä»¥æŒ‡é’ˆä¼ å…¥ã€‚
// è¾“å…¥ç«¯çš„æ¢è¡Œç¬¦å¿…é¡»å’Œ format ä¸­çš„æ¢è¡Œç¬¦ç›¸å¯¹åº”ï¼ˆå¦‚æœæ ¼å¼å­—ç¬¦ä¸²ä¸­æœ‰æ¢è¡Œ
// ç¬¦ï¼Œåˆ™è¾“å…¥ç«¯å¿…é¡»è¾“å…¥ç›¸åº”çš„æ¢è¡Œç¬¦ï¼‰ã€‚
// å ä½ç¬¦ %c æ€»æ˜¯åŒ¹é…ä¸‹ä¸€ä¸ªå­—ç¬¦ï¼ŒåŒ…æ‹¬ç©ºç™½ï¼Œæ¯”å¦‚ç©ºæ ¼ç¬¦ã€åˆ¶è¡¨ç¬¦ã€æ¢è¡Œç¬¦ã€‚
// è¿”å›æˆåŠŸè§£æçš„å‚æ•°æ•°é‡ã€‚
func Scanf(format string, a ...interface{}) (n int, err error)

// åŠŸèƒ½åŒä¸Šé¢ä¸‰ä¸ªå‡½æ•°ï¼Œåªä¸è¿‡ä» r ä¸­è¯»å–æ•°æ®ã€‚
func Fscan(r io.Reader, a ...interface{}) (n int, err error)
func Fscanln(r io.Reader, a ...interface{}) (n int, err error)
func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)

// åŠŸèƒ½åŒä¸Šé¢ä¸‰ä¸ªå‡½æ•°ï¼Œåªä¸è¿‡ä» str ä¸­è¯»å–æ•°æ®ã€‚
func Sscan(str string, a ...interface{}) (n int, err error)
func Sscanln(str string, a ...interface{}) (n int, err error)
func Sscanf(str string, format string, a ...interface{}) (n int, err error)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang error åŒ…]]></title>
        <id>https://flyingchase.github.io/post/golang-error-bao/</id>
        <link href="https://flyingchase.github.io/post/golang-error-bao/">
        </link>
        <updated>2021-09-27T06:35:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="error-åŒ…">error åŒ…</h1>
<p>Golang ä½¿ç”¨ error ç±»å‹è¿”å›å‡½æ•°æ‰§è¡Œä¸­é‡åˆ°çš„é”™è¯¯</p>
<p><code>nil</code>è¡¨ç¤ºæœªé‡åˆ°é”™è¯¯ï¼Œå¦åˆ™ä¼šè¿”å›å­—ç¬¦ä¸²è¯´æ˜è¿”å›çš„é”™è¯¯ä¿¡æ¯</p>
<ul>
<li>error åªæ˜¯ä¸€ä¸ªæ¥å£ å¯ä»¥ä½¿ç”¨ä»»æ„ç±»å‹å»å®ç°</li>
</ul>
<pre><code class="language-go">type error interface {
    Error() interface
}
</code></pre>
<ul>
<li>
<p>error ä¸ä¸€å®šä»£è¡¨é”™è¯¯</p>
<ul>
<li>io åŒ…å†…çš„ error ç±»å‹ io.EOF ä»£è¡¨æ•°æ®è¯»å–ç»“æŸ</li>
<li>path/filepathåŒ…å†… error ç±»å‹çš„ filepath.SkipDir è¡¨ç¤ºè·³è¿‡å½“å‰ç›®å½•</li>
</ul>
</li>
<li>
<p><code>errors</code>åŒ…å®ç°æœ€ç®€å•çš„ error ç±»å‹ åªåŒ…å«å­—ç¬¦ä¸²</p>
<ul>
<li><code>func New(text string) error</code> New å‡½æ•°ç”Ÿæˆç®€å•çš„ error å¯¹è±¡</li>
</ul>
</li>
<li>
<p>å¯è‡ªå®šä¹‰ error ç±»å‹</p>
<pre><code class="language-go">type myError struct {
    err string
    time time.Time
    count int
}
func (m *myError)Error() string {
    return fmt.Sprintf(&quot;%s %d count, time is %v&quot;, m.err,m.count,m.time)
} 
func newError (s string , i int) {
    return &amp;myError{
        err:s,
        time:time.Now(),
        count:i,
    }
}
</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Joplin ä»‹ç»]]></title>
        <id>https://flyingchase.github.io/post/joplin-jie-shao/</id>
        <link href="https://flyingchase.github.io/post/joplin-jie-shao/">
        </link>
        <updated>2021-09-08T10:27:44.000Z</updated>
        <content type="html"><![CDATA[<h1 id="joplin-ä»‹ç»">Joplin ä»‹ç»</h1>
<h2 id="ç‰¹è‰²">ç‰¹è‰²</h2>
<ul>
<li>
<p>åŒæ­¥æ–¹å¼å¤šç§å¤šæ · å…¨å¹³å°æ”¯æŒ</p>
<ul>
<li>
<img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/image-20210908170712113.png" alt="image-20210908170712113" style="zoom:50%;" />
</li>
</ul>
</li>
<li>
<p>ç½‘é¡µå‰ªè¾‘</p>
</li>
<li>
<p>å¼€æºæ”¯æŒ ç¤¾åŒºå¾ˆå¥½ ä¸æ€•è·‘è·¯ ç¬”è®°åŠ å¯†</p>
</li>
<li>
<p>æ”¯æŒè°ƒç”¨å¤–éƒ¨ mkdownç¼–è¾‘å™¨</p>
</li>
<li>
<p>ç›®å½•æ ‘  tag</p>
</li>
<li>
<p>to-do æ¨¡å¼</p>
</li>
<li>
<p>æ”¯æŒé™„ä»¶æ’å…¥ åœ°ç†ä½ç½®</p>
</li>
<li>
<p>ç¬”è®°å†å²ç‰ˆæœ¬</p>
</li>
</ul>
<h2 id="åŒæ­¥">åŒæ­¥</h2>
<p>é‡‡ç”¨ AWS S3 åŒæ­¥  è…¾è®¯äº‘å’Œé˜¿é‡Œäº‘å¯¹è±¡å­˜å‚¨å‡æ”¯æŒ</p>
<ul>
<li>è…¾è®¯äº‘
<ul>
<li>åŒæ­¥çš„å‚¨å­˜æ¡¶åç§°åŒ…æ‹¬ id  url å½¢å¼ä¸º<code>https://cos.whereisyourbucket.myqclound.com</code></li>
<li>ç§˜é’¥å’Œå¯†ç ä¸ºç§æœ‰ç”¨æˆ·æƒé™çš„ API</li>
</ul>
</li>
</ul>
<h2 id="å®šåˆ¶">å®šåˆ¶</h2>
<ul>
<li>å®ç°[toc]å³ä¾§é¼ æ ‡æ‚¬æµ® <code>cmd</code>å¯ç‚¹å‡»è·³è½¬</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/C5Yjiz.png" alt="C5Yjiz" loading="lazy"></figure>
<p>å‚è€ƒï¼š<a href="https://lightzhan.xyz/index.php/2020/11/22/joplin-toc-customizing/">Joplinå®ç°ç‚«é…·çš„ä¾§è¾¹æ ç›®å½•</a></p>
<ul>
<li>
<p>åˆ©ç”¨ typora çš„ css æ ¼å¼ å¤åˆ¶åˆ°<code>~/.config/joplin-desktop</code> å³å¯åœ¨è®¾ç½®ä¸­åº”ç”¨ï¼ˆæ”¹ä¸ºé»˜è®¤åç§° userstyle.nameï¼‰</p>
</li>
<li>
<p>ä½¿ç”¨ vscode Joplin æ’ä»¶å®ç° vscode æ‰“å¼€ joplin ç¼–è¾‘ mkdown æ–‡ä»¶</p>
</li>
</ul>
]]></content>
    </entry>
</feed>