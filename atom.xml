<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://flyingchase.github.io</id>
    <title>flyingchase</title>
    <updated>2021-10-02T10:08:30.576Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://flyingchase.github.io"/>
    <link rel="self" href="https://flyingchase.github.io/atom.xml"/>
    <subtitle>记录成长的脚印</subtitle>
    <logo>https://flyingchase.github.io/images/avatar.png</logo>
    <icon>https://flyingchase.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, flyingchase</rights>
    <entry>
        <title type="html"><![CDATA[Neovim 配置]]></title>
        <id>https://flyingchase.github.io/post/neovim-pei-zhi/</id>
        <link href="https://flyingchase.github.io/post/neovim-pei-zhi/">
        </link>
        <updated>2021-10-02T10:08:13.000Z</updated>
        <content type="html"><![CDATA[<p>neovim 配置</p>
<h2 id="前言">前言</h2>
<p>最近纠正完自己的指法后重新捡起了 vim</p>
<p>考虑到自己的需求和刷题的要求，在 idea 和 goland 中均配置了 <code>.ideavimrc</code></p>
<p>选择 neovim 配置 go 的开发环境</p>
<p>个人向配置，因此略过相关依赖的安装教程，大量参考其他配置</p>
<h2 id="安装">安装</h2>
<h3 id="检查">检查</h3>
<p>nvim 中输入<code>:checkhealth</code>检查依赖完成度</p>
<h3 id="插件管理器">插件管理器</h3>
<p><code>vim-plug</code> 注意安装的位置</p>
<pre><code class="language-shell">call plug#begin()

call plug#end()
</code></pre>
<ul>
<li>安装插件：<code>:PlugInstall</code></li>
<li>更新插件：<code>:PlugUpdate</code></li>
<li>删除插件：<code>:PlugClean</code> （首先在 <code>init.vim</code> 中，注释掉该插件，然后打开 Nvim， 使用 <code>:PlugClean</code> 命令清除该插件）</li>
<li>查看插件状态：<code>:PlugStatus</code></li>
<li>升级 vim-plug：<code>:PlugUpgrade</code></li>
</ul>
<h2 id="插件">插件</h2>
<h3 id="vim-airline">vim-airline</h3>
<p>底部状态栏</p>
<p>底部状态栏的主题美化需要配合<code>vim-arilene-themes</code>插件</p>
<p>状态栏主题：<code>let g:airline_theme='themeName'</code></p>
<h3 id="nerdtree">nerdtree</h3>
<p>文件管理器</p>
<pre><code class="language-shell">&quot;==============================================================================
&quot; 项目管理 nerdtree 设置

nnoremap &lt;leader&gt;v :NERDTreeFind&lt;cr&gt;
highlight NERDTreeFile ctermfg=14
nnoremap &lt;leader&gt;g :NERDTreeToggle&lt;cr&gt;
</code></pre>
<p><code>leader+v/g</code> 找到当前文件所在的目录和打开侧边栏目录</p>
<p><code>gi/gs</code> 目录树中以分割视图打开文件</p>
<h3 id="cocnvim">coc.nvim</h3>
<p>代码补全插件</p>
<p>默认路径在<code>~/.config/nvim/coc-settings.json</code> 配置文件添加 golang 相关配置</p>
<pre><code class="language-json">{
    &quot;languageserver&quot;: {
        &quot;golang&quot;: {
            &quot;command&quot;: &quot;gopls&quot;,
            &quot;rootPatterns&quot;: [
                &quot;go.mod&quot;
            ],
            &quot;filetypes&quot;: [
                &quot;go&quot;
            ]
        }
    },
    &quot;suggest.noselect&quot;: false,
    &quot;coc.preferences.diagnostic.displayByAle&quot;: true,
    &quot;suggest.floatEnable&quot;: true
}
</code></pre>
<p>使用<code>ctr+n/p</code>上下移动 回车选择补全代码</p>
<p>在<code>init.vim</code> 可选配置</p>
<pre><code class="language-shell">&quot;==============================================================================
&quot; coc.nvim 配置
&quot; Remap keys for gotos
&quot; nmap &lt;silent&gt; gd &lt;Plug&gt;(coc-definition)
nmap &lt;silent&gt; gy &lt;Plug&gt;(coc-type-definition)
nmap &lt;silent&gt; gm &lt;Plug&gt;(coc-implementation)
nmap &lt;silent&gt; gr &lt;Plug&gt;(coc-references)
inoremap &lt;expr&gt; &lt;cr&gt; pumvisible() ? &quot;\&lt;C-y&gt;&quot; : &quot;\&lt;C-g&gt;u\&lt;CR&gt;&quot;

nnoremap &lt;silent&gt; K :call &lt;SID&gt;show_documentation()&lt;CR&gt;
function! s:show_documentation()
  if (index(['vim','help'], &amp;filetype) &gt;= 0)
    execute 'h '.expand('&lt;cword&gt;')
  else
    call CocAction('doHover')
  endif
endfunction
&quot;==============================================================================
</code></pre>
<h3 id="ale-代码错误插件">ale 代码错误插件</h3>
<p>在 <code>coc-settings.json</code>中关闭 coc的错误处理 <code>&quot;coc.preferences.diagnostic.displayByAle&quot;: true</code></p>
<p>在<code>init.vim</code>配置</p>
<pre><code class="language-shell">&quot;==============================================================================
&quot; ale 错误处理配置
let g:ale_set_highlights = 1
let g:ale_set_quickfix = 1
&quot;自定义error和warning图标
let g:ale_sign_error = '✗'
let g:ale_sign_warning = '⚡'
&quot;在vim自带的状态栏中整合ale
let g:ale_statusline_format = ['✗ %d', '⚡ %d', '✔ OK']
&quot;显示Linter名称,出错或警告等相关信息
let g:ale_echo_msg_error_str = 'E'
let g:ale_echo_msg_warning_str = 'W'
let g:ale_echo_msg_format = '[%linter%] %s [%severity%]'
&quot;打开文件时不进行检查
let g:ale_lint_on_enter = 1

&quot;普通模式下，sp前往上一个错误或警告，sn前往下一个错误或警告
nmap sp &lt;Plug&gt;(ale_previous_wrap)
nmap sn &lt;Plug&gt;(ale_next_wrap)
&quot;&lt;Leader&gt;d查看错误或警告的详细信息
nmap &lt;Leader&gt;d :ALEDetail&lt;CR&gt;
let g:ale_linters = {
    \ 'go': ['golint', 'go vet', 'go fmt'],
    \ }
&quot;==============================================================================
</code></pre>
<p>使用<code>sn/sp</code>在错误之间跳转</p>
<h3 id="查找-fzf">查找 fzf</h3>
<p>与本地内 fzf 联动</p>
<pre><code class="language-shell">Plug '/usr/local/opt/fzf'
Plug 'junegunn/fzf.vim'
</code></pre>
<p>在<code>init.vim</code>配置</p>
<pre><code class="language-shell">map &lt;leader&gt;f :Files&lt;CR&gt;
map &lt;leader&gt;b :Buffers&lt;CR&gt;
let g:fzf_action = { 'ctrl-e': 'edit' }
&quot; 用 leader+ag 搜索当前 cursor 下单词 
nnoremap &lt;silent&gt; &lt;Leader&gt;ag :Ag &lt;C-R&gt;&lt;C-W&gt;&lt;CR&gt;
</code></pre>
<p>直接<code>leader+ag</code> 搜索当前光标下的单词</p>
<p><code>leader+f</code> 搜索项目内文件</p>
<p><code>leader+b</code>搜索 buffer 列表切换 <code>ctrl+n/p</code>选择</p>
<p>全局项目搜索：<code>:Ag</code> 在项目中查找</p>
<h3 id="others">others</h3>
<table>
<thead>
<tr>
<th>插件</th>
<th>作用</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>vim-commentary</code></td>
<td>注释插件</td>
<td><code>gcc/gc</code>注释当前行/所选代码块</td>
</tr>
<tr>
<td><code>vim-easymotion</code></td>
<td>快速移动光标</td>
<td><code>ss</code> nmap 下 ss+目标单词的 2 个字母两次 跳转到显示区域内的首目标单词</td>
</tr>
<tr>
<td><code>vim-surround</code></td>
<td>CRUD{[(“‘</td>
<td><code>di/da/ci/ca/yi/ya+*</code></td>
</tr>
<tr>
<td><code>vim-auto-pairs</code></td>
<td>成对括号</td>
<td></td>
</tr>
<tr>
<td><code>vim-ultisnips+vim-snippets</code></td>
<td>代码块生成</td>
<td><code>forr+tab</code> 即可<code>for range</code></td>
</tr>
<tr>
<td><code>tagbar</code></td>
<td>ctag</td>
<td><code>leader+t</code>显示 tag</td>
</tr>
</tbody>
</table>
<h2 id="总结">总结</h2>
<p>不建议直接 copy 巨佬们的配置</p>
<p>尽量了解每个插件的作用和快捷键，避免插件之间的快捷键冲突，在使用中记忆快捷键。</p>
<p>将 IDE 于<code>vim</code>配合使用，项目开发还是 Goland 香。</p>
<h2 id="reference">Reference</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang context 包]]></title>
        <id>https://flyingchase.github.io/post/golang-context-bao/</id>
        <link href="https://flyingchase.github.io/post/golang-context-bao/">
        </link>
        <updated>2021-10-01T03:55:53.000Z</updated>
        <content type="html"><![CDATA[<p>context 包</p>
<h1 id="context包">context包</h1>
<p>控制并发的方式：</p>
<p>​	<code>WaitGroup</code> <code>Context</code></p>
<p><strong>waitGroup</strong></p>
<ul>
<li>并发启动多个子协程，等待所有的 goroutine 完成任务 <code>wg.Wait()</code>等待所有的子协程完成后再执行后续代码</li>
<li>无法主动通知子协程的退出</li>
</ul>
<p>使用<code>channel</code>和<code>select</code>通知 goroutine 的处理</p>
<p>子协程使用 for 循环定时轮询，<code>stop</code>信道有值（可读）则退出</p>
<pre><code class="language-go">select {
    case &lt;-stop :
    	...
    	return
	default :
    	...
  
}
</code></pre>
<p>背景：</p>
<p>​	网络请求Request 需要开启 goroutine 需要去跟踪 goroutine 的方案 从而进行控制	即 goroutine 的上下文</p>
<h2 id="context"><strong>Context</strong></h2>
<ul>
<li>通知子协程退出（正常和超时）</li>
<li>传递必要参数</li>
</ul>
<p><strong>使用原则：</strong></p>
<ul>
<li>以参数形式传递 Context 且位于入口请求和出口请求链路的每个函数的首位</li>
<li>函数方法传递 Context 不可传递 nil ——&gt;tarce 追踪时断掉</li>
<li>Context 线程安全</li>
<li>Context 可传递给任意个数的 goroutine 子协程受根 context 控制</li>
</ul>
<h3 id="控制单协程">控制单协程</h3>
<p>将 chan stop 转化为 Context 追踪 goroutine</p>
<pre><code class="language-go">	// Background 返回空的 Context 作为整个 context 树的根节点
// WithCanclel(parent) 创建可取消的子 context 作为参数传递给 goroutine 进行跟踪
	ctx,cancel:=context.WithCancel(context.Background())

	go func(ctx context.Context) {
		for  {
			select {
                // Done()判断接收到值则结束
			case &lt;-ctx.Done():
				fmt.Println(&quot;quit &quot;)
				return
			default:
				fmt.Println(&quot;goroutine is under control&quot;)
				time.Sleep(2*time.Second)
			}
		}
	}(ctx)
	time.Sleep(10*time.Second)
	fmt.Println(&quot;it is time to tell ctx stop control&quot;)

	cancel()
	time.Sleep(5*time.Second)
</code></pre>
<ul>
<li><code>context.Backgroud()</code>创建根 Context 作为顶层的 Context</li>
<li><code>context.WithCancle(parent)</code> 创建可取消的子 Context 返回函数 <code>cancel</code></li>
<li>子协程中使用<code>select</code>调用<code>&lt;-ctx.Done()</code> 判断是否需要退出</li>
<li>主协程使用<code>cancle()</code>函数通知子协程退出</li>
</ul>
<h3 id="控制多协程">控制多协程</h3>
<pre><code class="language-go">ctx,cancle:=context.WithCancel(context.Background())
go reqTask(ctx,&quot;one&quot;)
go reqTask(ctx,&quot;two&quot;)
go reqTask(ctx,&quot;three&quot;)

time.Sleep(3*time.Second)
cancle()
time.Sleep(3*time.Second)

func reqTask(ctx context.Context,name string)  {
	for  {
		select {
		case &lt;-ctx.Done():
			fmt.Println(&quot;stop&quot;,name)
			return
		default:
			fmt.Println(&quot;send request: &quot;,name)
			time.Sleep(time.Second)
		}

	}

</code></pre>
<p><code>cancle()</code>终止所有的子协程</p>
<p><code>context.Context</code>是一个接口</p>
<pre><code class="language-go">type Context interface {
  Deadline() (deadline time.Time, ok bool)
  Done() &lt;-chan struct{}
  Err() error
  Value(key interface{}) interface{}
}
</code></pre>
<p><code>WithCancel()</code>返回<code>context.Context</code>接口</p>
<p><code>func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</code></p>
<pre><code class="language-go">// 返回的是 parent的副本newCancleCtx
func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {
	if parent == nil {
		panic(&quot;cannot create context from nil parent&quot;)
	}
	c := newCancelCtx(parent)
    // propagateCancel 是结束子context
	propagateCancel(parent, &amp;c)
	return &amp;c, func() { c.cancel(true, Canceled) }
}
//  *ctx 本身是 cancleCtx 故而是地址传递
type cancelCtx struct {
	Context

	mu       sync.Mutex            // protects following fields
	done     chan struct{}         // created lazily, closed by first cancel call
	children map[canceler]struct{} // set to nil by the first cancel call
	err      error                 // set to non-nil by the first cancel call
}
</code></pre>
<h3 id="contextwithvalue">Context.WithValue</h3>
<p>往子协程中传递参数</p>
<p>其中key应该自定义 避免内置数据类型</p>
<p><code>func WithValue(parent Context, key, val interface{}) Context</code></p>
<pre><code class="language-go">	type favKey string
	f := func(ctx context.Context, k favKey) {
		if v := ctx.Value(k); v != nil {
			fmt.Println(&quot;found value &quot;, v)
			return
		}
		fmt.Println(&quot;not found key &quot;, k)
	}

	k := favKey(&quot;language&quot;)
	ctx = context.WithValue(context.Background(), k, &quot;Go&quot;)
	f(ctx, k)
	f(ctx, favKey(&quot;color&quot;))
</code></pre>
<ul>
<li><code>WithValue()</code>创建基于<code>ctx</code>的子 context 携带值 options</li>
<li>子协程使用<code>ctx.Value(key)</code> 获取传递的值</li>
</ul>
<h3 id="常用-api">常用 API</h3>
<p><code>WithTimeout()</code>  设置超时时间（子协程最长执行时间）</p>
<pre><code class="language-go">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)
</code></pre>
<ul>
<li>可能使得子协程在 cancle()函数之前结束</li>
<li>可使用 <code>ctx.Err()</code> 获取子协程退出原因</li>
</ul>
<p><code>WithDeadline</code> 设置控制子协程的最长推出时间</p>
<pre><code class="language-go">func WithDeadline(parent Context, d time.Time) (Context, CancelFunc)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang fmt包]]></title>
        <id>https://flyingchase.github.io/post/golang-fmt-bao/</id>
        <link href="https://flyingchase.github.io/post/golang-fmt-bao/">
        </link>
        <updated>2021-09-27T07:01:25.000Z</updated>
        <content type="html"><![CDATA[<h1 id="fmt-包">fmt 包</h1>
<h2 id="输出">输出</h2>
<ul>
<li>
<p>Fprint Fprintln Fprintf</p>
<ul>
<li>将结果写入到 w 中 返回写入的字节数</li>
<li><code>func Fprint(w io.Writer, a ...interface{})(n int, err error)</code></li>
</ul>
</li>
<li>
<p>Sprint Sprintln Sprintf</p>
<ul>
<li>转换结果以字符串形式返回</li>
<li><code>func Sprintf(format string, a ...interface{}) string</code></li>
</ul>
</li>
<li>
<p>Errorf 功能与 Sprintf 相同 字符串被包装为 error 类型</p>
</li>
</ul>
<h2 id="输入">输入</h2>
<ul>
<li>
<p>Scan Scanf Scanln</p>
<ul>
<li>从标准输入中读取 EOF 或所有 a …interface{}变量均被填充停止读入</li>
<li><code>scan</code>换行符<code>\n</code>为空白处理</li>
<li><code>scanln</code> 换行则停止扫描</li>
<li><code>scanf</code> 依据 format字符串 对数据进行解析 <code>%c</code>总是匹配下一个字符 包括空白</li>
</ul>
</li>
<li>
<p>Fscan Fscanf Fscanln</p>
<ul>
<li>从文件读取 <code>r io.Reader</code></li>
</ul>
</li>
<li>
<p>Sscan Sscanf Ssanln</p>
<ul>
<li>从字符串读取 <code>str string</code></li>
</ul>
</li>
</ul>
<pre><code class="language-go">// Scan 从标准输入中读取数据，并将数据用空白分割并解析后存入 a 提供
// 的变量中（换行符会被当作空白处理），变量必须以指针传入。
// 当读到 EOF 或所有变量都填写完毕则停止扫描。
// 返回成功解析的参数数量。
func Scan(a ...interface{}) (n int, err error)

// Scanln 和 Scan 类似，只不过遇到换行符就停止扫描。
func Scanln(a ...interface{}) (n int, err error)

// Scanf 从标准输入中读取数据，并根据格式字符串 format 对数据进行解析，
// 将解析结果存入参数 a 所提供的变量中，变量必须以指针传入。
// 输入端的换行符必须和 format 中的换行符相对应（如果格式字符串中有换行
// 符，则输入端必须输入相应的换行符）。
// 占位符 %c 总是匹配下一个字符，包括空白，比如空格符、制表符、换行符。
// 返回成功解析的参数数量。
func Scanf(format string, a ...interface{}) (n int, err error)

// 功能同上面三个函数，只不过从 r 中读取数据。
func Fscan(r io.Reader, a ...interface{}) (n int, err error)
func Fscanln(r io.Reader, a ...interface{}) (n int, err error)
func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)

// 功能同上面三个函数，只不过从 str 中读取数据。
func Sscan(str string, a ...interface{}) (n int, err error)
func Sscanln(str string, a ...interface{}) (n int, err error)
func Sscanf(str string, format string, a ...interface{}) (n int, err error)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang error 包]]></title>
        <id>https://flyingchase.github.io/post/golang-error-bao/</id>
        <link href="https://flyingchase.github.io/post/golang-error-bao/">
        </link>
        <updated>2021-09-27T06:35:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="error-包">error 包</h1>
<p>Golang 使用 error 类型返回函数执行中遇到的错误</p>
<p><code>nil</code>表示未遇到错误，否则会返回字符串说明返回的错误信息</p>
<ul>
<li>error 只是一个接口 可以使用任意类型去实现</li>
</ul>
<pre><code class="language-go">type error interface {
    Error() interface
}
</code></pre>
<ul>
<li>
<p>error 不一定代表错误</p>
<ul>
<li>io 包内的 error 类型 io.EOF 代表数据读取结束</li>
<li>path/filepath包内 error 类型的 filepath.SkipDir 表示跳过当前目录</li>
</ul>
</li>
<li>
<p><code>errors</code>包实现最简单的 error 类型 只包含字符串</p>
<ul>
<li><code>func New(text string) error</code> New 函数生成简单的 error 对象</li>
</ul>
</li>
<li>
<p>可自定义 error 类型</p>
<pre><code class="language-go">type myError struct {
    err string
    time time.Time
    count int
}
func (m *myError)Error() string {
    return fmt.Sprintf(&quot;%s %d count, time is %v&quot;, m.err,m.count,m.time)
} 
func newError (s string , i int) {
    return &amp;myError{
        err:s,
        time:time.Now(),
        count:i,
    }
}
</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Joplin 介绍]]></title>
        <id>https://flyingchase.github.io/post/joplin-jie-shao/</id>
        <link href="https://flyingchase.github.io/post/joplin-jie-shao/">
        </link>
        <updated>2021-09-08T10:27:44.000Z</updated>
        <content type="html"><![CDATA[<h1 id="joplin-介绍">Joplin 介绍</h1>
<h2 id="特色">特色</h2>
<ul>
<li>
<p>同步方式多种多样 全平台支持</p>
<ul>
<li>
<img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/image-20210908170712113.png" alt="image-20210908170712113" style="zoom:50%;" />
</li>
</ul>
</li>
<li>
<p>网页剪辑</p>
</li>
<li>
<p>开源支持 社区很好 不怕跑路 笔记加密</p>
</li>
<li>
<p>支持调用外部 mkdown编辑器</p>
</li>
<li>
<p>目录树  tag</p>
</li>
<li>
<p>to-do 模式</p>
</li>
<li>
<p>支持附件插入 地理位置</p>
</li>
<li>
<p>笔记历史版本</p>
</li>
</ul>
<h2 id="同步">同步</h2>
<p>采用 AWS S3 同步  腾讯云和阿里云对象存储均支持</p>
<ul>
<li>腾讯云
<ul>
<li>同步的储存桶名称包括 id  url 形式为<code>https://cos.whereisyourbucket.myqclound.com</code></li>
<li>秘钥和密码为私有用户权限的 API</li>
</ul>
</li>
</ul>
<h2 id="定制">定制</h2>
<ul>
<li>实现[toc]右侧鼠标悬浮 <code>cmd</code>可点击跳转</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/C5Yjiz.png" alt="C5Yjiz" loading="lazy"></figure>
<p>参考：<a href="https://lightzhan.xyz/index.php/2020/11/22/joplin-toc-customizing/">Joplin实现炫酷的侧边栏目录</a></p>
<ul>
<li>
<p>利用 typora 的 css 格式 复制到<code>~/.config/joplin-desktop</code> 即可在设置中应用（改为默认名称 userstyle.name）</p>
</li>
<li>
<p>使用 vscode Joplin 插件实现 vscode 打开 joplin 编辑 mkdown 文件</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go cheatsheet]]></title>
        <id>https://flyingchase.github.io/post/go-cheatsheet/</id>
        <link href="https://flyingchase.github.io/post/go-cheatsheet/">
        </link>
        <updated>2021-09-04T15:03:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="go-cheatsheet">Go cheatsheet</h1>
<h2 id="variables">Variables</h2>
<ul>
<li>短声明不可在函数外部
<ul>
<li>短声明至少一个新变量</li>
</ul>
</li>
<li>常量 const
<ul>
<li>可忽略类型 也可指定类型</li>
</ul>
</li>
</ul>
<p><strong>关键字</strong></p>
<ol>
<li><code>break default func interface select</code></li>
<li><code>case defer go map struct</code></li>
<li><code>chan else goto package switch</code></li>
<li><code>const fallthrough if range type</code></li>
<li><code>continue for import return var</code></li>
</ol>
<h3 id="iota">iota</h3>
<ul>
<li>
<p>枚举使用  为 const 常量赋值</p>
</li>
<li>
<p>按照 const 内的行数从 0 递增  同一行的值相等</p>
</li>
<li>
<p>每次遇见 const 重置为 0</p>
</li>
</ul>
<p>rune 是 unit32 别称</p>
<p>byte 是 unit8 别称</p>
<h3 id="make-new">make new</h3>
<h4 id="make">make</h4>
<ul>
<li>内建 map slices channel 的内存分配</li>
<li>返回有初始值的 T类型 非*T 指针</li>
</ul>
<h4 id="new">new</h4>
<ul>
<li>各种类型的内存分配</li>
<li>返回指针 指向新分配的类型的零值</li>
</ul>
<h2 id="basic-types">Basic types</h2>
<h3 id="strings">Strings</h3>
<pre><code class="language-go">// 不会将换行符\n 转化 直接输出换行
str:=`Multiline
string`
</code></pre>
<ul>
<li>字符串不可变
<ul>
<li>改变需要转化为<code>[]byte</code>类型</li>
<li>+和切片操作可以更改  <code>s=“c”+s[1:]</code></li>
</ul>
</li>
<li>再强转 string(ch)即可</li>
<li>可使用<code>+</code>链接</li>
<li></li>
</ul>
<h3 id="numbers">Numbers</h3>
<pre><code class="language-go">num1:=3
num2:=3.1
num3:=3+4i
num4:=byte('a') // byte 底层为alias unit8 

fmt.Printf(&quot;reflect.TypeOf(num1): %v\n&quot;, reflect.TypeOf(num1))
fmt.Printf(&quot;reflect.TypeOf(num2): %v\n&quot;, reflect.TypeOf(num2))
fmt.Printf(&quot;reflect.TypeOf(num3): %v\n&quot;, reflect.TypeOf(num3))
fmt.Printf(&quot;reflect.TypeOf(num4): %v\n&quot;, reflect.TypeOf(num4))

// reflect.TypeOf(num1): int
// reflect.TypeOf(num2): float64
// reflect.TypeOf(num3): complex128
// reflect.TypeOf(num4): uint8
</code></pre>
<h3 id="array">Array</h3>
<pre><code class="language-go">numbers:=[...]int{1,2,3,4,5} // 忽略数组长度 直接按照后续初始化计长
for _,num:=range numbers{
  println(num)
}
</code></pre>
<h3 id="slices">Slices</h3>
<ul>
<li><code>var slice []byte</code>
<ul>
<li>Slice[ : ：] 第一个默认位置为<code>0</code> 第二个默认位置是 len 第三个位置是容量的最后一个对应数组的下标 则 cap=(最后一位-第一位)
<ul>
<li>前闭后开</li>
</ul>
</li>
</ul>
</li>
<li>类似结构体 内含有 <em>指针（指向 数组中slice 的开始位置）、len（代表 slice长度）、cap（代表 slice 开始位置到对应数组的最后位置长度）</em>
<ul>
<li>append 追加——&gt;指针 会影响slice 指向的数组
<ul>
<li>当 slices(cap-len==0) 时slices 分配新的空间 返回新的数组指针 原数组内容不变</li>
</ul>
</li>
<li>len 长度</li>
<li>cap 容量</li>
<li>copy 复制到目标 dst 返回复制元素个数</li>
</ul>
</li>
</ul>
<h3 id="pointers">Pointers</h3>
<h3 id="map">map</h3>
<ul>
<li>字典无序 长度不固定，是引用类型</li>
<li>len 获取 key 的数量</li>
<li>不存在 k 对应的 v 返回为 bool</li>
<li><em>API</em>
<ul>
<li>delete 删除 delete(map,key)</li>
<li>v</li>
</ul>
</li>
</ul>
<h2 id="flow-control">Flow control</h2>
<ul>
<li>if内声明的变量作用域仅在代码块内</li>
<li>无 while</li>
<li>Switch 中 case 默认带 break 需要 <code>fallthrough</code></li>
</ul>
<h3 id="conditional">Conditional</h3>
<h4 id="siwtch">siwtch</h4>
<ul>
<li>switch中 Expr 与 case 的各个 expr判断必须是同类型的</li>
<li>switch 无表达式则默认为 <code>true</code></li>
<li></li>
</ul>
<h3 id="goto">Goto</h3>
<p>与 <code>Here:</code>标签搭配  必须跳转到当前函数内定义的标签</p>
<ul>
<li>标签名大小写敏感</li>
<li></li>
</ul>
<h2 id="functions">Functions</h2>
<ul>
<li>
<p>函数可作为参数传递</p>
<ul>
<li>成为嵌套函数  在函数中调用其他函数</li>
</ul>
<pre><code class="language-go">package main

import &quot;fmt&quot;
// 首先需要定义函数类型 作为其它函数的传入参数
type testInt func(int) bool
// 按照函数类型来编写函数
func isOdd(integer int) bool {
   if integer%2 == 0 {
      return false
   }
   return true
}
func isEven(integer int) bool {
   if integer%2 != 0 {
      return false
   }
   return true
}
func filter(slice []int, f testInt) []int {
   var res []int
   for _, val := range slice {
      if f(val) {
         res = append(res, val)
      }
   }
   return res
}
func main() {
   slice := []int{1, 2, 3, 4, 5, 6, 7}
   fmt.Println(slice)
   odd := filter(slice, isOdd) // 将函数作为参数传入函数
   fmt.Println(odd)
   even := filter(slice, isEven)
   fmt.Println(even)
}
</code></pre>
<ul>
<li>将函数作为参数传递要求
<ul>
<li>定义函数类型</li>
<li>要作为参数传递的函数类型与定义的函数类型相同</li>
</ul>
</li>
</ul>
<h4 id="variadic-functions-可变参数">Variadic Functions 可变参数</h4>
<ul>
<li>
<pre><code class="language-go">func funcName (nums ...int) {  // 不指定参数个数
    fmpl(nums)
    for _,num:=rang nums{
        sum+=num;
    }
    fmpl(sum)
}
func main() {
    sum(1,2)
    sum(1,2,3)
    nums:=[]int{1,2,3,4}
    sum(nums...)
}
</code></pre>
</li>
</ul>
<h4 id="closures-返回func">Closures 返回func</h4>
<ul>
<li>
<pre><code class="language-go">func intSeq() func() int{    // 函数返回值为函数
   i:=0
   return func() int {
       i++
       return i
   }
}
func main() {
   nextIntL:=intSeq()
   fmt.Println(nextIntL()) // 1
   fmt.Println(nextIntL()) //2
   fmt.Println(nextIntL())//3
   newIntL:=intSeq()
   fmt.Println(newIntL()) //1 
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="recursion">Recursion</h4>
<pre><code class="language-go">func fact (n int) int{
	if n==0 {
		return 1
	}
	return n* fact(n-1)  
}

func main(){
	fmt.Println(fact(7))  

	var fib func(n int) int  // 将函数定义为变量 

	fib=func (n int) int {
		if n&lt;2 {
			return n
		}
		return fib(n-1)+fib(n-2)
	}
	fmt.Println(fib(7))
}
</code></pre>
<h3 id="lambda">Lambda</h3>
<p><code>arg …int</code>表示函数接受不定数量的变参</p>
<p>Func myFunc (arg ..int) int{}</p>
<h3 id="defer">defer</h3>
<ul>
<li>函数执行到最后return 后  defer 逆序执行 最后返回值退出</li>
<li></li>
</ul>
<h2 id="packages">Packages</h2>
<p>两个保留函数 main 和 init</p>
<ul>
<li><code>main 函数</code>只能用于<code>package main</code> <code>init函数</code>可用于各个 package</li>
<li>两者无参数和返回值</li>
</ul>
<h3 id="点操作">点操作</h3>
<p><strong>. “packhageName”：</strong></p>
<ul>
<li>点操作含义是调用该包内函数时 可忽略前缀包名
<ul>
<li><code>fmt.Println()</code>可简写为<code>Println()</code></li>
</ul>
</li>
</ul>
<h3 id="别名操作">别名操作</h3>
<ul>
<li>将包名在本文件内作为自定义名称</li>
<li>防止冲突/易于记忆包名</li>
</ul>
<h3 id="_操作">_操作</h3>
<ul>
<li>导入该包但不直接使用包内函数 调用包内的 <code>init函数</code></li>
</ul>
<h2 id="error-control">Error control</h2>
<p>panic 和 recover 机制</p>
<h2 id="structs">Structs</h2>
<ul>
<li>
<p>匿名字段可包含对应 struct 的所有内容</p>
</li>
<li>
<p>内置类型 Int 等也可以作为匿名字段</p>
</li>
<li>
<p>内外层有重复的字段 优先访问最外层的字段</p>
</li>
</ul>
<h2 id="methods">Methods</h2>
<ul>
<li>
<p>附属在给定的 struct 上 在函数基础上加上 receiver</p>
</li>
<li>
<p>方法可与在任何自定义的类型、内置类型、struct 上</p>
<ul>
<li>type typeName typeLiteral   称 typeName 为自定义类型</li>
<li>struct 是自定义中的一种</li>
</ul>
</li>
<li>
<p>继承</p>
<ul>
<li>匿名字段的 method 可被继承 包含该匿名字段的 struct 可调用期内的 methods</li>
</ul>
</li>
<li>
<p>重写 override</p>
<ul>
<li>外部 struct 可重写内部 struct 的 methods</li>
</ul>
</li>
</ul>
<h2 id="interfaces">Interfaces</h2>
<ul>
<li>
<p>interface 可被任意对象实现</p>
</li>
<li>
<p>一个对象可实现多个 interface</p>
</li>
<li>
<p>任意类型都实现了空 interface</p>
</li>
<li>
<p>是一抽象方法的集合</p>
</li>
</ul>
<h4 id="变量存储类型">变量存储类型</h4>
<ul>
<li>断言<code>Comma-ok</code>
<ul>
<li><code>value,ok:=element(T)</code> ok 是 bool 类型 true 代表是该类型 多在 if-else 使用</li>
<li><code>switch</code> 使用<code>element.(type)</code> 作为判断和 case</li>
</ul>
</li>
</ul>
<pre><code class="language-go">type Element interface {
} // 可作用在任何类型上
type List[] Element // element 为空接口并将其自定义名称为 List[]
type Person struct {
   name string
   age int
}

func (p *Person) String() string {
   return p.name+strconv.Itoa(p.age)

}
func main() {
list:=make(List,3)
list[0] = 1
list[1] = &quot;hello&quot;
list[2]=Person{name : &quot;w&quot;,age :100}
for index,element:=range list {
   if value, ok := element.(int); ok {
      fmt.Println(index, value)
   }else if value, ok := element.(Person); ok {
      fmt.Println(index,value)
   }else if value, ok := element.(string); ok {

      fmt.Println(index,value)
   }else {
      fmt.Println(index)
   }
}
</code></pre>
<p>函数赋值给变量 函数内是空接口</p>
<pre><code class="language-go">whatAmI := func(i interface{}) {  switch t := i.(type) {  case bool:     fmt.Println(&quot;bool&quot;)  case int:     fmt.Println(&quot;int&quot;)  default:     fmt.Println(reflect.TypeOf(t))  }}whatAmI(&quot;1&quot;)whatAmI(true)whatAmI(1)whatAmI(Studnet{})
</code></pre>
<h2 id="concurrency">Concurrency</h2>
<ul>
<li>通过通信来共享而非通过共享来通信</li>
<li>goroutine 运行在相同的地址空间</li>
</ul>
<h4 id="channel">channel</h4>
<ul>
<li>
<p>channel 必须使用 make 创建并定义发送到 channel 的类型</p>
</li>
<li>
<p>cap 可以读取 channel 的缓存容量</p>
<ul>
<li>
<pre><code class="language-go">ch:=make(chan int) // 定义同时规定发送到 chan 的类型v:=1ch&lt;-v 	// 将 v 发送到 chanw:=&lt;-ch	// 从 ch中读取并赋值给 w
</code></pre>
</li>
</ul>
</li>
<li>
<p>默认无缓存chan 接受和发送是阻塞的  除非另外一端准备好</p>
<ul>
<li>
<p><code>value:&lt;-c</code> 读取会被阻塞 直到有数据接受</p>
</li>
<li>
<p><code>ch&lt;-5</code> 发送会被阻塞 直到有被读取</p>
</li>
<li>
<pre><code class="language-go">func sum(a []int, c chan int)  {   total:=0   for _,v:=range a{      total+=v   }   c&lt;-total}func main() {   a:=[...]int {1, 2, 3,4,5,6,7,8,9,0}   c:=make(chan int)   go sum(a[:len(a)/2],c)   go sum(a[len(a)/2:],c)   x,y:=&lt;-c,&lt;-c   fmt.Println(x,y,x+y)}
</code></pre>
</li>
</ul>
</li>
<li>
<p>Buffer channel 带缓存的 channel</p>
<ul>
<li>
<p><code>ch；=make(chan type,cap)</code> 在 cap 内的读写是无阻塞的 超过 cap 时候需要等待其他 goroutine 从 channel 中读取元素 释放空间</p>
</li>
<li>
<p><code>for i:=rang c</code> 可以不断读取 channel 直到 channel 被显示关闭</p>
</li>
<li>
<p><code>close</code>关闭 channel 无法发送数据 但可以在消费方通过<code>v,ok:=c;ok</code><em>断言</em>来测试是否关闭 channel</p>
<ul>
<li>在生产者方关闭 channle  在消费者方容易产生 panic</li>
<li>结束 range 循环/无数据需要发送时候关闭 channel 才使用 close显式关闭</li>
</ul>
</li>
<li>
<pre><code class="language-go">func fibonacc(n int, c chan int)  {   x,y:=1,1   for i:=0;i&lt;n;i++ {      c&lt;-x      x,y=y,x+y   }   close(c)	// 显示关闭 channel}func main() {   c:=make(chan int, 10)   go fibonacc(cap(c),c)   for i:=range c {      fmt.Println(i)   }}
</code></pre>
</li>
</ul>
</li>
<li>
<p>多 channel 下 <em>select</em></p>
<ul>
<li>
<p>select 关键字监听 channel 上的数据流动</p>
</li>
<li>
<p>默认是阻塞的  只有监听的 channel 上数据流动才运行  多个 channel 准备好时select 随机选择执行</p>
</li>
<li>
<p>类似 switch 有 <code>default</code>   可设置超时来退出循环</p>
</li>
<li>
<pre><code class="language-go">func fibonacc(c, quit chan int) {   x, y := 1, 1   for {      select {		// 类似 switch  监听 channel 上的数据流动      case c &lt;- x:         x, y  = y, x+y      case &lt;-quit:         fmt.Println(&quot;quit&quot;)         return      case &lt;-time.After(5*time.Second) // 阻塞超过5 s情况          fmpl(&quot;timeOut&quot;)          break;      }   }}func main() {   c := make(chan int)   quit:=make(chan int)   go func() {      for i := 0; i &lt; 10; i++ {         fmt.Println(&lt;-c)      }      quit&lt;-0   }()   fibonacc(c,quit)}
</code></pre>
</li>
</ul>
</li>
<li>
<p><code>Goexit</code></p>
<ul>
<li>退出当前 Goroutine 但defer 仍调用</li>
</ul>
</li>
<li>
<p><code>Gosched</code></p>
<ul>
<li>让出 goRoutine 权限</li>
</ul>
</li>
<li>
<p><code>NumCPU</code> <code>NumGoroutine</code></p>
<ul>
<li>返回 cpu数目</li>
<li>返回执行和排队的任务总数</li>
</ul>
</li>
<li>
<p><code>GOMAXPROCS</code></p>
<ul>
<li>并行计算的 cpu 核数最大值 返回之前的核数值</li>
</ul>
</li>
</ul>
<h2 id="references">References</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go web 基础]]></title>
        <id>https://flyingchase.github.io/post/go-web-ji-chu/</id>
        <link href="https://flyingchase.github.io/post/go-web-ji-chu/">
        </link>
        <updated>2021-09-04T15:02:30.000Z</updated>
        <content type="html"><![CDATA[<h1 id="go-web基础">Go Web基础</h1>
<h2 id="web-概念">web 概念</h2>
<h3 id="request">Request</h3>
<p>include post , get , cookie,  url</p>
<h3 id="response">Response</h3>
<h3 id="conn">Conn</h3>
<p>用户的每次请求链接</p>
<h3 id="handler">Handler</h3>
<p>处理请求和生成返回信息的处理逻辑</p>
<h2 id="http-包执行流程">Http 包执行流程</h2>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/image-20210903113614403.png" alt="image-20210903113614403" loading="lazy"></figure>
<ul>
<li>创建 Listen Socket 监听窗口</li>
<li>Listen Socket 接收客户端请求——&gt;client Socket</li>
<li>Client socket 读取 HTTP请求的协议头 交给对象的 handler 处理 再通过 client socket 写给客户端</li>
</ul>
<h4 id="监听端口">监听端口</h4>
<ul>
<li><code>ListenAndServe</code><br>
初始化 serve 对象，调用<code>net.Listen(&quot;tcp&quot;,addr)</code> 底层使用 tcp 协议搭建服务来监听端口</li>
<li></li>
</ul>
<h4 id="接收客户端请求">接收客户端请求</h4>
<ul>
<li>
<p>调用<code>srv.Serve(net.Listener)</code>函数</p>
</li>
<li>
<p>每次请求创建 Conn</p>
</li>
</ul>
<h4 id="分配-handler">分配 Handler</h4>
<ul>
<li>conn 解析 request <code>c.readRequest()</code> 获取 handler 即为调用 ListenAndServe 的第二个参数
<ul>
<li>为空 nil 则默认<code>handler=DefaultServeMax</code>  为路由器 匹配 url 跳转到对应的 handle 函数</li>
<li>路由请求规则<code>“/”</code>：
<ul>
<li>跳转到 <code>http.HandleFunc(&quot;/&quot;,selfFunc)</code> 中的自定义函数</li>
<li>DefaultServeMux 调用 ServeHTTP 方法 内部及调用 selfFunc</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="实战">实战</h1>
<h2 id="创建-web-server">创建 web server</h2>
<p>使用 http.ListenAndServer()</p>
<ul>
<li>
<p>第一个参数网络地址</p>
<ul>
<li>“” 则为所有网络接口的 80 端口</li>
</ul>
</li>
<li>
<p>第二个参数 handler</p>
<ul>
<li>nil 则为 DefaultServeMux(multipledxer) 看做路由器</li>
</ul>
</li>
</ul>
<p>使用http.Server</p>
<ul>
<li>struct
<ul>
<li>Addr 字段表示网络地址</li>
<li>Handler 字段
<ul>
<li>nil defaulSerMux</li>
</ul>
</li>
<li>ListenAndServe() 方法</li>
</ul>
</li>
</ul>
<pre><code class="language-go">// way One 
http.ListenAndServe(&quot;localhost:9090&quot;,nil)
// way Two
server:=http.Server{Addr: &quot;localhost:8080&quot;,Handler: nil}
server.ListenAndServe()
</code></pre>
<p>以上只能执行 http 而非 https</p>
<p>需要分别加上：</p>
<ul>
<li>http.ListenAndServeTLS()</li>
<li>Server.ListenAndServeTLS()</li>
</ul>
<h4 id="handler-2">Handler</h4>
<p>是一个 interface 接口</p>
<ul>
<li>
<p>定义了一个方法ServeHTTP()</p>
<ul>
<li>HTTPResponseWriter</li>
<li>指向 Request（struct）的指针</li>
</ul>
<pre><code class="language-go">type Handler interface {
   ServeHTTP(ResponseWriter, *Request)
}
</code></pre>
</li>
</ul>
<h4 id="defaultservemux">DefaultServeMux</h4>
<p>Multiplexer 多路复用器（可被视为路由器） 是 ServerMux 的一个指针变量</p>
<ul>
<li>也是一个 Handler</li>
<li>转发调用其他 handler</li>
<li>调用 http.Handle 函数实际上调用的是 DefaultServeMux 上的 Hanler 方法</li>
</ul>
<p>不指定 server struct 中的 handler 字段值</p>
<ul>
<li>可以使用 http.Handle 将某个 Handler 附加到 DefaultServeMux
<ul>
<li>http 包有一个 Handle 函数</li>
<li>ServerMux struct 也有一个 Handle 方法</li>
</ul>
</li>
</ul>
<h4 id="httphandle">http.Handle</h4>
<p>func Handle(pattern string, handler Handler)</p>
<ul>
<li>
<p>第二个参数是 handler（注意是<em>指针</em>）</p>
<pre><code class="language-go">type Handler interface {
 ServeHTTP(ResponseWriter, *Request)
// 实现 ServerHTTP 方法的类型均可视为 handler
 }
</code></pre>
</li>
</ul>
<pre><code class="language-go">server := http.Server{
   Addr: &quot;localhost:1090&quot;,
   Handler: nil,  // use DefaultServeMux
}
http.Handle(&quot;/wo&quot;,&amp;mh)
server.ListenAndServe()
</code></pre>
<h4 id="httphandlefunc">http.HandleFunc</h4>
<p>Handler函数行为与hanlder 类似 将 f 适配为 handler 使得handler 具有方法 f  类似<em>类型转换</em></p>
<p>作用即为： Handler 函数转化为 Handler 内部还是调用 http.Handle 函数</p>
<ul>
<li>Handler 函数的签名与 ServeHTTP 方法的签名一样，接收：
<ul>
<li>一个 http.ResponseWriter</li>
<li>一个 指向 http.Request 的指针</li>
</ul>
</li>
</ul>
<pre><code class="language-go">// 第二个参数是 func 但是不要带()  带（）就直接执行了
http.HandleFunc(&quot;/home&quot;,welcome)

func welcome(w http.ResponseWriter, r *http.Request) {
   w.Write([]byte(&quot;Home!&quot;))
}
</code></pre>
<p>HandleFunc 源码：</p>
<pre><code class="language-go">func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
    // 调用 DefaultServeMux 的 HandleFunc
   DefaultServeMux.HandleFunc(pattern, handler) 
}

// DefaultServeMux 的 HandleFunc 第二个参数是 Handler函数（不同于 http.Handle 第二个参数是 Handler）
func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
	if handler == nil {
		panic(&quot;http: nil handler&quot;)
	}
    // 内部还是调用 http.Handle 函数
	mux.Handle(pattern, HandlerFunc(handler))
}
</code></pre>
<h2 id="内置-handlers">内置 Handlers</h2>
<h3 id="notfoundhandler">NotFoundHandler</h3>
<pre><code class="language-go">// NotFound replies to the request with an HTTP 404 not found error.
func NotFound(w ResponseWriter, r *Request) { Error(w, &quot;404 page not found&quot;, StatusNotFound) }

// NotFoundHandler returns a simple request handler
// that replies to each request with a ``404 page not found'' reply.
func NotFoundHandler() Handler { return HandlerFunc(NotFound) }
</code></pre>
<p>给每个请求的响应均为404</p>
<h3 id="redirecthandler">RedirectHandler</h3>
<pre><code class="language-go">// Redirect to a fixed URL
type redirectHandler struct {
   url  string
   code int
}

// The provided code should be in the 3xx range and is usually
// StatusMovedPermanently, StatusFound or StatusSeeOther.
func RedirectHandler(url string, code int) Handler {
	return &amp;redirectHandler{url, code}
}
</code></pre>
<p>将每个请求使用给定的状态码code——&gt;指定的 url 跳转到提供的第一个参数</p>
<h3 id="stripprefix">StripPrefix</h3>
<pre><code class="language-go">func StripPrefix(prefix string, h Handler) Handler
</code></pre>
<p>从请求的 URL去掉指定的前缀prefix 再调用第二个参数 handler h</p>
<ul>
<li>请求的 URL 与前缀 prefix 不符合 404</li>
<li>h handler 将会在 请求 url 被去除 prefix 后调用 用于接收请求</li>
</ul>
<h3 id="timeouthandler">TimeoutHandler</h3>
<pre><code class="language-go">func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler
</code></pre>
<ul>
<li>time.Duration 表示一段时间 alias int64 的别名</li>
<li>返回 handler 在指定时间 dt duration 内运行传入的 h
<ul>
<li>h 将要被修饰的 handler</li>
<li>msg 超时则返回 msg 信息表示响应时间过长</li>
<li>dt 处理 h 的允许时间</li>
</ul>
</li>
</ul>
<h3 id="fileserver">FileServer</h3>
<pre><code class="language-go">func FileServer(root FileSystem) Handler
</code></pre>
<p>返回 handler 基于 root 文件系统来响应请求  root 是字符串作为根目录</p>
<pre><code class="language-go">// filestystem 可以自定义  通常委托给 
type FileSystem interface {
   Open(name string) (File, error)
}
</code></pre>
<p>eg 使用内置 filehandler 实现 handleFunc</p>
<pre><code class="language-go">http.HandleFunc(&quot;/&quot;,func(w http.ResponseWriter, r *http.Request) {
      http.ServeFile(w,r,&quot;wwwroot&quot;+r.URL.Path)
   })
   
http.ListenAndServe(&quot;:9090&quot;,nil)
http.ListenAndServe(&quot;8080&quot;,http.FileServer(http.Dir(&quot;wwwwroot&quot;)))
</code></pre>
<h2 id="请求-request">请求 Request</h2>
<h3 id="http-请求">HTTP 请求</h3>
<h3 id="request-2">Request</h3>
<h3 id="url">URL</h3>
<p>请求信息的第一行里面的信息</p>
<p>指向 url&gt;URL类型的指针 url&gt;URL 是一个 struct</p>
<p>scheme://[userinfo@]host/path[?query][#fragment]通用格式</p>
<p><em>Query</em></p>
<ul>
<li>查询字符串</li>
</ul>
<h3 id="header">Header</h3>
<p><code>map[string]/[]string</code>类型</p>
<p>设置 key 时候创建空的[]string 作为 value 第一个元素就是新的 header 值</p>
<p>key 添加元素执行 append 操作</p>
<h3 id="body">Body</h3>
<p>io.ReadCloser 接口</p>
<ul>
<li>
<p>reader 接口</p>
<ul>
<li>[]byte 返回 byte 的数量 可选的错误</li>
</ul>
</li>
<li>
<p>closer 接口</p>
<ul>
<li>返回可选的错误</li>
</ul>
</li>
</ul>
<h2 id="upload">UpLoad</h2>
<h3 id="form-表单">Form 表单</h3>
<h4 id="表单发送请求">表单发送请求</h4>
<ul>
<li>
<p>html 表单里面的数据以 name-value 对的形式 通过 method 规定post/get请求发送出去</p>
</li>
<li>
<p>数据内容存储在 POST 请求的 Body里面</p>
<ul>
<li>
<p>name-value 对的格式 通过表单的<code>Content Type</code>指定 <code>enctype</code>属性</p>
</li>
<li>
<p>entry 属性默认值 <code>application/x-www-form-urlcoded</code></p>
</li>
<li>
<p>enrty 属性设置为<code>multipart/form-data</code>   (大量数据、上传文件)</p>
<ul>
<li>每个 name-value 对转换为 MIME消息 每部分各自有 Content Type 和 Content Disposition</li>
</ul>
</li>
</ul>
</li>
<li>
<p>method 属性设置 POST 和 GET</p>
<ul>
<li>GET 请求没有 Body     数据通过 URL 编码的 name-value 对发送</li>
</ul>
</li>
</ul>
<h4 id="form-字段">Form 字段</h4>
<ul>
<li>
<p>Request 上的函数允许我们从 URL 或/和 Body 中提取数据，通过这些字段：</p>
<ul>
<li>Form  是 url.Values 类型——&gt;type Values map[string][]string 类型</li>
<li>PostForm</li>
<li>MultipartForm</li>
</ul>
</li>
<li>
<p>Form 里面的数据是 key-value 对</p>
<ul>
<li>每个 key 对应一个切片 可以有多个值</li>
</ul>
</li>
<li>
<p>通常的做法是：</p>
<ul>
<li>调用 ParseForm 或 ParseMultipartForm 来解析 Request</li>
<li>相应的访问 Form、PostForm 或 MultipartForm 字段</li>
</ul>
</li>
<li>
<pre><code class="language-go">func main() {
	server:=http.Server {
		Addr : &quot;localhost:8080&quot;,
	}
	http.HandleFunc(&quot;/process&quot;, func(w http.ResponseWriter,r *http.Request){
		r.ParseForm() // 解析 request

		fmt.Fprintln(w,r.Form)
	})
	server.ListenAndServe()
}

// index.html 输出 是一个 map[string][]string
// map[first_name:[wo] last_name:[456] uploaded:[Go Web.md]]
</code></pre>
</li>
</ul>
<h4 id="postform-字段">PostForm 字段</h4>
<p>只读取表单的 key-value 对 不需读取 url 的 kv 对  使用 PostForm 字段</p>
<p>当 url 和 form 中均有 key对应的 Value 时候 Form 字段显示所有的 values 表单在前 url 在后</p>
<pre><code class="language-html">map[first_name:[D] firtst_name:[Nick] last_name:[as]]  // D 为表单 Nick 为 url
</code></pre>
<ul>
<li>只支持<code>&quot;application/x-www-form-urlencoded&quot;</code></li>
</ul>
<pre><code class="language-go">fmt.Fprintln(w,r.PostForm)  // 使用 PostForm字段
// map[first_name:[qw] last_name:[q]]   只显示表单输入的 key对应的 values
</code></pre>
<h4 id="multipartform-字段">MultipartForm 字段</h4>
<ul>
<li>首先调用<code>ParseMultipartForm</code> 方法
<ul>
<li>该方法会在必要时调用 <code>ParseForm</code>方法
<ul>
<li>参数是需要读取数据的长度 字节数</li>
<li>MultipartForm 只包含<em>表单</em>的 key-value 对</li>
<li>返回类型是一个 struct 而不是 map。这个 struct 里有两个 map：
<ul>
<li>key 是 string，value 是 []string</li>
<li>空的（key 是 string，value 是文件）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-go">func main() {
   server:=http.Server {
      Addr : &quot;localhost:8080&quot;,
   }
   http.HandleFunc(&quot;/process&quot;, func(w http.ResponseWriter,r *http.Request){
      r.ParseMultipartForm(1024) // 解析 request  使用 ParseMultipartForm 解析 需要传入长度（字节数）

      fmt.Fprintln(w,r.MultipartForm) 
   })
   server.ListenAndServe()
}
// index 输出  struct 两个 map 第一个有数据第二个是空的
&amp;{map[first_name:[12] last_name:[12]] map[]}
</code></pre>
<h4 id="formvaluepostformvalue-字段">FormValue&amp;PostFormValue 字段</h4>
<p>FormValue 方法会返回 Form 字段中指定 key 对应的<em>第一个 value</em></p>
<ul>
<li>无需调用 ParseForm 或 ParseMultipartForm</li>
</ul>
<p>PostFormValue 方法只能读取 PostForm</p>
<ul>
<li>FormValue 和 PostFormValue 都会调用 ParseMultipartForm 方法</li>
<li>表单的 <code>enctype</code> 设为 multipart/form-data，无法通过 FormValue 获得想要的值。</li>
</ul>
<h4 id="文件-files">文件 Files</h4>
<ul>
<li>
<p>调用 <code>ParseMultipartForm</code> 方法</p>
</li>
<li>
<p>从 <code>File</code>字段获得 FileHeader 调用 Open 方法获得文件</p>
</li>
<li>
<p>使用<code>ioutil.ReadAll</code>函数将文件内容读取到 []byte中</p>
<pre><code class="language-go">func process(w http.ResponseWriter, r *http.Request) {
   r.ParseMultipartForm(1024) // 最大传递字节
   fileHead := r.MultipartForm.File[&quot;uploaded&quot;][0] // 读取指定 body 内容
   file, err := fileHead.Open()
   if err == nil {
      data, err := ioutil.ReadAll(file)
      if err == nil {
         fmt.Fprintln(w, string(data))
      }
   }
}

func main() {
   server := http.Server{
      Addr: &quot;localhost:8080&quot;,
   }
   http.HandleFunc(&quot;/process&quot;, process)
   server.ListenAndServe()
}
</code></pre>
</li>
</ul>
<p><em>FormFile</em></p>
<ul>
<li>返回对应 Key的第一个文件
<ul>
<li>返回指定 Key 的第一个 Value</li>
</ul>
</li>
</ul>
<h4 id="post-json">POST Json</h4>
<h4 id="multipartreader">MultipartReader</h4>
<pre><code class="language-go">func (r *Request) MultipartReader() (*multipart.Reader, error)
</code></pre>
<pre><code class="language-go">type ResponseWriter interface {   Header() Header   Write([]byte) (int, error)   WriteHeader(statusCode int)}// 是一个接口 response 实现了其内部的所有函数 所以 ResponseWriter 可视为 response 的指针
</code></pre>
<h3 id="responsewrite">ResponseWrite</h3>
<h3 id="内置-response">内置 Response</h3>
<ul>
<li>NotFound 函数，包装一个 404 状态码和一个额外的信息</li>
<li>ServeFile 函数，从文件系统提供文件，返回给请求者</li>
<li>ServeContent 函数，它可以把实现了 io.ReadSeeker 接口的任何东西里面的内容返回给请求者</li>
<li>还可以处理 Range 请求（范围请求），如果只请求了资源的一部分内容，那么 ServeContent 就可以如此响应。而 ServeFile 或 io.Copy 则不行。</li>
<li>Redirect 函数，告诉客户端重定向到另一个 URL</li>
</ul>
<pre><code class="language-go">func process(w http.ResponseWriter, r *http.Request) {   r.ParseMultipartForm(1024)                      // 最大传递字节   fileHead := r.MultipartForm.File[&quot;uploaded&quot;][0] // 读取指定 body 内容   file, err := fileHead.Open()   if err == nil {      data, err := ioutil.ReadAll(file)      if err == nil {         fmt.Fprintln(w, string(data))      }   }}func writeExample(w http.ResponseWriter, r *http.Request) {   str := `&lt;html&gt;&lt;head&gt;&lt;title&gt;Go Web&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello World&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;`   w.Write([]byte(str))}func writeHeaderExampl(w http.ResponseWriter, r *http.Request) {   w.WriteHeader(501)   fmt.Fprintln(w, &quot;No such service, try next door&quot;)}func main() {   server := http.Server{      Addr: &quot;localhost:8080&quot;,   }   http.HandleFunc(&quot;/write&quot;, writeHeaderExampl)   http.HandleFunc(&quot;/redirect&quot;, headerEXample)   http.HandleFunc(&quot;/json&quot;, jsonExample)   server.ListenAndServe()}func headerEXample(w http.ResponseWriter, r *http.Request) {   w.Header().Set(&quot;Location&quot;, &quot;http://google.com&quot;)   w.WriteHeader(302)}type Post struct {   User    string   Threads []string}func jsonExample(w http.ResponseWriter, r *http.Request) {   w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)   post := &amp;Post{      User : &quot;wlzhou&quot;,      Threads: []string {&quot;first&quot;,&quot;second&quot;,&quot;third&quot;},   }   json,_:=json.Marshal(post)   w.Write(json)}
</code></pre>
<h2 id="模板">模板</h2>
<p>Web 模板即为 HTML 页面（预先设置好的）</p>
<p><code>text/template</code> <code>html/template</code>模板库</p>
<h3 id="模板引擎">模板引擎</h3>
<p>合并模板和上下文数据产生 HTML</p>
<ul>
<li>生成 HTML 写入<code>ResponseWriter</code> 再加入 HTTP响应返回给客户端</li>
<li><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/IG3Raz.png" alt="IG3Raz" loading="lazy"></li>
</ul>
<p><em>ParseFiles</em></p>
<ul>
<li>解析模板文件 创建解析好的模板 struct</li>
<li>是 template struct 上的 ParseFiles 上的方法调用</li>
</ul>
<p>创建新的模板 名称为文件名</p>
<pre><code class="language-go"> t, _ := template.ParseFiles(&quot;tmpl.html&quot;)
</code></pre>
<p><em>ParseGlob</em></p>
<ul>
<li>
<p>模式匹配  根目录下匹配</p>
<pre><code class="language-go"> t, _ := template.ParseGlob(&quot;*.html&quot;)
</code></pre>
</li>
</ul>
<p><em>Parse</em></p>
<ul>
<li>上述两个函数均会调用</li>
</ul>
<h3 id="action">Action</h3>
<p>模板中嵌入的命令 两组花括号之间{{}}</p>
<p>条件 迭代 设置 包含 定义</p>
<h3 id="参数-管道-变量">参数、管道、变量</h3>
<p><em>参数：</em></p>
<ul>
<li>模板中的值
<ul>
<li>bool 整数 string struct key 变量 方法</li>
</ul>
</li>
</ul>
<p><em>管道：</em></p>
<p>Unix 管道类似</p>
<ul>
<li>把参数输出发送到下一个参数</li>
<li>|隔开</li>
</ul>
<h3 id="函数">函数</h3>
<p>内置函数有：</p>
<p>​	define template block html js urlquery</p>
<p>index print len with</p>
<p>自定义函数：</p>
<pre><code class="language-go">template.Funcs(funcMap FuncMap) *Templatetype FuncMap map[string]interface{}
</code></pre>
<h3 id="模板组合">模板组合</h3>
<h2 id="路由">路由</h2>
<p>Controller</p>
<ul>
<li>Main() 设置类工作</li>
<li>Controller：
<ul>
<li>静态资源</li>
<li>不同的请求发送给不同的 controller 处理</li>
</ul>
</li>
</ul>
<h3 id="路由参数">路由参数</h3>
<ul>
<li>
<p>静态路由：</p>
<ul>
<li>一个路径对应一个页面
<ul>
<li>/home /index</li>
</ul>
</li>
</ul>
</li>
<li>
<p>带参路由：</p>
<ul>
<li>依据路由参数 创建出一族不同的页面
<ul>
<li>/companies/123</li>
<li>/companies/homeAbout</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go Concurrency]]></title>
        <id>https://flyingchase.github.io/post/go-concurrency/</id>
        <link href="https://flyingchase.github.io/post/go-concurrency/">
        </link>
        <updated>2021-09-03T03:05:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="concurrency">Concurrency</h2>
<ul>
<li>通过通信来共享而非通过共享来通信 并发模型采用 CSP communicating Seqyential process</li>
<li>goroutine 运行在相同的地址空间</li>
<li>底层也是通过共享内存的加锁来实现  抽象级别层级更高</li>
</ul>
<h4 id="channel">channel</h4>
<ul>
<li>
<p>channel 必须使用 make 创建并定义发送到 channel 的类型</p>
</li>
<li>
<p>cap 可以读取 channel 的缓存容量</p>
<ul>
<li>
<pre><code class="language-go">ch:=make(chan int) // 定义同时规定发送到 chan 的类型
v:=1
ch&lt;-v 	// 将 v 发送到 chan
w:=&lt;-ch	// 从 ch中读取并赋值给 w
</code></pre>
</li>
</ul>
</li>
<li>
<p>默认无缓存chan 接受和发送是阻塞的  除非另外一端准备好</p>
<ul>
<li>
<p><code>value:&lt;-c</code> 读取会被阻塞 直到有数据接受</p>
</li>
<li>
<p><code>ch&lt;-5</code> 发送会被阻塞 直到有被读取</p>
</li>
<li>
<pre><code class="language-go">func sum(a []int, c chan int)  {
   total:=0
   for _,v:=range a{
      total+=v
   }
   c&lt;-total

}
func main() {
   a:=[...]int {1, 2, 3,4,5,6,7,8,9,0}
   c:=make(chan int)
   go sum(a[:len(a)/2],c)
   go sum(a[len(a)/2:],c)
   x,y:=&lt;-c,&lt;-c
   fmt.Println(x,y,x+y)
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>Buffer channel 带缓存的 channel</p>
<ul>
<li>
<p><code>ch：=make(chan type,cap)</code> 在 cap 内的读写是无阻塞的 超过 cap 时候需要等待其他 goroutine 从 channel 中读取元素 释放空间</p>
</li>
<li>
<p><code>for i:=rang c</code> 可以不断读取 channel 直到 channel 被显示关闭</p>
</li>
<li>
<p><code>close</code>关闭 channel 无法发送数据 但可以在消费方通过<code>v,ok:=c;ok</code><em>断言</em>来测试是否关闭 channel</p>
<ul>
<li>在生产者方关闭 channle  在消费者方容易产生 panic</li>
<li>结束 range 循环/无数据需要发送时候关闭 channel 才使用 close显式关闭</li>
</ul>
</li>
<li>
<pre><code class="language-go">func fibonacc(n int, c chan int)  {
   x,y:=1,1
   for i:=0;i&lt;n;i++ {
      c&lt;-x
      x,y=y,x+y
   }
   close(c)	// 显示关闭 channel
}
func main() {
   c:=make(chan int, 10)
   go fibonacc(cap(c),c)
   for i:=range c {
      fmt.Println(i)
   }
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>多 channel 下 <em>select</em></p>
<ul>
<li>
<p>select 关键字监听 channel 上的数据流动</p>
</li>
<li>
<p>默认是阻塞的  只有监听的 channel 上数据流动才运行  多个 channel 准备好时select 随机选择执行</p>
</li>
<li>
<p>类似 switch 有 <code>default</code>   可设置超时来退出循环</p>
</li>
<li>
<pre><code class="language-go">func fibonacc(c, quit chan int) {
   x, y := 1, 1
   for {
      select {		// 类似 switch  监听 channel 上的数据流动
      case c &lt;- x:
         x, y  = y, x+y
      case &lt;-quit:
         fmt.Println(&quot;quit&quot;)
         return
      case &lt;-time.After(5*time.Second) // 阻塞超过5 s情况
          fmpl(&quot;timeOut&quot;)
          break;
      }
   }
}

func main() {
   c := make(chan int)
   quit:=make(chan int)
   go func() {
      for i := 0; i &lt; 10; i++ {
         fmt.Println(&lt;-c)
      }
      quit&lt;-0
   }()
   fibonacc(c,quit)
}
</code></pre>
</li>
</ul>
<h5 id="channel-通信">channel 通信</h5>
<pre><code class="language-go">func testAppendA(t *testing.T) {
   x := []int{1, 2, 3}
   appendA(x)
   fmt.Printf(&quot;main %v\n&quot;, x)
}

func appendA(x []int) {
   x[0] = 100
   fmt.Printf(&quot;appendA %v\n&quot;, x)
}
func main() {
   ch := make(chan struct{})

   go func() {
      for i := 1; i &lt; 11; i++ {
         ch &lt;- struct{}{}
         if i%2 == 1 {
            fmt.Println(&quot;奇数&quot;, i)
         }
      }
   }()
   go func() {
      for i := 0; i &lt; 11; i++ {
         &lt;-ch
         if i%2 == 0 {
            fmt.Println(&quot;偶数&quot;, i)
         }
      }
   }()
   time.Sleep(10 * time.Second)
}
</code></pre>
</li>
</ul>
<h5 id="广播通信">广播通信</h5>
<pre><code class="language-go">func main() {
   notify := make(chan struct{})

   for i := 0; i &lt; 10; i++ {
      go func(i int) {
         for {
            select {
            case &lt;-notify:
               fmt.Println(&quot;done...&quot;, i)
            case &lt;-time.After(1 * time.Second):
               fmt.Println(&quot;wait notify&quot;, i)
            }
         }
      }(i)
   }
   time.Sleep(1 * time.Second)
   close(notify)
   time.Sleep(3 * time.Second)
}
</code></pre>
<ul>
<li><code>Goexit</code>
<ul>
<li>退出当前 Goroutine 但defer 仍调用</li>
</ul>
</li>
<li><code>Gosched</code>
<ul>
<li>让出 goRoutine 权限</li>
</ul>
</li>
<li><code>NumCPU</code> <code>NumGoroutine</code>
<ul>
<li>返回 cpu数目</li>
<li>返回执行和排队的任务总数</li>
</ul>
</li>
<li><code>GOMAXPROCS</code>
<ul>
<li>并行计算的 cpu 核数最大值 返回之前的核数值</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GoLang 语法入门笔记]]></title>
        <id>https://flyingchase.github.io/post/golang-yu-fa-ru-men-bi-ji/</id>
        <link href="https://flyingchase.github.io/post/golang-yu-fa-ru-men-bi-ji/">
        </link>
        <updated>2021-08-30T07:14:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="golang语法">GoLang语法</h1>
<h3 id="10-引入">1.0 引入</h3>
<pre><code class="language-go">//firt-in-go.go
package main
import &quot;fmt&quot;

func main(){
  fmt.println(&quot;firt-print-in-go\n&quot;)
    // println
}
</code></pre>
<ul>
<li>
<p>首行包名必须存在，Go通过包管理命名空间</p>
</li>
<li>
<p><code>import</code>为引入外包；<code>fmt</code>为标准输出输出包；</p>
</li>
<li>
<p><code>func</code>为函数定义的关键字；</p>
</li>
</ul>
<p><strong>Go语言特征：</strong></p>
<ul>
<li>默认UTF-8编码；</li>
<li>标志符区分大小写；</li>
<li>语句结尾 <code>;</code>可省略；</li>
<li><em>函数{必须在函数开头同一行；</em></li>
<li>调用包中方法采用 <code>.</code>访问符；</li>
<li>mian函数包名需为main；</li>
<li>强类型的静态编译语言</li>
</ul>
<p><strong>格式化输出：</strong></p>
<pre><code class="language-go">%d          十进制整数
%x, %o, %b  十六进制，八进制，二进制整数。
%f, %g, %e  浮点数： 3.141593 3.141592653589793 3.141593e+00
%t          布尔：true或false
%c          字符（rune） (Unicode码点)
%s          字符串
%q          带双引号的字符串&quot;abc&quot;或带单引号的字符'c'
%v          变量的自然形式（natural format）
%T          变量的类型
%%          字面上的百分号标志（无操作数）
</code></pre>
<p><strong>各项零值：</strong></p>
<pre><code class="language-go">int     0
int8    0
int32   0
int64   0
uint    0x0
rune    0 //rune的实际类型是 int32
byte    0x0 // byte的实际类型是 uint8
float32 0 //长度为 4 byte
float64 0 //长度为 8 byte
bool    false
string  &quot;&quot;
</code></pre>
<p><strong>Notion:</strong></p>
<ul>
<li><code>,</code>操作符没有 故而多个操作使用平行赋值 <code>i,j=1,1</code></li>
<li>查看变量类型 <code>fmt.println(&quot;type is&quot;,reflect.typeOf(var name))</code>
<ul>
<li><code>fmt.Printf(&quot;%T&quot;,val)</code></li>
</ul>
</li>
</ul>
<h3 id="11-token-词法分析">1.1 Token 词法分析</h3>
<img src="/Users/qlzhou/Library/Application Support/typora-user-images/image-20201215121911426.png" alt="image-20201215121911426" style="zoom:40%;" />
<h3 id="12-标志符">1.2 标志符</h3>
<ul>
<li>
<p>规则：</p>
<p>​	字母和下划线开头，区分大小写；</p>
</li>
</ul>
<p>**数据类型标志符：**20</p>
<ul>
<li>
<p>数值：</p>
<p>byte int int8 int16 int32 int64 uint uint8 uint16 uint64 uinprt（整数）</p>
<p>​				不同类型之间必须强制类型转换；</p>
<p>​				支持算术/位运算 结果仍为整型；</p>
<p>float32 float64（浮点数）</p>
<p>​				默认为float64 <code>var a:=1.0</code></p>
<p>complex64 complex128（复数）</p>
<p>​				<code>complex real image (构造 返回实部、返回虚部)</code></p>
<p>​</p>
<pre><code class="language-go">var v complex64=3.14+5i
v1:=3.14+5i
var v2 = complex(3.14,5)
a:=real(v)//实部
b:=imag(v)//虚步
</code></pre>
</li>
<li>
<p>字符 字符串：string rune</p>
<p>采用UTF-8字符集编码</p>
<p>字符串不可变 无法通过数字下标修改</p>
<p>可以使用操作符 **+**来链接字符串</p>
<p>​</p>
<pre><code class="language-go">var a =&quot;直接用字符串初始化&quot;
var emptyString string =&quot;&quot;	//声明空字符串
//同时声明多个字符串 
no,yes,may :=&quot;no&quot;,&quot;yes&quot;,&quot;may&quot;
/*字符串多行声明  使用``*/
s :=`my
		love`	//	``包括的字符串为Raw字符串，在代码中形式即为打印出的形式 没有字符转义 换行亦直接输出
no=&quot;yes&quot;		//常规赋值


/*可以数组索引下标值 但不可修改*/
var b = &quot;abcdef&quot;
c:=b[0]
b[0]='1'	//ERROR!!
/*字符串修改方法*/
/*- 将字符串转化为[]byte类型*/
c :=[]byte(a)
c[0]='1'
a1 :=string(c)	//再回转为string
fmt.Println(&quot;%s&quot;,a1)		//输出为1bcdef
fmt.Printf(&quot;%c&quot;,a1[0])	//输出为1
fmt.Printf(&quot;%q&quot;,a1[0])	//输出为'1'
/*- 使用切片操作修改字符串 */
s :=&quot;mylove&quot;
s=&quot;y&quot;+s[1:]
fmt.Printf(&quot;%s\n&quot;,s)


/* 字符串尾部不含NULL字符 */

/* “+”操作符链接字符串 可连接多个
s :=&quot;try&quot;
s1 :=&quot;it&quot;
s2 :=&quot;!&quot;
s3 :=s+s1
s4 :=s+s1+s2
fmt.Printf(&quot;%s\n&quot;,s+s1)
fmt.Printf(&quot;%s\n&quot;,s3)
fmt.Printf(&quot;%s\n&quot;,s+s1+s2)
fmt.Printf(&quot;%s\n&quot;,s4)
</code></pre>
<p>字符串可以拼接+ len()返回长度</p>
<pre><code class="language-go">a：=&quot;hello&quot;
b：=&quot;world&quot;

c：=a+b		//可以拼接
len(a)		//内置函数无需导入

d:=&quot;hello,go!&quot;

for i:=0;i&lt;len(d);i++ {	//数组下标形式访问字符串
  fmt.println(d[i])
}

for i,v:=rang d{
  fmt.println(i,v)
}
</code></pre>
</li>
<li>
<p>array slice map</p>
<ul>
<li>
<p>数组 array</p>
<p>定义方式为<code>var arr [n]type</code> 其中arr为名称 n为数组长度 type为元素类型 n忽略则需要同时赋值 Go会自动计算长度</p>
<p>Len(arr)可直接计算长度</p>
<p>支持数组嵌套成为多维数组</p>
<p>长度不可变 值传递和值赋值</p>
<pre><code class="language-go">var arr[10]int //长为10的in t类型数组arr 默认为类型的零值
a[0]=1	//从0开始 直接赋值

/*赋值同时声明 */
a:=[3]int{1,2,3}
b:=[...]int{1,2,3}	//省略长度 自动计算长度

/*二维数组*/
doubleArray:=[2][4]int{[4]int{1,2,3,4},[4]int{1,2,3,4}}
doubleArray:=[2][4]int{{1,2,3,4},{1,2,3,4}}

</code></pre>
</li>
<li>
<p><strong>slice</strong></p>
<p>即为动态数组，<code>slice</code>并不是真正意义上的动态数组，而是一个引用类型。<code>slice</code>总是指向一个底层<code>array</code>。</p>
<pre><code class="language-go">// 和声明array一样，只是少了长度
var fslice []int
</code></pre>
<pre><code class="language-go">slice := []byte {'a', 'b', 'c', 'd'}
</code></pre>
<p><code>slice</code>可以从一个数组或一个已经存在的<code>slice</code>中再次声明。<code>slice</code>通过<code>array[i:j]</code>来获取，其中<code>i</code>是数组的开始位置，<code>j</code>是结束位置，但不包含<code>array[j]</code>，它的长度是<code>j-i</code>。</p>
<pre><code class="language-go">// 声明一个含有10个元素元素类型为byte的数组
var ar = [10]byte {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}
// 声明两个含有byte的slice
var a, b []byte// a指向数组的第3个元素开始，并到第五个元素结束，
a = ar[2:5]
//现在a含有的元素: ar[2]、ar[3]和ar[4]
// b是数组ar的另一个slice
b = ar[3:5]
// b的元素是：ar[3]和ar[4]
</code></pre>
<ul>
<li><code>slice</code>的默认开始位置是0，<code>ar[:n]</code>等价于<code>ar[0:n]</code></li>
<li><code>slice</code>的第二个序列默认是数组的长度，<code>ar[n:]</code>等价于<code>ar[n:len(ar)]</code></li>
<li>如果从一个数组里面直接获取<code>slice</code>，可以这样<code>ar[:]</code>，因为默认第一个序列是0，第二个是数组的长度，即等价于<code>ar[0:len(ar)]</code></li>
<li>对于<code>slice</code>有几个有用的内置函数：
<ul>
<li><code>len</code> 获取<code>slice</code>的长度</li>
<li><code>cap</code> 获取<code>slice</code>的最大容量</li>
<li><code>append</code> 向<code>slice</code>里面追加一个或者多个元素，然后返回一个和<code>slice</code>一样类型的`slice``</li>
<li>``copy<code>函数</code>copy<code>从源</code>slice<code>的</code>src<code>中复制元素到目标</code>dst`，并且返回复制的元素的个数</li>
</ul>
</li>
</ul>
<p>注：<code>append</code>函数会改变<code>slice</code>所引用的数组的内容，从而影响到引用同一数组的其它<code>slice</code>。 但当<code>slice</code>中没有剩余空间（即<code>(cap-len) == 0</code>）时，此时将动态分配新的数组空间。返回的<code>slice</code>数组指针将指向这个空间，而原数组的内容将保持不变；其它引用此数组的<code>slice</code>则不受影响。</p>
<pre><code class="language-go">// 声明一个数组
var array = [10]byte{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}
// 声明两个slice
var aSlice, bSlice []byte
// 演示一些简便操作
aSlice = array[:3] // 等价于aSlice = array[0:3] aSlice包含元素: a,b,c
aSlice = array[5:] // 等价于aSlice = array[5:10] aSlice包含元素: f,g,h,i,j
aSlice = array[:]  // 等价于aSlice = array[0:10] 这样aSlice包含了全部的元素
// 从slice中获取slice
aSlice = array[3:7]  // aSlice包含元素: d,e,f,g
bSlice = aSlice[1:3] // bSlice 包含aSlice[1], aSlice[2] 也就是含有: e,f
bSlice = aSlice[:3]  // bSlice 包含 aSlice[0], aSlice[1], aSlice[2] 也就是含有: d,e,f
bSlice = aSlice[0:5] // 对slice的slice可以在cap范围内扩展，此时bSlice包含：d,e,f,g,h
bSlice = aSlice[:]   // bSlice包含所有aSlice的元素: d,e,f,g
</code></pre>
<p>从概念上面来说<code>slice</code>像一个结构体，这个结构体包含了三个元素：</p>
<ul>
<li>
<p>一个指针，指向数组中<code>slice</code>指定的开始位置 即为引用修改</p>
</li>
<li>
<p>长度，即<code>slice</code>的长度</p>
</li>
<li>
<p>最大长度，也就是<code>slice</code>开始位置到数组的最后位置的长度</p>
<pre><code class="language-go">  Array_a := [10]byte{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}  
Slice_a := Array_a[2:5]
</code></pre>
</li>
</ul>
<h3 id="map">map</h3>
<pre><code class="language-go">map//也就是Python中字典的概念
map[keyType]valueType
// 类似表格 key对应着values 
</code></pre>
<p><code>slice</code>的<code>index</code>只能是 <code>int</code> 类型，<code>map</code>是<code>int</code>，可以是<code>string</code>及所有完全定义了<code>==</code>与<code>!=</code>操作的类型。</p>
<pre><code class="language-go">// 声明一个key是字符串，值为int的字典,这种方式的声明需要在使用之前使用make初始化
var numbers map[string]int
// 另一种map的声明方式
numbers = make(map[string]int)
numbers[&quot;one&quot;] = 1  //赋值
numbers[&quot;ten&quot;] = 10 //赋值
numbers[&quot;three&quot;] = 3
fmt.Println(&quot;第三个数字是: &quot;, numbers[&quot;three&quot;]) // 读取数据
// 打印出来如:第三个数字是: 3
</code></pre>
<p>Note:</p>
<ul>
<li><code>map</code>是无序的，每次打印出来的<code>map</code>都会不一样，它不能通过<code>index</code>获取，而必须通过<code>key</code>获取</li>
<li><code>map</code>的长度是不固定的，也就是和<code>slice</code>一样，也是一种引用类型</li>
<li>内置的<code>len</code>函数同样适用于<code>map</code>，返回<code>map</code>拥有的<code>key</code>的数量</li>
<li><code>map</code>的值可以很方便的修改，通过<code>numbers[&quot;one&quot;]=11</code>可以很容易的把key为<code>one</code>的字典值改为<code>11</code></li>
<li><code>map</code>有两个返回值，第一个为values第二个为存在否，存在为true，不存在为false</li>
<li><code>map</code>和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用mutex lock机制</li>
</ul>
<p><code>map</code>的初始化可以通过<code>key:val</code>的方式初始化值，同时<code>map</code>内置有判断是否存在<code>key</code>的方式</p>
<p>通过<code>delete</code>删除<code>map</code>的元素：</p>
<pre><code class="language-go">// 初始化一个字典
rating := map[string]float32{&quot;C&quot;:5, &quot;Go&quot;:4.5, &quot;Python&quot;:4.5, &quot;C++&quot;:2 }
// map有两个返回值，第二个返回值，如果不存在key，那么ok为false，如果存在ok为true
csharpRating, ok := rating[&quot;C#&quot;]
if ok {
  fmt.Println(&quot;C# is in the map and its rating is &quot;, csharpRating)
}else {
  fmt.Println(&quot;We have no rating associated with C# in the map&quot;)
}
delete(rating, &quot;C&quot;)  
// 删除key为C的元素
</code></pre>
<p><code>map</code>也是一种引用类型，如果两个<code>map</code>同时指向一个底层，那么一个改变，另一个也相应的改变：</p>
<pre><code class="language-go">m := make(map[string]string)
m[&quot;Hello&quot;] = &quot;Bonjour&quot;
m1 := m
m1[&quot;Hello&quot;] = &quot;Salut&quot;  // 现在m[&quot;hello&quot;]的值已经是Salut了
</code></pre>
</li>
</ul>
</li>
<li>
<p>接口：error</p>
</li>
<li>
<p>布尔：bool</p>
<p>​				默认false；&amp;&amp; || ! 操作符</p>
<p>​				仅两值 ture false <code>var ok bool</code>  <code>ok = true</code> //<code>ok:=true</code></p>
<p>​				表达式/逻辑表达式的结果为bool；if for条件为bool</p>
</li>
</ul>
<p>**内置函数：**15 全局可用 无需导入import</p>
<p><code>make new lwn cap append copy delete panic recover close complex real image Print Println</code></p>
<p>**常量标志符：**4</p>
<p><code>ture false;iota（连续枚举）;nil（指针/引用变量默认值nil）</code></p>
<p>**空白标志符：**1</p>
<p><code>_</code></p>
<pre><code class="language-go">//空白标志符用于去除第一项值
sum :=0
for _;value:=range array{
  sum+=value
}
</code></pre>
<pre><code class="language-go">	var a string = &quot;inital&quot;
	fmt.Println(a)
//输出inital

	var b,c int =1,2
	fmt.Println(b,c)
//输出1 2

	var d =true
	fmt.Println(!d)
//输出false

	var e int
	fmt.Println(e)
//输出0 默认int未赋值
	f :=&quot;one&quot;				//命名方式 无须声明
	fmt.Println(f)
</code></pre>
<pre><code class="language-go">	
	const s string = &quot;constant&quot;
	fmt.Println(s)

	const n =50000000
	const d = 3e20 / n 

	fmt.println(d)
	fmt.println(int64(d))

	fmt.println(math.Sin(n))
</code></pre>
<h3 id="13-变量">1.3 变量</h3>
<hr>
<p><code>var 变量名称 类型 = 表达式</code></p>
<p>其中 类型/表达式可忽略一个 类型忽略自行推倒；表达式忽略初始化0值 数值=0 boolean=false string=&quot;&quot;空 接口。引用（slice 指针 map chan 函数）对应零值=nil</p>
<p><em>即Go中无未初始化的变量</em></p>
<pre><code class="language-go">//同时声明多个变量
var i,j,k int
var b,f,s=true,3.14,&quot;four&quot;		//bool,float64,string
var names []string
i,j:=1,0

</code></pre>
<p>**:=**是变量声明语句 **=**是赋值操作 <code>i,j=j,i //交换值</code></p>
<ul>
<li>:= 其左边变量不一定是第一次声明，如果已经声明 则:=仅用于赋值 <em>但其中至少有一个变量是新声明</em></li>
</ul>
<pre><code class="language-go">in ,err :=os.Open(infile)
out,err :=os.Create(outfile)	//out声明并赋值 err仅赋值

f,err :=os.Open(infile)
f,err :=os.Create(outfile)	//	error! 至少一个声明
</code></pre>
<p><strong>指针：</strong></p>
<p><code>var x int;p=&amp;x</code>称p指针指向变量x *p表达式为读取p指针指向的变量x的值</p>
<pre><code class="language-go">x :=1
p :=&amp;x
fmt.Println(*p)		//p of type *int,points to x
*p=2			//equivalent to x=2
fmt.Println(x)
</code></pre>
<ul>
<li>不可<code>++age</code>但可以<code>age++</code></li>
</ul>
<h3 id="14-控制结构">1.4 控制结构</h3>
<hr>
<p><em>控制结构的左大括号不可另起一行</em> 否则会自动在大括号前插入;</p>
<p>reason: Go正式语法以; 分号结束语句 词法分析器自动插入分号  故而源码中不必使用;</p>
<p>​				词法分析器插入规则：新行前最后一个标记为标志符、数值、字符串常量 或者 <code>break continue fallthrough return ++ -- ) }</code>等将在该标记后插入;</p>
<p>​				新行前的标记为语句末尾 则插入分号; 分号还可在闭括号之前省略 <code>go func() { for {dst &lt;- &lt;-src}} ()</code></p>
<p>**关键字 keywords：**25个</p>
<ul>
<li>
<p>引导程序整体结构：8</p>
<p>​	<code>package、import、const、var（变量声明关键字）、func、defer(延迟执行)、go(并发语法关键字)、return</code></p>
</li>
<li>
<p>复合数据结构：4</p>
<p>​	<code>struct、interface(接口类型)、map(声明/创建map)、chan(声明/创建通道)</code></p>
</li>
<li>
<p>控制程序结构：13</p>
<p>​	<code>if eles、for range break continue(循环)、switch select type case default fallthroug(select/switch语句关键字)、goto</code></p>
</li>
</ul>
<p><strong>if</strong></p>
<p><strong>if...else...</strong></p>
<p>​	条件表达式的值必须为boolean 可以省略括号 左花括号不可另起一行</p>
<p>​	条件表达式可以定义局部变量 初始化函数**（作用域为if/else块）** 可接受初始化语句</p>
<pre><code class="language-go">if x&gt;0 {
  return y
}
//初始化语句
if err:=file.Chmod(0664);err!=nil{
  log.Print(err)
  return err
}
</code></pre>
<p><strong>go to</strong></p>
<p><code>goto</code>跳转必须在函数内定义的标签</p>
<pre><code class="language-go">func main(){
  i:=0
  Here:
  fmt.Printf(i)
  i++
  goto Here
}
</code></pre>
<p><strong>For</strong></p>
<p>可以循环又可以控制逻辑作为while使用</p>
<p><code>for expression1;expression2;expression3{}</code>e1\e3均为变量声明 函数调用返回值 e2判断条件 e1在循环开始前调用 e3在每轮循环结束后调用</p>
<p>e1 e3可省略 for e2{}即为仅仅判断e2的条件 相当于while使用 <code>break</code>跳出所有循环 <code>continue</code>结束本次循环 继续下一次</p>
<p>无 <code>,</code>操作符 多变量使用平行赋值</p>
<pre><code class="language-go">//for的三种用法
for init;condition;post{}		//类似C
for condition {}		//类似C中的while
for{}		//类似C中for(;;)

sum:=0
for i:=0;i&lt;10;i++{
  sum+=i
}

//遍历数组 切片 字符串 映射 信道读取 使用rang
for key,value:=range oldMap {
  newMap[key] =value
}

//range在字符串中解析utf-8 独立的Unicode码点分离出来 错误编码占据一个字节 以U+FFFD代替1																		`1`

for pos, char := range &quot;日本\x80語&quot; { // \x80 在 UTF-8 编码中是一个非法字符
    fmt.Printf(&quot;character %#U starts at byte position %d\n&quot;, char, pos)
}

//go无,逗号操作符 在for中多个变量应该采用平行赋值 
for i,j:=0,len(a)-1;i&lt;j;i,j=i+1,j-1{
  a[i],a[j]=a[j],a[i]
}

</code></pre>
<p><strong>Switch：</strong></p>
<pre><code class="language-go">//使用说明
switch sExpr{
  case e1:
  		s1
  case e2:
  		s2
}
</code></pre>
<ul>
<li>其中switch sExpr必须和e1 e2为同一类型 sExpr无表达式为true</li>
<li>默认case 带有break；可使用 <code>fallthroug</code>强制执行后续case</li>
</ul>
<p><strong>make new使用：</strong></p>
<p>make用于内建类型（map slice channel）内存分配；new可以用于全部内存分配</p>
<p><strong>new(Type)</strong> 分配零值的Type类型的内存空间，返回地址为*Type 返回指针，指向新分配的类型Type的零值</p>
<p>New(T) make(T,args)</p>
<p><em>new返回指针</em>	<em>make返回初始化后非零值</em></p>
<h3 id="15-函数">1.5 函数</h3>
<ul>
<li>
<p>保留函数 <code>init main</code> 不存在参数和返回值</p>
</li>
<li>
<p><code>import</code></p>
<ul>
<li>
<p>支持相对和绝对路径的导入，<code>import &quot;./model&quot;</code>当前文件同目录下 <code>import &quot;short/model&quot;</code>加载footpath/src/short/model</p>
</li>
<li>
<p><code>import ( .&quot;fmt)</code> 使得调用包内函数可以忽略包名 <code>fmt.Println(&quot;&quot;)</code>——&gt;<code>Println(&quot;&quot;)</code></p>
</li>
<li>
<pre><code class="language-go">// 将包别名化 使用为f.Println()
import (
  f &quot;fmt&quot;
)

// _操作 
impot (
	&quot;database/sql&quot;
  _&quot;gihub.com/ziutek/mymysql/godrv&quot;	//_操作为引入包但不直接食用包内函数，调用包内init函数
)

</code></pre>
</li>
</ul>
</li>
</ul>
<p>func关键字声明;</p>
<pre><code class="language-go">func funcName(input1 type, inpute2 type)(output1 type,output type){
  
  return v1,v2
}
</code></pre>
<ul>
<li>多参输入 <code>,</code>分隔 多个返回值；</li>
<li>返回值声明变量 output1 output2可忽略</li>
<li>可接受变参</li>
</ul>
<pre><code class="language-go">func SumAndProduct(A,B int)(int,int) {
	return A+B , A*B
	
}

func main(){
	x:=3
	y:=5

	x1,x2:=SumAndProduct(x,y)

	fmt.Printf(&quot;%d+%d=%d\n&quot;,x,y,x1)
	fmt.Printf(&quot;%d*%d=%d\n&quot;,x,y,x2)

  }
</code></pre>
<ul>
<li>
<p>支持变参输入</p>
<p><code>func myFunc(arg ...int){}</code> arg ...int即为不定参数的int输入 arg则为int的slice</p>
</li>
</ul>
<p><strong>延迟 defer:</strong></p>
<p><strong>函数作为值和类型：</strong></p>
<p>在函数中传递函数类型</p>
<h3 id="16-struct-结构体">1.6 Struct 结构体</h3>
<pre><code class="language-go">//定义和使用type person struct {	name string	age  int}var P personfunc main() {  /*逐个赋值 */	P.name = &quot;hello&quot;	P.age = 22  P.name,P.age=&quot;qq&quot;,01  /* 直接使用并赋值 */  P1:=person{&quot;world&quot;,18}	fmt.Printf(&quot;%s\n %d\n&quot;, P.name, P.age)  //错误使用   fmt.Printf(&quot;%s\n&quot;,P1)   // {world %!s (int=18)}    /*通过field:value初始化任意顺序 */  P3:=person{age:24,name:&quot;aaa&quot;}    /* new函数分配指针 类型为*person */  P4:=new(person)}
</code></pre>
<p><strong>匿名字段</strong></p>
<p>将多个结构体中公共部分字段拿出来单独作为结构体，使之嵌套在其他结构体中，可以略过中间结构体名</p>
<p>外在结构体可以直接访问内在结构体的属性 同样可以多重嵌套</p>
<pre><code class="language-go">type Point struct {		x, y int	}	type Circle struct {		Point		Radius int	}	type Wheel struct {		Circle		spokes int	}	var w Wheel//多层嵌套，同时赋值	w = Wheel{Circle{Point{1, 1}, 1}, 1}	fmt.Println(w)
</code></pre>
<h3 id="17-面向对象-method">1.7 面向对象 -method</h3>
<p><code>func (recv ReceiverType) methName(parameters)(results)</code></p>
<p>可认为是特殊类型的函数 recv.Method()</p>
<pre><code class="language-go">package mainimport &quot;fmt&quot;//&quot;github.com/sqs/goreturns/returns&quot;//	&quot;time&quot;type TwoInts struct {	a, b int}func (tn *TwoInts) AddThem() int {	return tn.a + tn.b}func (tn *TwoInts) AddtoParam(param int) int {	return tn.a + tn.b + param}/*以上需在main之外声明 */func main() {	two1 := new(TwoInts)	two1.a, two1.b = 12, 10	fmt.Printf(&quot;sum %d\n&quot;, two1.AddThem())	fmt.Printf(&quot;add this to param %d\n&quot;, two1.AddtoParam(20))	two2 := TwoInts{3, 4}	fmt.Printf(&quot;sum %d\n&quot;, two2.AddThem())}
</code></pre>
<ul>
<li>函数&amp;方法比较：
<ul>
<li>函数参数为变量 <code>fuc(recv)</code> 方法在变量上被调用 <code>recv.emthod()</code></li>
<li>接受者为指针时 方法可以改值 函数引用调用亦可</li>
<li>接受者必须有显式名称 名称必须被调用 receivertype 必须在方法相同的包内被声明</li>
</ul>
</li>
</ul>
<h3 id="18-接口-interface">1.8 接口 interface</h3>
<ul>
<li>利于代码与特定实现分离</li>
</ul>
<h3 id="19-go-module">1.9 go module</h3>
<p>go弃用了gopath模式 转向gomodule</p>
<p>Go mod 常用命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>go mod init</td>
<td>生成 go.mod 文件</td>
</tr>
<tr>
<td>go mod download</td>
<td>下载 go.mod 文件中指明的所有依赖</td>
</tr>
<tr>
<td>go mod tidy</td>
<td>整理现有的依赖</td>
</tr>
<tr>
<td>go mod graph</td>
<td>查看现有的依赖结构</td>
</tr>
<tr>
<td>go mod edit</td>
<td>编辑 go.mod 文件</td>
</tr>
<tr>
<td>go mod vendor</td>
<td>导出项目所有的依赖到vendor目录</td>
</tr>
<tr>
<td>go mod verify</td>
<td>校验一个模块是否被篡改过</td>
</tr>
<tr>
<td>go mod why</td>
<td>查看为什么需要依赖某模块</td>
</tr>
</tbody>
</table>
<p>终端查看:</p>
<p><code>go env</code> 查看go相关环境变量</p>
<p><code>go env -w</code> 修改 +对应</p>
<p>开关 go env -w GO111MODULE=on</p>
<h4 id="初始化项目">初始化项目</h4>
<p>在完成 Go modules 的开启后，我们需要创建一个示例项目来进行演示，执行如下命令：</p>
<pre><code>$ mkdir -p $HOME/eddycjy/module-repo $ cd $HOME/eddycjy/module-repo
</code></pre>
<p>然后进行Go modules的初始化，如下：</p>
<pre><code>$ go mod init github.com/eddycjy/module-repogo: creating new go.mod: module github.com/eddycjy/module-repo
</code></pre>
<p>在执行 <code>go mod init</code> 命令时，我们指定了模块导入路径为 <code>github.com/eddycjy/module-repo</code>。接下来我们在该项目根目录下创建 main.go 文件，如下：</p>
<pre><code>package mainimport (    &quot;fmt&quot;    &quot;github.com/eddycjy/mquote&quot;)func main() {	fmt.Println(mquote.GetHello())}
</code></pre>
<p>然后在项目根目录执行 <code>go get github.com/eddycjy/mquote</code> 命令，如下：</p>
<pre><code>$ go get github.com/eddycjy/mquote go: finding github.com/eddycjy/mquote latestgo: downloading github.com/eddycjy/mquote v0.0.0-20200220041913-e066a990ce6fgo: extracting github.com/eddycjy/mquote v0.0.0-20200220041913-e066a990ce6f
</code></pre>
<h4 id="查看gomod-文件">查看go.mod 文件</h4>
<p>在初始化项目时，会生成一个 go.mod 文件，是启用了 Go modules 项目所必须的最重要的标识，同时也是GO111MODULE 值为 auto 时的识别标识，它描述了当前项目（也就是当前模块）的元信息，每一行都以一个动词开头。</p>
<p>在我们刚刚进行了初始化和简单拉取后，我们再次查看go.mod文件，基本内容如下：</p>
<pre><code>module github.com/eddycjy/module-repogo 1.15.2require (	github.com/eddycjy/mquote v0.0.0-20200220041913-e066a990ce6f)
</code></pre>
<p>为了更进一步的讲解，我们模拟引用如下：</p>
<pre><code>module github.com/eddycjy/module-repogo 1.15.2require (    example.com/apple v0.1.2    example.com/banana v1.2.3    example.com/banana/v2 v2.3.4    example.com/pear // indirect    example.com/strawberry // incompatible)exclude example.com/banana v1.2.4replace example.com/apple v0.1.2 =&gt; example.com/fried v0.1.0 replace example.com/banana =&gt; example.com/fish
</code></pre>
<ul>
<li>module：用于定义当前项目的模块路径。</li>
<li>go：用于标识当前模块的 Go 语言版本，值为初始化模块时的版本，目前来看还只是个标识作用。</li>
<li>require：用于设置一个特定的模块版本。</li>
<li>exclude：用于从使用中排除一个特定的模块版本。</li>
<li>replace：用于将一个模块版本替换为另外一个模块版本。</li>
</ul>
<p>另外你会发现 <code>example.com/pear</code> 的后面会有一个 indirect 标识，indirect 标识表示该模块为间接依赖，也就是在当前应用程序中的 import 语句中，并没有发现这个模块的明确引用，有可能是你先手动 <code>go get</code> 拉取下来的，也有可能是你所依赖的模块所依赖的，情况有好几种。</p>
<h4 id="查看gosum文件">查看go.sum文件</h4>
<p>在第一次拉取模块依赖后，会发现多出了一个 go.sum 文件，其详细罗列了当前项目直接或间接依赖的所有模块版本，并写明了那些模块版本的 SHA-256 哈希值以备 Go 在今后的操作中保证项目所依赖的那些模块版本不会被篡改。</p>
<pre><code>github.com/eddycjy/mquote v0.0.1 h1:4QHXKo7J8a6J/k8UA6CiHhswJQs0sm2foAQQUq8GFHM=github.com/eddycjy/mquote v0.0.1/go.mod h1:ZtlkDs7Mriynl7wsDQ4cU23okEtVYqHwl7F1eDh4qPg=github.com/eddycjy/mquote/module/tour v0.0.1 h1:cc+pgV0LnR8Fhou0zNHughT7IbSnLvfUZ+X3fvshrv8=github.com/eddycjy/mquote/module/tour v0.0.1/go.mod h1:8uL1FOiQJZ4/1hzqQ5mv4Sm7nJcwYu41F3nZmkiWx5I=...
</code></pre>
<p>我们可以看到一个模块路径可能有如下两种：</p>
<pre><code>github.com/eddycjy/mquote v0.0.1 h1:4QHXKo7J8a6J/k8UA6CiHhswJQs0sm2foAQQUq8GFHM=github.com/eddycjy/mquote v0.0.1/go.mod h1:ZtlkDs7Mriynl7wsDQ4cU23okEtVYqHwl7F1eDh4qPg=
</code></pre>
<p>h1 hash 是 Go modules 将目标模块版本的 zip 文件开包后，针对所有包内文件依次进行 hash，然后再把它们的 hash 结果按照固定格式和算法组成总的 hash 值。</p>
<p>而 h1 hash 和 go.mod hash 两者，要不就是同时存在，要不就是只存在 go.mod hash。那什么情况下会不存在 h1 hash 呢，就是当 Go 认为肯定用不到某个模块版本的时候就会省略它的 h1 hash，就会出现不存在 h1 hash，只存在 go.mod hash 的情况。</p>
<h4 id="查看全局缓存">查看全局缓存</h4>
<p>我们刚刚成功的将 <code>github.com/eddycjy/mquote</code> 模块拉取了下来，其拉取的结果缓存在 <code>$GOPATH/pkg/mod</code>和 <code>$GOPATH/pkg/sumdb</code> 目录下，而在<code>mod</code>目录下会以 <code>github.com/foo/bar</code> 的格式进行存放，如下：</p>
<pre><code>mod├── cache├── github.com├── golang.org├── google.golang.org├── gopkg.in...
</code></pre>
<p>需要注意的是同一个模块版本的数据只缓存一份，所有其它模块共享使用。如果你希望清理所有已缓存的模块版本数据，可以执行 <code>go clean -modcache</code> 命令。</p>
<h3 id="110-error接口">1.10 error接口</h3>
<p>error为预定义的类型 interface</p>
<pre><code class="language-go">type error interface {    Error() string}
</code></pre>
<p>调用errors.new函数即可利用传入的错误信息返回新的error</p>
<p>整个errors包仅只有4行：</p>
<pre><code class="language-go">package errorsfunc New(text string) error { return &amp;errorString{text} }type errorString struct { text string }func (e *errorString) Error() string { return e.text }
</code></pre>
<p>承载errorString的类型是一个结构体</p>
<pre><code class="language-go">package syscalltype Errno uintptr // operating system error codevar errors = [...]string{    1:   &quot;operation not permitted&quot;,   // EPERM    2:   &quot;no such file or directory&quot;, // ENOENT    3:   &quot;no such process&quot;,           // ESRCH    // ...}func (e Errno) Error() string {    if 0 &lt;= int(e) &amp;&amp; int(e) &lt; len(errors) {        return errors[e]    }    return fmt.Sprintf(&quot;errno %d&quot;, e)}
</code></pre>
<h3 id="111-reflect">1.11 reflect</h3>
<p>反射是由 reflect 包提供的。它定义了两个重要的类型，Type 和 Value。一个 Type 表示一个Go类型。它是一个接口，有许多方法来区分类型以及检查它们的组成部分，例如一个结构体的成员或一个函数的参数等。唯一能反映 reflect.Type 实现的是接口的类型描述信息（§7.5），也正是这个实体标识了接口值的动态类型。</p>
<p>函数 reflect.TypeOf 接受任意的 interface{} 类型，并以 reflect.Type 形式返回其动态类型：</p>
<pre><code class="language-Go">t := reflect.TypeOf(3)  // a reflect.Typefmt.Println(t.String()) // &quot;int&quot;fmt.Println(t)          // &quot;int&quot;
</code></pre>
<p>其中 TypeOf(3) 调用将值 3 传给 interface{} 参数。回到 7.5节 的将一个具体的值转为接口类型会有一个隐式的接口转换操作，它会创建一个包含两个信息的接口值：操作数的动态类型（这里是 int）和它的动态的值（这里是 3）。</p>
<p>因为 reflect.TypeOf 返回的是一个动态类型的接口值，它总是返回具体的类型。因此，下面的代码将打印 &quot;*os.File&quot; 而不是 &quot;io.Writer&quot;。稍后，我们将看到能够表达接口类型的 reflect.Type。</p>
<pre><code class="language-Go">var w io.Writer = os.Stdoutfmt.Println(reflect.TypeOf(w)) // &quot;*os.File&quot;
</code></pre>
<p>要注意的是 reflect.Type 接口是满足 fmt.Stringer 接口的。因为打印一个接口的动态类型对于调试和日志是有帮助的， fmt.Printf 提供了一个缩写 %T 参数，内部使用 reflect.TypeOf 来输出：</p>
<pre><code class="language-Go">fmt.Printf(&quot;%T\n&quot;, 3) // &quot;int&quot;
</code></pre>
<p>reflect 包中另一个重要的类型是 Value。一个 reflect.Value 可以装载任意类型的值。函数 reflect.ValueOf 接受任意的 interface{} 类型，并返回一个装载着其动态值的 reflect.Value。和 reflect.TypeOf 类似，reflect.ValueOf 返回的结果也是具体的类型，但是 reflect.Value 也可以持有一个接口值。</p>
<pre><code class="language-Go">v := reflect.ValueOf(3) // a reflect.Valuefmt.Println(v)          // &quot;3&quot;fmt.Printf(&quot;%v\n&quot;, v)   // &quot;3&quot;fmt.Println(v.String()) // NOTE: &quot;&lt;int Value&gt;&quot;
</code></pre>
<p>和 reflect.Type 类似，reflect.Value 也满足 fmt.Stringer 接口，但是除非 Value 持有的是字符串，否则 String 方法只返回其类型。而使用 fmt 包的 %v 标志参数会对 reflect.Values 特殊处理。</p>
<p>对 Value 调用 Type 方法将返回具体类型所对应的 reflect.Type：</p>
<pre><code class="language-Go">t := v.Type()           // a reflect.Typefmt.Println(t.String()) // &quot;int&quot;
</code></pre>
<p>reflect.ValueOf 的逆操作是 reflect.Value.Interface 方法。它返回一个 interface{} 类型，装载着与 reflect.Value 相同的具体值：</p>
<pre><code class="language-Go">v := reflect.ValueOf(3) // a reflect.Valuex := v.Interface()      // an interface{}i := x.(int)            // an intfmt.Printf(&quot;%d\n&quot;, i)   // &quot;3&quot;
</code></pre>
<p>reflect.Value 和 interface{} 都能装载任意的值。所不同的是，一个空的接口隐藏了值内部的表示方式和所有方法，因此只有我们知道具体的动态类型才能使用类型断言来访问内部的值（就像上面那样），内部值我们没法访问。相比之下，一个 Value 则有很多方法来检查其内容，无论它的具体类型是什么。让我们再次尝试实现我们的格式化函数 format.Any。</p>
<p>我们使用 reflect.Value 的 Kind 方法来替代之前的类型 switch。虽然还是有无穷多的类型，但是它们的 kinds 类型却是有限的：Bool、String 和 所有数字类型的基础类型；Array 和 Struct 对应的聚合类型；Chan、Func、Ptr、Slice 和 Map 对应的引用类型；interface 类型；还有表示空值的 Invalid 类型。（空的 reflect.Value 的 kind 即为 Invalid。）</p>
<pre><code class="language-Go">package formatimport (    &quot;reflect&quot;    &quot;strconv&quot;)// Any formats any value as a string.func Any(value interface{}) string {    return formatAtom(reflect.ValueOf(value))}// formatAtom formats a value without inspecting its internal structure.func formatAtom(v reflect.Value) string {    switch v.Kind() {    case reflect.Invalid:        return &quot;invalid&quot;    case reflect.Int, reflect.Int8, reflect.Int16,        reflect.Int32, reflect.Int64:        return strconv.FormatInt(v.Int(), 10)    case reflect.Uint, reflect.Uint8, reflect.Uint16,        reflect.Uint32, reflect.Uint64, reflect.Uintptr:        return strconv.FormatUint(v.Uint(), 10)    // ...floating-point and complex cases omitted for brevity...    case reflect.Bool:        return strconv.FormatBool(v.Bool())    case reflect.String:        return strconv.Quote(v.String())    case reflect.Chan, reflect.Func, reflect.Ptr, reflect.Slice, reflect.Map:        return v.Type().String() + &quot; 0x&quot; +            strconv.FormatUint(uint64(v.Pointer()), 16)    default: // reflect.Array, reflect.Struct, reflect.Interface        return v.Type().String() + &quot; value&quot;    }}
</code></pre>
<p>到目前为止，我们的函数将每个值视作一个不可分割没有内部结构的物品，因此它叫 formatAtom。对于聚合类型（结构体和数组）和接口，只是打印值的类型，对于引用类型（channels、functions、pointers、slices 和 maps），打印类型和十六进制的引用地址。虽然还不够理想，但是依然是一个重大的进步，并且 Kind 只关心底层表示，format.Any 也支持具名类型。例如：</p>
<pre><code class="language-Go">var x int64 = 1var d time.Duration = 1 * time.Nanosecondfmt.Println(format.Any(x))                  // &quot;1&quot;fmt.Println(format.Any(d))                  // &quot;1&quot;fmt.Println(format.Any([]int64{x}))         // &quot;[]int64 0x8202b87b0&quot;fmt.Println(format.Any([]time.Duration{d})) // &quot;[]time.Duration 0x8202b87e0&quot;
</code></pre>
<h3 id="112单元测试">1.12单元测试</h3>
<p><code>go test</code> 使用该命令时以 <code>_test.go</code>后缀的源文件在<code>gobuild</code>时不会成为包的一部分</p>
<p>遍历所有 <code>*_test.go</code>的文件</p>
<p><strong>测试函数</strong></p>
<p><code>func TestName (t *testing.T){}</code></p>
<p>必须以Test开头 后缀名可选且必须大写字母</p>
<p><code>e.g. func TestSin(t *testing.T){}</code> t参数用于报告测试失败和附加日志</p>
<pre><code class="language-go">
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[# idea 单元测试]]></title>
        <id>https://flyingchase.github.io/post/idea-dan-yuan-ce-shi/</id>
        <link href="https://flyingchase.github.io/post/idea-dan-yuan-ce-shi/">
        </link>
        <updated>2021-08-30T07:04:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="安装插件">安装插件</h2>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/ovrMKQ.png" alt="ovrMKQ" loading="lazy"></figure>
<h2 id="配置-test-目录">配置 test 目录</h2>
<ul>
<li>
<p>在 src 同级生成 test 目录</p>
</li>
<li>
<p>右键 test 目录设为 test resourceroot</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/JQtpJv.png" alt="JQtpJv" loading="lazy"></figure>
</li>
</ul>
<h2 id="生成测试类">生成测试类</h2>
<ul>
<li>
<p>在待测试的类或者方法上使用快捷键 <code>cmd+shift+t</code></p>
</li>
<li>
<p>选择 Junit5 + 待测方法名</p>
</li>
<li>
<p>自动上设置的test 目录新建对应 package 下的测试类</p>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/t4PxEI.png" alt="t4PxEI" loading="lazy"></figure>
</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/Cf7oFg.png" alt="Cf7oFg" loading="lazy"></figure>
<h2 id="编写测试代码">编写测试代码</h2>
<ul>
<li>使用 new 创建原先的代码类并传入方法</li>
<li>使用<code>assertEquals</code>等进行测试</li>
</ul>
]]></content>
    </entry>
</feed>