<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://flyingchase.github.io</id>
    <title>flyingchase</title>
    <updated>2021-08-01T13:38:02.248Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://flyingchase.github.io"/>
    <link rel="self" href="https://flyingchase.github.io/atom.xml"/>
    <subtitle>记录成长的脚印</subtitle>
    <logo>https://flyingchase.github.io/images/avatar.png</logo>
    <icon>https://flyingchase.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, flyingchase</rights>
    <entry>
        <title type="html"><![CDATA[二叉树的非递归遍历算法]]></title>
        <id>https://flyingchase.github.io/post/er-cha-shu-de-fei-di-gui-bian-li-suan-fa/</id>
        <link href="https://flyingchase.github.io/post/er-cha-shu-de-fei-di-gui-bian-li-suan-fa/">
        </link>
        <updated>2021-07-02T10:13:16.000Z</updated>
        <content type="html"><![CDATA[<h2 id="非递归遍历二叉树">非递归遍历二叉树</h2>
<hr>
<p>递归本质上就是栈 由于二叉树提供节点只能向下访问 无法返回 故而使用栈结构实现返回</p>
<pre><code class="language-java">public static List&lt;Integer&gt; inOrderTraversalBT(TreeNode root) {
    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
    //空树则直接返回null的res
    if (root == null) {
        return res;
    }
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
    // 保存root
    TreeNode cur = root;
    while (cur != null || !stack.isEmpty()) {
        // 向树的最左侧走 并不断压栈
        while (cur != null) {
            stack.push(cur);
            cur = cur.left;
        }
        // 走完最左侧后弹栈顶
        TreeNode node = stack.pop();
        res.add(node.val);
        // 往上层的右边去再重复找最左侧
        cur = node.right;
    }
    return res;
}


public static List&lt;Integer&gt; preOrderTraversalBT(TreeNode root) {
    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
    //空树则直接返回null的res
    if (root == null) {
        return res;
    }
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
    // 保存root
    TreeNode cur = root;
    while (cur != null || !stack.isEmpty()) {
        // 向树的最左侧走 并不断压栈入数组
        while (cur != null) {
            res.add(cur.val);
            stack.push(cur);
            cur = cur.left;
        }
        // 走完最左侧后弹栈顶 无须入组 cur循环内已经入组
        TreeNode node = stack.pop();
        // 往上层的右边去 再重复找最左侧
        cur = node.right;
    }

    return res;
}


public static List&lt;Integer&gt; postOrderTraversalBT(TreeNode root) {
    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
    //空树则直接返回null的res
    if (root == null) {
        return res;
    }
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
    // 保存root
    TreeNode cur = root;
    while (cur != null || !stack.isEmpty()) {
        // 向树的最右侧走 并不断压栈入数组
        while (cur != null) {
            res.add(cur.val);
            stack.push(cur);
            cur = cur.right; // 使得reverse后正常左在前
        }
        // 走完最右侧后弹栈顶 无须入组 cur循环内已经入组
        TreeNode node = stack.pop();
        // 往上层的左边去 再重复找最右侧
        cur=node.left;
    }
    Collections.reverse(res);
    return res;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git常见问题汇总]]></title>
        <id>https://flyingchase.github.io/post/git-chang-jian-wen-ti-hui-zong/</id>
        <link href="https://flyingchase.github.io/post/git-chang-jian-wen-ti-hui-zong/">
        </link>
        <updated>2021-06-28T06:08:25.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>整理收集于互联网</p>
</blockquote>
<h3 id="1修改提交信息">1.修改提交信息</h3>
<p>重写<code>commit</code></p>
<pre><code class="language-shell">git commit --amend -m &quot;new message&quot;
</code></pre>
<h3 id="2添加文件到最后一次提交">2.添加文件到最后一次提交</h3>
<p><code>git push</code> 后新增文件到最后一次提交</p>
<pre><code class="language-shell">git add &lt;file_name&gt;git commit --amend HEAD~1
</code></pre>
<h3 id="3撤消提交">3.撤消提交</h3>
<p>如果要撤消最近一次提交但保留更改，可执行以下操作：</p>
<pre><code class="language-shell">git reset --soft HEAD~1
</code></pre>
<p>如果要撤消提交和更改，可执行以下操作：——&gt;丢弃更改</p>
<pre><code class="language-shell">git reset --hard HEAD~1
</code></pre>
<p>如果要撤消所有的本地更改，则可以重置为分支的原始版本：</p>
<pre><code class="language-shell">git reset --hard origin/&lt;branch_name&gt;
</code></pre>
<p>如果要撤消提交而不修改现有历史记录，则可以使用 git revert，此命令通过创建新的提交来撤消提交。</p>
<pre><code class="language-shell">git revert HEAD
</code></pre>
<p>撤消已经推送到远程分支的合并提交的安全方法是使用 git revert 命令：</p>
<pre><code class="language-shell">git revert -m 1 &lt;commit_id&gt;
</code></pre>
<p>commit_id 是要还原的合并提交 id。</p>
<p>注意要点：</p>
<ol>
<li>可以撤消任意数量的提交。例如：<code>git reset HEAD~3</code>（返回 HEAD 之前的 3 个提交)；<code>git reset --hard &lt;commit_id&gt;</code>（返回特定的提交）。</li>
<li>如果尚未推送提交，并且你不想引入糟糕的提交到远程分支，可以使用 git reset。</li>
<li>使用 git revert 还原已经推送到远程分支的合并提交。</li>
<li>使用 git log 查看提交历史。</li>
</ol>
<pre><code class="language-bash"># 删除 untracked files 
git clean -f
 
# 连 untracked 的目录也一起删掉
git clean -fd
 
# 连 gitignore 的untrack 文件/目录也一起删掉 （慎用，一般这个是用来删掉编译出来的 .o之类的文件用的）
git clean -xfd
 
# 在用上述 git clean 前，墙裂建议加上 -n 参数来先看看会删掉哪些文件，防止重要文件被误删
git clean -nxfd
git clean -nf
git clean -nfd
</code></pre>
<h3 id="4-git命令显示中文路径">4. Git命令显示中文路径</h3>
<pre><code class="language-shell">git config --global core.quotePath false
</code></pre>
<h3 id="5-指定文件的历史修改记录">5. 指定文件的历史修改记录</h3>
<pre><code class="language-shell">git log --follow -p 文件名
</code></pre>
<h3 id="6-指定提交的修改记录">6. 指定提交的修改记录</h3>
<pre><code class="language-shell"># 查看commit提交修改的文件git show --stat &lt;commit的代号&gt;#查看commit提交修改的文件及内容git show &lt;commit的代号&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java-集合]]></title>
        <id>https://flyingchase.github.io/post/java-ji-he/</id>
        <link href="https://flyingchase.github.io/post/java-ji-he/">
        </link>
        <updated>2021-06-02T09:08:51.000Z</updated>
        <content type="html"><![CDATA[<h2 id="13-类集合框架">13 类集合框架</h2>
<hr>
<p>Collection定义的方法:</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/NpsW79.png" alt="NpsW79" loading="lazy"></figure>
<p>单列集合+双列集合</p>
<p>Collection接口有两个子接口 list Set实现的子类均为单列集合 Map接口实现的子类为双列结合(K_V )</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/Whzxbx.png" alt="Whzxbx" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/vkXtxV.png" alt="vkXtxV" loading="lazy"></figure>
<h3 id="1301-collection接口">13.01 Collection接口</h3>
<ul>
<li>
<p>常用方法</p>
<ul>
<li>add/addAll</li>
<li>remove/clear/removeAll</li>
<li>contains/containsAll</li>
<li>size</li>
<li>isEmpty</li>
</ul>
</li>
<li>
<p>遍历:</p>
<ul>
<li>
<p>迭代器——&gt;Iterator对象; 所有实现Collection接口均实现</p>
<img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/2021-05-13 15.42.43.gif" alt="2021-05-1315.42.43" style="zoom:150%;" />
</li>
</ul>
</li>
</ul>
<h3 id="1302-list接口">13.02 List接口</h3>
<p><code>List特点:</code></p>
<ul>
<li>元素有序(添加和取出顺序 ) 可重复</li>
<li>支持索引 从0开始</li>
</ul>
<p>实现List接口有: <code>ArrayList LinkedList Vector Stack etc.</code></p>
<p><code>List接口常用方法:</code> 常见8种</p>
<pre><code class="language-java">// index位置插ele List长度自动+1
void add(int index, Object ele);
//index位置开始将eles中所有元素加入
boolean addAll(int index, Collection eles);
// 获取index位置元素
Object get(int index);
// 返回object在集合中首次出现位置
int indexOf(Object obj);
// 返回obj在集合中末次出现位置
int lastIndexOf(Object obj);
// 移除index位置元素并返回该元素
Object remove(int index);
// 替换index位置元素为ele——&gt;也可用于交换

Object set(int index, Object ele);
// 返回从fromIndex到toIndex位置的子集合 前闭后开[forIndex,toIndex)
List subList(int formIndex, int toIndex);

</code></pre>
<p><code>set</code>可用于交换 注意先后访问的顺序</p>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/KGeM3K.png" alt="KGeM3K" loading="lazy"></figure>
<p><code>List常见遍历方式:</code></p>
<pre><code class="language-java">// 迭代器遍历
Iterator ite = collection.iterator();
while(ite.hasNext()) {
    Object next - ite.next();
}

// foreach遍历
for(Object o : Collection) {
    
}

// 普通fori
        for (int i = 0; i &lt; Collection.size(); i++) {
            Object o = Collection.get(i);
        }
</code></pre>
<h4 id="arraylist注意事项️">ArrayList注意事项⚠️</h4>
<ul>
<li>
<p>可以加入多个null</p>
</li>
<li>
<p>是由数组底层实现</p>
</li>
<li>
<p>线程不安全——&gt;没有<code>synchronized</code> 可以等同于Vector (线程安全)</p>
</li>
</ul>
<p><em>底层源码阅读</em>  注意IDEA默认debug不显示null的扩容内容</p>
<ul>
<li>
<p>维护<code>Object</code>类型数组 <code>elecmentData</code></p>
<ul>
<li><code>transient object[] elementData</code> 表示为瞬时 该属性不会被序列化</li>
</ul>
</li>
<li>
<p>创建<code>ArrayList</code>对象时:</p>
<ul>
<li>无参构造器——&gt;初始化的elementData容量为0, 第一次添加扩容elementData为10, 再次扩容则为1.5倍(0_10_15_22)</li>
<li>ArrayList(int) 指定大小的构造器——&gt;elementData容量为制定大小,扩容则直接扩为1.5倍</li>
</ul>
<p><strong>扩容:</strong></p>
<pre><code class="language-java">// 右移一位 ——&gt; /2int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);// 使用Arrays.copyOf(nums,length)来对底层数组elementData扩容return elementData = Arrays.copyOf(elementData, newCapacity);// Arrays.copyOf()超出nums的len范围用null来填充
</code></pre>
<p><code>无参构造器:</code><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/HXRDVH.png" alt="HXRDVH" loading="lazy"></p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/tIEh4x.png" alt="tIEh4x" style="zoom: 50%;" />
<img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/kBrKAj.png" alt="kBrKAj" style="zoom:150%;" />
<p><code>ArraysSupport.newLength</code>方法用于获取newCapacity</p>
<img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/Mh3IOH.png" alt="Mh3IOH" style="zoom:50%;" />
<h4 id="vector底层结构源码剖析"><code>Vector</code>底层结构&amp;源码剖析</h4>
<ul>
<li>
<p>底层同样是对象数组 <code>protected Object[] elementData</code></p>
</li>
<li>
<p>线程同步安全 操作方法带有<code>synchronized</code></p>
<p><strong>无参构造:</strong> 默认10initalCapacity 再按照2倍扩容</p>
<p><strong>指定大小:</strong> 每次2倍扩容</p>
</li>
</ul>
<h4 id="linkedlist源码和结构"><code>LinkedList</code>源码和结构</h4>
<img src="/Users/qlzhou/Library/Application Support/typora-user-images/image-20210514171051143.png" alt="image-20210514171051143" style="zoom:50%;" />
<ul>
<li>底层双向链表、队列——&gt;插入、删除效率高
<ul>
<li>维护两个属性first last 分别指向首尾结点</li>
<li>每个节点Node维护prev next item三个属性</li>
<li>双向链表的插入——&gt; waitInsert.next=prevNode; waitInsert.pre=nextNode; prevNode.next=waitInsert; nextNode.pre=waitInsert;</li>
</ul>
</li>
<li>元素任意(可以重复)  包括null</li>
<li>线程不安全 没有实现同步</li>
</ul>
<p><strong><code>LinkedListCRUD</code></strong></p>
<p>​	linkedList.add(item)——&gt;使用linkLast(e)函数(将添加的节点挂入原链表的最后)</p>
<img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/NJEbDZ.png" alt="NJEbDZ" style="zoom:50%;" />
<p><em><code>Explain To linkLast(E e)</code></em></p>
<p>初始last=null——&gt;第一个节点时 first last newNode均指向节点newNode——&gt;再插入则 l=last last=newNode 将newNode的prev指向l 即原先的last(上一个节点位置) 同时将last指向newNode 设为双向链表的尾指针——&gt;l!=null 再将上一个节点的next指针指向newNode 同时更新size/modCount 完成两个节点之间的链接</p>
<p>linkedList.remove(int index)——&gt;首先使用node(index)函数找到index下标的结点并返回该节点——&gt;调用unlink(Node<E> x) 函数删除该节点并返回item值</p>
<img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/C2JGW8.png" alt="C2JGW8" style="zoom:50%;" />
<p><em><code>Explain To node(index)</code></em></p>
<p>判断下标index在整个链表的前部还是后部——&gt;⚠️后部<code>i=size-1;i&gt;index;i--</code> 判断</p>
<img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/DdBI3S.png" alt="DdBI3S" style="zoom:50%;" />
<p>​	<em><code>Explain To unlink(Node&lt;E&gt; x)</code></em></p>
<p>暂存待删结点x的前后结点</p>
<p>prev next——&gt;移动x的前一结点的next指向x的下一结点<code>prev.next=next</code>   移动x的下一结点的prev指向x的上一结点<code>next.prev=prev</code> ——&gt;同时将x的prev和next均置空(help GC) ——&gt;最后item置空并链表size-1</p>
<h5 id="arraylist-linkedlist-compare">ArrayList &amp;&amp; LinkedList Compare</h5>
<p>ArrayList——&gt;增查</p>
<p>LinkedList——删改</p>
<p>均为线程不安全</p>
<h3 id="1303-set">13.03 <code>Set</code></h3>
<p><code>Feature:</code></p>
<ul>
<li>无序（添加与取出的顺序不一致） 没有 index 索引
<ul>
<li>取出的顺序一次设定即被固定</li>
</ul>
</li>
<li>无重复元素——&gt;最多包含一个 null 多个重复数字后者不会被添加</li>
<li><code>set</code>接口实现的类：<code>HashSet、TreeSet、LinkedHashSet、etc.</code></li>
</ul>
<p><code>Mathods:</code></p>
<ul>
<li>是 Collection 的子接口——&gt;常用方法一致</li>
<li>遍历：迭代器 foeeach 不可 index 索引</li>
</ul>
<h4 id="hashset"><code>HashSet</code></h4>
<p><code>instructions:</code></p>
<ul>
<li>
<p>实现 Set 接口</p>
</li>
<li>
<p>本质上是<code>HashMap</code> <img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/DBF5F0.png" alt="DBF5F0" style="zoom:50%;" />——<code>HashMap</code>底层是数组+链表+红黑树</p>
<ul>
<li>在数组的某个index 位置存储链表（数据存储的高效）</li>
<li>index 上存储的链表长度&gt;8（TreeIfy_Threshold）并且数组长度&gt;64(Min_TreeIfy_Capacity) ————&gt;转化为树</li>
</ul>
</li>
<li>
<p>可存放 null 但仅可有一个 元素不可重复</p>
<ul>
<li>注意元素重复与否与 JVM 内存相关——&gt;常量池、栈内存</li>
<li>toString 没有重写则输出为引用的地址 重写则为内容</li>
<li>new String(“**”)——&gt;先在常量池中查找有没有已经存在的 str</li>
</ul>
</li>
<li>
<p>不保证元素有序，取决于 Hash 后在确定索引</p>
</li>
</ul>
<h5 id="hashset-add-method"><code>HashSet add Method</code></h5>
<ul>
<li>添加元素时——&gt;得到元素的 hash 值再转化——&gt;索引值(存储位置)</li>
<li>存储数据表 tables——&gt;是否已经存放（没有直接加入、有则下步比较 ）</li>
<li>有调用 equal 比较——&gt;不相同再加入到最后</li>
</ul>
<p>hash 值计算<img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/2b37hf.png" alt="2b37hf" style="zoom:50%;" /></p>
<p>第一次 add</p>
<p>依据 hash 计算出的 key 应该存档于 table 的位置，并赋值给辅助变量 p(p 指向索引的结点)</p>
<p>再判断 p 是否为空——&gt;空（对应的插入位置无元素）则将 key新建 Node 并存入 tab[i] （hash key value=present next）——&gt;判断 size 与 threshold(0.75*16)  扩容与否  再返回 null 则表示插入成功</p>
<p>add 所插入的位置非空——&gt;</p>
<p><code>p.hash==hash &amp;&amp; ((k=p.key)==key)||(key!=null&amp;&amp;key.equals(k))</code> hash value equals 三重比较确保两者不相同</p>
<p>返回 oldValue 非空则插入式失败</p>
<img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/Jzejjh.png" alt="Jzejjh" style="zoom:150%;" />
<h5 id="hashset-扩容机制"><code>HashSet 扩容机制</code></h5>
<ol>
<li>
<p>底层<code>HashMap</code> 第一次添加时 <code>table 数组</code>扩容到 16，阈值<code>threshold</code>为 16*0.75加载因子（<code>loadFactor</code>）=12</p>
</li>
<li>
<p><code>table 数组</code>扩容为* 2=32 新的临界值(<code>threshold</code>)为 0.75*32=24</p>
<p>扩容是使用左移&lt;&lt;1实现 * 2</p>
</li>
<li>
<p>链表元素个数达到<code>TreeIfy_Threshold(8)</code>且 table 数组大小&gt;=<code>Min_Treeify_Capacity</code> 则转化为红黑树，否则仍然是扩容数组</p>
</li>
</ol>
<p>​	使用重写 class 的 hashcode 方法 返回同一个 hashcode 使得插入在 map 的同一个数组 index 上的链表内 链表长度超过 8 后会使  table 扩容 &lt;&lt;1 表长+1  扩容为 32表长再+1 到 10  再扩容 64  若在添加元素则树化  treeifyBin 方法</p>
<img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/29NvGo.png" alt="29NvGo" style="zoom:50%;" />
<p>​	直到走到链表末尾进行且 binCount&gt;=8-1=7(从 0 开始)则调用<code>treeifyBin</code>方法树化 传入 table 和 hash 参数</p>
<img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/B2ojcy.png" alt="B2ojcy" style="zoom:50%;" />
<p><code>Min_TreeIfy_Capacity=64</code></p>
<p><code>tab[index=(n-1)&amp;hash]</code> 找到数组储存数据的位置并将e 指向这个引用</p>
<h4 id="linkedhashset"><code>LinkedHashSet</code></h4>
<blockquote>
<p><code>Features:</code></p>
<ol>
<li>属于 HashSet 的子类；</li>
<li>底层是<code>LinkedHashMap</code>，维护了数组+双向链表；</li>
<li>依据元素的<code>hashcode</code>决定元素的存储位置，同时用链表维护元素的次序（图），使得元素看起来插入顺序保存；</li>
<li>不允许重复元素；</li>
</ol>
</blockquote>
<p><code>Explain</code></p>
<blockquote>
<ol>
<li>维护 hash 表和双向链表（属性有 head 和 tail） 使得每次后续插入的元素连接在最后 有序</li>
<li>每个节点有 prev 和 next 属性 before after</li>
<li>添加元素时，先求 hash值再求索引，从而确定元素在 hashtable 的位置——&gt;再添加进入双向链表</li>
<li>遍历顺序保证与插入顺序一致</li>
</ol>
</blockquote>
<ul>
<li>
<p>底层维护<code>LinkedeHashMap</code>结构 ——&gt;是 <code>HashMap</code> 的子类</p>
</li>
<li>
<p>首次初始化为 16（size）结点类型为<code>LinkedHashMao$Entry</code>——&gt;数组是<code>HashMap$Node[]</code> 存放的元素是<code>LinkedHashMap$Entry</code>  即为多态 继承父类的属性</p>
<figure data-type="image" tabindex="5"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/W58GVZ.png" alt="W58GVZ" loading="lazy"></figure>
</li>
</ul>
<p>要求 hashcode 和 equal 均相同才无法加入，对于非基本数据类型需要重写两个方法 equal 和 hashcode</p>
<h4 id="treeset">TreeSet</h4>
<p>可以排序</p>
<p>使用无参构造器创建<code>TreeSet</code>  无序</p>
<p>有参可以使用<code>Comparator</code> 接口——&gt;传入比较器 匿名内部类</p>
<p>构造器将传入的比较器对象comparator赋给 TreeSet 底层的 TreeMap 的属性 comparator</p>
<pre><code class="language-java">public TreeMap(Comparator&lt;? super K&gt; comparator) {
    this.comparator = comparator;
}


final int compare(Object k1, Object k2) {
    return comparator==null ? ((Comparable&lt;? super K&gt;)k1).compareTo((K)k2)
        : comparator.compare((K)k1, (K)k2);
}
</code></pre>
<p>在 TreeSet 的 add 方法会调用</p>
<pre><code class="language-java">private V put(K key, V value, boolean replaceOld) {
    Entry&lt;K,V&gt; t = root;
    if (t == null) {
        addEntryToEmptyMap(key, value);
        return null;
    }
    int cmp;
    Entry&lt;K,V&gt; parent;
    // split comparator and comparable paths
    Comparator&lt;? super K&gt; cpr = comparator;
    if (cpr != null) {
        do {
            parent = t;
           	// 调用自定的 compare
            cmp = cpr.compare(key, t.key);
            if (cmp &lt; 0)
                t = t.left;
            else if (cmp &gt; 0)
                t = t.right;
            else {
                // 两个值相等时候即返回 oldVaule 无法添加
                V oldValue = t.value;
                if (replaceOld || oldValue == null) {
                    t.value = value;
                }
                return oldValue;
            }
        } while (t != null);
    } else {
        Objects.requireNonNull(key);
        @SuppressWarnings(&quot;unchecked&quot;)
        Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;
        do {
            // 这里的循环逐个比较则一旦出现相应的就 return了 
            // 即==时候无法被加入（==为自定的规则）
            parent = t;
            cmp = k.compareTo(t.key);
            if (cmp &lt; 0)
                t = t.left;
            else if (cmp &gt; 0)
                t = t.right;
            else {
                V oldValue = t.value;
                if (replaceOld || oldValue == null) {
                    t.value = value;
                }
                return oldValue;
            }
        } while (t != null);
    }
    addEntry(key, value, parent, cmp &lt; 0);
    return null;
}
</code></pre>
<h3 id="1304-map">13.04 Map</h3>
<p>该接口子类具有的特点：</p>
<blockquote>
<p>Features:</p>
<ol>
<li>Map 和 collection 并列，用于保存具有映射关系的 Key-value 之间为单项一对一的关系</li>
<li>Key Value 可以是任何引用类型的数据 object，会被封装到 HashMap$Node 内部类，Node 实现Entry 接口，即一对 K-V 就是一个 Entry</li>
<li>使用 EntrySet 内部类，定义的类型是 Entry 实际上存放是 HashMap$Node 因为 Node implement Map.Entry 接口——&gt;接口的多态</li>
<li>EntrySet 方便遍历——&gt;提供了 getKey getValue 方法</li>
<li>Key 可为 null 仅一个但不可重复（），value 可以重复并可为 null</li>
</ol>
</blockquote>
<p>Node——&gt;Entry——&gt;EntrySet</p>
<p>Properties：</p>
<p>​	继承自HashTable 并且适用于 Properties文件类型导入加载数据到 Properities 类对象读取和修改</p>
<p>​	读取配置文件时候常用</p>
<h4 id="集合选择">集合选择</h4>
<ul>
<li>存储类型</li>
<li>单列对象：<code>Collection</code> 接口
<ul>
<li>允许重复：List
<ul>
<li>增删：LinkedList——&gt;底层双向链表</li>
<li>改查：ArrayList——&gt;底层维护 Object 可变数组</li>
</ul>
</li>
<li>不允许重复：Set
<ul>
<li>无序：HashSet——&gt;底层 HashMap 维护哈希表（数组+链表+红黑树）</li>
<li>排序：TreeSet</li>
<li>插入和取出循序一致：LinkedHashSet——&gt;数组+双向链表</li>
</ul>
</li>
</ul>
</li>
<li>双列键值对：Map
<ul>
<li>键无序：HashMap——&gt;哈希表</li>
<li>键排序：TreeMap</li>
<li>键插入和取出顺序一致：LinkedHashMap</li>
<li>读取配置文件：Properties</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mac配置指南]]></title>
        <id>https://flyingchase.github.io/post/mac-pei-zhi-zhi-nan/</id>
        <link href="https://flyingchase.github.io/post/mac-pei-zhi-zhi-nan/">
        </link>
        <updated>2021-05-03T12:26:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>升级Big sur时替换硬盘使用Time Machine只恢复一月前备份,故将配置流程记录</p>
<p>教训:</p>
<ul>
<li>做好多处备份, 机械和固态多个备份, 在升级和较多本地内容变动时加强备份频率;</li>
<li>少折腾多干活, 黑苹果不要追求太完美, 现有的版本能稳定运行即可, 多刷题多学习, 不要花时间过于折腾;</li>
</ul>
<h2 id="系统设置">系统设置</h2>
<h4 id="触控板">触控板</h4>
<p>Bettertouch</p>
<h2 id="开发工具">开发工具</h2>
<h4 id="idea系列">IDEA系列</h4>
<h5 id="自动补全">自动补全</h5>
<p><strong>快速输出</strong></p>
<p>List.sout——&gt;System.out.println(list);</p>
<p><strong>定义局部变量</strong></p>
<p>new ArrayList&lt;&gt;().var;</p>
<p><strong>判断空与否</strong></p>
<p>List.null——&gt;if(List==null)</p>
<p>List.notnull——&gt;if(List!=null)</p>
<p><strong>快速取反:</strong></p>
<p>​	输入 .not 可以让布尔值快速取反，再输入 .if 可快速生成 if 判断语句块。</p>
<p>![2021-05-1311.47.57](https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/2021-05-13 11.47.57.gif)</p>
<p><strong>快速遍历集合:</strong></p>
<p>collection.for/.forr/.fori</p>
<p>![2021-05-1311.51.59](https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/2021-05-13 11.51.59.gif)</p>
<p><strong>快速返回:</strong></p>
<p>Object.return——&gt;return Object;</p>
<h5 id="重构生成">重构/生成</h5>
<p>快速生成类的构造器和get set等常见方法</p>
<p>重写toString/hashCode/equal等常见方法</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/ry6AzG.png" alt="ry6AzG" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux操作命令笔记]]></title>
        <id>https://flyingchase.github.io/post/linux-cao-zuo-ming-ling-bi-ji/</id>
        <link href="https://flyingchase.github.io/post/linux-cao-zuo-ming-ling-bi-ji/">
        </link>
        <updated>2021-05-03T12:25:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="to-do-list"><strong>TO DO LIST</strong></h1>
<ul>
<li>top命令</li>
<li>ps命令</li>
<li>netstat命令</li>
<li>awk命令</li>
<li>find命令</li>
<li>grep命令</li>
<li>wc命令</li>
<li>sed命令</li>
<li>head和tail命令</li>
<li>正则表达式</li>
<li>如何查找出现频率最高的100个IP地址</li>
<li>linux如何统计文件中某个字符串出现的频率</li>
<li>linux启动的第一个进程</li>
<li>linux查看端口占用</li>
<li>linux查看CPU和内存使用</li>
<li>Linux查看系统负载命令</li>
<li>Linux调试程序</li>
<li>Linux硬链接和软连接</li>
<li>core dump</li>
<li>cmake和makefile</li>
<li>Shell脚本基本语法和使用</li>
</ul>
<h1 id="linux网络编程">Linux网络编程</h1>
<ul>
<li>孤儿进程、僵尸进程和守护进程</li>
<li>进程间通信方式signal、file、pipe、shm、sem、msg、socket</li>
<li>线程同步机制线程：互斥量、锁机制、条件变量、信号量、读写锁</li>
<li>fork返回值</li>
<li>五大IO模型：阻塞I/O、非阻塞I/O、I/O复用、信号驱动I/O、异步I/O</li>
<li>IO复用机制</li>
<li>epoll与select/poll</li>
<li>LT水平触发和ET边缘触发</li>
<li>Reactor和Proactor模式</li>
<li>反向代理、负载均衡</li>
</ul>
<h1 id="linux操作指令-笔记">Linux操作指令-笔记</h1>
<h2 id="1-文件权限">1 文件权限</h2>
<h3 id="11-ls命令">1.1 ls命令</h3>
<p>帮助 <code>man ls</code> <code>info ls</code></p>
<p><code>ls -al</code> ——&gt;list all include those hided</p>
<p>e.g:</p>
<p><code>-rwxr-xr-x 1 qlzhou staff 5797544 12 21 15:59 impl</code></p>
<p>第一列10个字符 文件类型和权限</p>
<p>​	1 - 代表文件 d代表文件夹</p>
<p>​	234拥有者权限 rwx 可读可写可执行</p>
<p>​	567 同用户组权限 r-x 可读可执行</p>
<p>​	8910 其他用户权限 r-x 可读可执行</p>
<pre><code>其中r w x顺序不变 不存在该权限则为- 
</code></pre>
<p>第二列 1代表多少文件名连接到此节点i-node</p>
<p>第三列 qlzhou代表所有者账号</p>
<p>第四列 表示文件所属用户组</p>
<p>第五列 文件大小 默认单位B</p>
<p>第六列 修改日期</p>
<p>​	完整时间显示 <code>ls -l --full-time</code></p>
<p>第七列 文件名 隐藏文件前含.</p>
<h3 id="12-文件权限修改">1.2 文件权限修改</h3>
<p>使用cp复制时会保留原有的用户权限 从而他人无法修改</p>
<ul>
<li>
<p>chgrp修改所属用户组</p>
<p>change group简写</p>
<p>-R递归 recursive 持续修改 包括子目录下文件 目录</p>
</li>
<li>
<p>Chown修改文件所有者</p>
<p><code>chown username filename/dirname</code> 可加-R</p>
</li>
<li>
<p>Chmod</p>
</li>
</ul>
<h2 id="man-获得帮助"><strong>man - 获得帮助</strong></h2>
<pre><code class="language-text">man ls        # 许多Linux自带命令可以通过man查看使用帮助
ls --help     # 有些程序可以通过-h, --help查看使用帮助
</code></pre>
<h2 id="ls-显示目录内容"><strong>ls - 显示目录内容</strong></h2>
<pre><code class="language-bash">ls                      # 显示目录内容
ls -l                   # 以列表显示形式显示目录内容，通常在~/.bashrc文件中增加一行：alias ll='ls -l'
                        # 以后就可以直接使用别名ll了，更方便
ll -h                   # 以人类可读的方式显示文件大小
ll -t                   # 以文件的修改时间排序，最新修改的在最前面
ll -tr                  # 以文件的修改时间排序，最新修改的在最后面
watch -n 3 -dc ls -l    # 追踪目录内容的变化，每3秒刷新一次
</code></pre>
<h2 id="pwd-显示当前目录"><strong>pwd - 显示当前目录</strong></h2>
<pre><code class="language-bash">pwd                 # 显示当前目录的绝对路径
ls `pwd`/file       # 显示文件的绝对路径
</code></pre>
<h2 id="cd-切换目录"><strong>cd - 切换目录</strong></h2>
<pre><code class="language-bash">cd dir    # 切换到目录dir
cd        # 切换到用户的HOME目录
cd ~      # 同cd，~表示HOME目录
cd ..     # 切换到上一级目录；一个点.表示当前目录，两个点..表示上一级目录
cd -      # 切换到进入当前目录之前所在的目录
</code></pre>
<h2 id="mkdir-创建目录"><strong>mkdir - 创建目录</strong></h2>
<pre><code class="language-bash">mkdir dir           # 创建dir目录
mkdir -p dir1/dir2  # 递归创建目录，如dir1不存在，会先创建dir1
</code></pre>
<h2 id="cat-合并文件按行"><strong>cat - 合并文件（按行）</strong></h2>
<pre><code class="language-bash">cat file              # 合并一个或多个文件至标准输出，当只有一个文件时，相当于显示所有文件内容
cat file1 file2       # 合并file1和file2的内容，并在屏幕上输出
cat R1.fq.gz R2.fq.gz # 可以合并gzip压缩文件，如测序数据原始reads的合并
</code></pre>
<h2 id="paste-合并文件按列"><strong>paste - 合并文件（按列）</strong></h2>
<pre><code class="language-bash">paste -d ' ' file1 file2    # 按列对列的方式一行一行合并文件。默认列中间加TAB键， -d参数可以改变列之间的分隔符
</code></pre>
<h2 id="split-分割文件"><strong>split - 分割文件</strong></h2>
<pre><code class="language-bash">split -d -l 10000 file chunk_   # 按行数分割文件，每个文件最多10000行，分割成的文件名为chunk_01, chunk_02。。。
split -d -b 100m file chunk_    # 按大小分割文件，每个文件最多100m，分割成的文件名为chunk_01, chunk_02。。。
</code></pre>
<h2 id="cut-剪切文件"><strong>cut - 剪切文件</strong></h2>
<pre><code class="language-bash">cut -f 1 file                   # 剪切文件的第1列
cut -f 1,2                      # 剪切文件的第1，2列
cut -f 3-                       # 剪切第3列及之后的所有列
cut -d ' ' -f 1 file            # 剪切第1列，但以空格作为列与列之间的分隔符。默认以TAB作为分隔符
grep '^&gt;' test.fa | cut -c 2-   # 得到fasta文件中的序列名称（去掉了&gt;符号）
</code></pre>
<h2 id="less-head-tail-显示文件内容"><strong>less, head, tail - 显示文件内容</strong></h2>
<pre><code class="language-bash">less file       # 分屏显示文件内容，按空格键显示下一页，按下/后可以搜索内容
less -SN file   # 显示文件的行号，并且截断太长的行 

head file       # 默认显示文件前10行
head -n 20 file # 显示文件前20行

tail file       # 默认显示文件后10行
tail -n 20 file # 显示文件后20行
tail -n +2 file # 跳过第1行，显示从第2行开始的所有行，可用于跳过文件的标题行
tail -f file    # 当文件的内容还在增加时，实时显示末尾增加的内容，常用于查看日志文件的更新情况
</code></pre>
<h2 id="wc-统计文件内容"><strong>wc - 统计文件内容</strong></h2>
<pre><code class="language-bash">wc -l file      # 统计文件行数
</code></pre>
<h2 id="touch-创建文件"><strong>touch - 创建文件</strong></h2>
<pre><code class="language-bash">touch file                  # 创建一个空文件
touch {file1,file2,file3}   # 同时创建3个文件
</code></pre>
<h2 id="cp-mv-rm-文件目录的复制移动删除"><strong>cp, mv, rm- 文件/目录的复制，移动，删除</strong></h2>
<pre><code class="language-bash">scp file1 file2     # 将file1复制一份，命名为file2，复制目录要加-r参数：scp -r
mv file1 dir1/      # 将file1移动到dir1/目录下
mv file1 file2      # 重命名：即将file1移动成为file2
rm file             # 删除文件，删除目录要加-r参数：rm -r
rm -f file          # 文件若不存在，删除时会报错，加-f参数就不会报错
</code></pre>
<h2 id="tar-文件打包压缩"><strong>tar - 文件打包/压缩</strong></h2>
<pre><code class="language-bash"># 平时tar基本上就能完成打包、压缩、解压的任务了
tar czvf file.tar.gz files  # 打包并压缩
tar xvf file.tar.gz         # 解包，解压缩

gzip file                   # 压缩
gunzip file.gz              # 解压
</code></pre>
<h2 id="chmod-改变文件目录权限"><strong>chmod - 改变文件/目录权限</strong></h2>
<pre><code class="language-bash">chmod +x file   # 增加[本人]可执行权限
chmod -x file   # 取消[本人]可执行权限
chmod a+x file  # 增加[所有人]可执行权限
chmod a-x file  # 取消[所有人]可执行权限
</code></pre>
<h2 id="chown-改变文件目录归属"><strong>chown - 改变文件/目录归属</strong></h2>
<pre><code class="language-bash">chown jianzuoyi:jianzuoyi file      # 将文件的所有权给jianzuoyi
chown -R jianzuoyi:jianzuoyi dirname    # 将目录以及目录内的文件的所有权给jianzuoyi
</code></pre>
<h2 id="sort-uniq-排序去重"><strong>sort, uniq - 排序，去重</strong></h2>
<pre><code class="language-bash">sort file				# 默认按字典序对文件进行排序
sort -k2,2 -k3,3 file	# 先按第2列排序，第2列相同，再按第3列排序
sort -k2,2n file		# 按第2列排序，且第2列是数字，升序
sort -k2,2nr file		# 按第2列排序，且第2列是数字，降序
sort -u file			# 先排序文件，然后去除相邻的重复行，只保留一条记录
sort file | uniq		# 去除相信的重复行，只保留一条记录，相当于： sort -u file

# 利用sort, uniq取两个文件的交、并、补集
sort a b | uniq			# 并集
sort a b | uniq -d &gt; c	# 交集
sort a c | uniq -u 		# 补集
</code></pre>
<h2 id="wget-下载文件"><strong>wget - 下载文件</strong></h2>
<pre><code class="language-bash">wget https://repo.anaconda.com/archive/Anaconda3-2020.07-Linux-x86_64.sh	# 下载文件到当前目录，文件名保持不变
</code></pre>
<h2 id="ssh-远程登录"><strong>ssh - 远程登录</strong></h2>
<pre><code class="language-bash">ssh username@host					 # ssh 远程连接至服务器
</code></pre>
<h2 id="scp-远程文件传输"><strong>scp - 远程文件传输</strong></h2>
<pre><code class="language-bash">scp username@host:/path/to/file .	 # 将远程服务器上的文件传输到当前目录，文件名保持不变，复制目录加参数-r
scp file username@host:/path/to/dir/ # 将本地文件复制到远程服务器，文件名保持不变，复制目录加参数-r
</code></pre>
<h2 id="rsync-远程文件拷贝"><strong>rsync - 远程文件拷贝</strong></h2>
<p>rsync与scp不同，它只是做增量更新且支持断点续传，也就是要复制的文件存在于目标文件夹且内容与当前要复制的相同，则不会复制。</p>
<pre><code class="language-bash">rsync -azvP dir1 dir2					# 将dir1的内容同步至dir2
rsync -azvP --delete dir1 dir2			# 同步dir2与dir1，dir1中删除的文件，dir2中也要跟着删除
rsync -azvP --exclude 'file' dir1 dir2  # 同步dir2与dir2，且将file排除在外
</code></pre>
<h2 id="df-du-free-查看磁盘内存使用情况"><strong>df, du, free - 查看磁盘/内存使用情况</strong></h2>
<pre><code class="language-bash">df -h		# 查看磁盘使用情况，-h表示以人类可读的方式显示容量大小
du -sh		# 查看当前目录使用了多少磁盘空间
du -sh *	# 查看当前目录下各文件或文件夹使用的磁盘空间
free -h		# 查看内存使用情况
</code></pre>
<h2 id="top-htop-ps-kill-任务管理"><strong>top, htop, ps, kill - 任务管理</strong></h2>
<pre><code class="language-bash">top -c		# 查看CPU，内存的使用情况
htop		# top的完美替代品，Linux系统不自带，需要安装， ubuntu系统：apt install htop
ps aut		# 查看后台任务运行情况，第2列是任务的PID号
kill -9 PID # 删除编号为PID的任务
</code></pre>
<h2 id="nohupdisown-远程任务管理"><strong>nohup，disown - 远程任务管理</strong></h2>
<pre><code class="language-bash">nohup ./run.sh &amp;&gt; run.sh.o &amp;	# 远程SSH登录服务器，在后台运行任务，断开远程连接后任务仍然在后台跑
</code></pre>
<ul>
<li>如果运行任务时没有加nohup命令，但任务运行时间长，但又必须断开（比如快下班了），若不想让任务因为断开远程连接而中断，可以用disown命令补救</li>
</ul>
<pre><code class="language-bash">./run.sh	# 假如任务是直接这样开始跑的
ctrl + z	# 按ctrl + z，将任务放到后台
jobs		# 输入jobs命令，回车，可以看到任务是暂停的： [1]+  Stopped(SIGTSTP)        bash run.sh
bg			# 让后台暂停的任务开始运行
jobs		# 再次运行jobs，可以看到任务已经跑起来了：   [1]+  Running                 bash run.sh &amp;
disown -r 	# 从当前shell中移除运行中的作业，至此，可以关掉终端回家了
</code></pre>
<h2 id="-管道"><strong>| - 管道</strong></h2>
<p>管道，将前一个命令的输出作为后一个命令的输入</p>
<pre><code class="language-bash">command1 | command2
</code></pre>
<h2 id="-输入输出重定向"><strong>&gt;, &gt;&gt; - 输入输出重定向</strong></h2>
<p>Linux中常用重定向操作符有：</p>
<ol>
<li>标准输入（/dev/stdin）：代码为0， 使用&lt;或&lt;&lt;</li>
<li>标准输出（/dev/stdout）：代码为1，使用&gt;（覆盖）或&gt;&gt;（追加）</li>
<li>标准错误输出（/dev/stderr）：代码为2，使用2&gt;或2&gt;&gt;</li>
<li>&amp;&gt; 标准输出和错误输出同时重定向</li>
<li>/dev/null 代表垃圾箱，不想要保存的东西都可以重定向到这里</li>
</ol>
<ul>
<li>输出重定向就是将命令的结果重定向到文件，而不是输出到屏幕，通常用于保存命令的结果</li>
</ul>
<pre><code class="language-bash">./run.sh &gt; run.sh.o		# 标准输出到run.sh.o日志文件
./run.sh 2&gt; run.sh.e	# 标准错误输出到run.sh.e错误日志文件
./run.sh &amp;&gt; run.sh.log	# 标准输出和标准错误都输出到定一个文件
./run.sh &amp;&gt; /dev/null	# 丢弃标准输出和标准错误信息
</code></pre>
<ul>
<li>输入重定向是将文件作为输入的来源，而不是键盘</li>
</ul>
<pre><code class="language-bash">command &lt; file			# 将file的内容作为command的输入 
command &lt;&lt; END			# 从标准输入（键盘）中读取数据，直到遇到分界符END时停止（分界符用户可以自定义）
command &lt;file1 &gt; file2	# 将file1作为command的输入，并将处理结果输出到file2
</code></pre>
<ul>
<li>综合运用</li>
</ul>
<pre><code class="language-bash">#!/bin/bash

while read line
do
    do something
done &lt; file.txt &gt; result.txt
</code></pre>
<p>逐行读入file.txt的内容，处理之后，将结果保存到result.txt文件中。</p>
<h2 id="find-locate-which-文件查找"><strong>find, locate, which - 文件查找</strong></h2>
<pre><code class="language-bash">find -name file					# 在当前目录查找名为file的文件
find dir/ -name file			# 在dir/目录下查找名为file的文件
find dir/ -name '*file*'		# 在dir/目录下查找包含file关键词的文件，-name参数支持正则表达式
find dir/ -name file -delete	# 查找文件并删除

locate file						# 查找文件
which command					# 显示命令的绝对路径
</code></pre>
<h2 id="xargs-命令组合工具"><strong>xargs - 命令组合工具</strong></h2>
<pre><code class="language-bash">cat file | xargs		# 将file的内容显示成一行
cat file | xargs -n3	# 将file的内容每3列一行进行输出
find /ifs/result -name '*.fq.gz' | xargs -n1 -I{} cp {} /ifs/data/	# 查找fq.gz文件并复制到/ifs/data目录下
find /ifs/result -name '*.fq.gz' | xargs tar czvf all.fq.gz			# 查找fq.gz文件并打包在一起
find . -type f -name '*.log' -print0 | xargs -0 rm -f				# 当rm文件过多时，可以这样删除
find . -type f -name '*.py' -print0 | xargs -0 wc -l				# 统计一个目录中所有python文件的行数
</code></pre>
<h2 id="parallel-并行工具"><strong>parallel - 并行工具</strong></h2>
<p>parallel是增强版的xargs。假如一个脚本文件中有4条命令：</p>
<pre><code class="language-bash"># cat run.sh
echo a
echo b
echo c
echo d

# 同时执行4个任务，生信中常通过这种方式并行执行多个任务
cat run.sh | parallel -j 4	
find *.fq | parallel -j 12 &quot;fastqc {} --outdir .&quot;	# 同时执行12个Fastqc任务
find *.bam | parallel --dry-run 'samtools index {}' # 同时执行samtools index任务，--dry-run显示任务命令但不实际执行，用于命令检查
</code></pre>
<h2 id="useradd-添加用户"><strong>useradd - 添加用户</strong></h2>
<pre><code class="language-bash">useradd -m username	# 创建用户并为其在/home下创建一个以其名称命名的目录
</code></pre>
<h2 id="passwd-更改密码"><strong>passwd - 更改密码</strong></h2>
<pre><code class="language-bash">passwd	    	   # 更改当前用户的密码
passwd username	   # 更改指定用户的密码
</code></pre>
<h2 id="dos2unix-文件格式转换"><strong>dos2unix - 文件格式转换</strong></h2>
<p>Linux很多工具都是针对纯文本文件的，并且需要是Unix-like格式的文本文件。但是很多时候文件是从Windows或Mac系统上传到Linux服务器上的，这可能导致文件格式不兼容，原因是不同平台生成的文本文件的换行符不一样。</p>
<table>
<thead>
<tr>
<th>操作系统</th>
<th>符号</th>
<th>正则表达式</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mac</td>
<td>^M</td>
<td>\r</td>
</tr>
<tr>
<td>Linux</td>
<td>$</td>
<td>\n</td>
</tr>
<tr>
<td>Windows</td>
<td>^M$</td>
<td>\r\n</td>
</tr>
</tbody>
</table>
<pre><code class="language-bash">cat -A file			# 查看文件换行符情况
dos2unix file			# Windows格式转换成Unix-like格式
</code></pre>
<h2 id="grep"><strong>grep</strong></h2>
<p><strong>用于查找文件里符合条件的字符串。</strong></p>
<pre><code class="language-bash">grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示列数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][--help][范本样式][文件或目录...]
grep pattern files			 # 搜索文件中包含pattern的行
grep -v pattern files		 # 搜索文件中不包含pattern的行

grep -f pattern.txt files	 # 搜索的pattern来自于文件中
grep -i pattern files		 # 不区分大小写。默认搜索是区分大小写的
grep -i pattern files		 # 只匹配整个单词，而不是字符串的一部分（如搜索hello，不会匹配到helloworld）
grep -n pattern files		 # 显示行号信息
grep -c pattern files		 # 显示匹配的行数
grep -l pattern files		 # 只显示匹配的文件名
grep -L pattern files		 # 显示不匹配的文件名
grep -C number pattern files     # 额外显示匹配行的上下[number]行
grep pattern1 | grep pattern2 files     # 显示既匹配pattern1，又匹配pattern2的行
grep -E &quot;pattern1|pattern2&quot; files	# 显示匹配pattern1或者pattern2的行, grep -E相当于egrep

# 用于搜索的特殊字符
^: 表示行前
$: 表示行尾

grep '^#' result.vcf		# 显示VCF文件的表头信息
grep '^hello$' files		# 显示只包含hello的行
grep -v '^\s*$' file		# 删除空白行
</code></pre>
<h2 id="sed"><strong>sed</strong></h2>
<p>sed是stream editor的缩写，中文称之为“流编辑器”。</p>
<pre><code class="language-bash">sed command file
</code></pre>
<ul>
<li>command部分，针对每行要进行的处理</li>
<li>file，要处理的文件</li>
</ul>
<h3 id="actions"><strong>Actions</strong></h3>
<ul>
<li>d：删除该行</li>
<li>p：打印该行</li>
<li>i：在行的前面插入新行</li>
<li>a：在行的后面插入新行</li>
<li>r：读取指定文件的内容。</li>
<li>w：写入指定文件。</li>
</ul>
<pre><code class="language-bash">sed -n '10p' file		# 显示第10行
sed -n '10,20p' file	# 显示第10到20之间的行
sed -n '/pattern/p' file# 显示含有pattern的行
sed -n '/pattern1/,/pattern2/p' file # 显示patter1与pattern2之间的行

sed '10d' file			# 删除第10行
sed '10,20d' file		# 删除第10到20之间的行
sed '/pattern/d'		# 删除匹配pattern的行
sed '/^\s*$/d' file		# 删除空白行
sed 's/^\s*//' file		# 删除行前的空白：空格，制表符
sed 's/\s*$//' file		# 删除行尾的空白：空格，制表符
sed 's/^\s*//;s/\s*$//' file # 删除行首和行尾的空白：空格，制表符

sed 's/AA/BB/' file		# 将文件中的AA替换成BB，只替换一行中第一次出现的AA，替换后的结果输出到屏幕
sed 's/AA/BB/g' file	# 将文件中的所有AA都替换成BB，替换后的结果输出到屏幕
sed -i 's/AA/BB/g' file # 将文件中的所有AA都替换成BB，直接更改文件的内容
sed '/CC/s/AA/BB/g' file# 只替换那些含有CC的行
sed 's/pattern/&amp;XXXX/' file	# 在pattern之后加上XXXX。&amp;表示之前被匹配的内容
sed 's/pattern.*/&amp;XXXX' file# 在匹配pattern的行尾加上XXXX。pattern.*表示包含pattern的整行内容

sed -n '1~4s/^@/&gt;/p;2~4p' file.fq &gt; file.fa	# Fastq文件转Fasta文件
sed -n '2~4p' file.fq		# 提取Fastq文件的序列

sed 'y/ABC/XYZ/' file	# 将ABC逐字替换成XYZ

sed '1i\hello' file		# 在第1行前面插入一行，内容为hello，通常用来为文件增加标题
sed '1a\hello' file		# 在第1行后面插入一行，内容为hello
sed '1r file2' file1	# 在第1行后面读入file2的内容
sed '/pattern/w file2' file1 # 将匹配的行写入file2中
</code></pre>
<h2 id="awk"><strong>awk</strong></h2>
<p>Awk是一个强大的文本分析工具，它每次读入一条记录，并把每条记录切分成字段后进行分析。Awk官方文档是非常好的学习材料，通过<code>man awk</code>查看。</p>
<pre><code class="language-bash">awk 'BEGIN { action } pattern { action } END { action }'
</code></pre>
<p><strong>Awk程序通常是一系列 pattern {action}对：</strong></p>
<p><code>pattern</code>，表示模式匹配，只处理匹配的行。pattern可以省略，表示匹配所有行</p>
<p><code>action</code>，表示对匹配行所做的动作。{actions}可以省略，表示{ print }。<code>BEGIN</code>和<code>END</code>的{action}不能省略</p>
<p><strong>pattern可能是：</strong></p>
<p><code>BEGIN</code>， 执行初始化操作，程序开始时执行一次</p>
<p><code>END</code>，执行收尾工作，程序结束时执行一次</p>
<p><code>expression</code>，一个表达式，既可以是判断语句，也可以是正则表达式</p>
<h3 id="常用参数"><strong>常用参数</strong></h3>
<ul>
<li><code>-F value</code> 设置域分隔符，相当于给FS内置变量赋值</li>
<li><code>-v var=value</code> 将变量value的值赋给程序变量var，-v可以多次使用</li>
</ul>
<h3 id="记录与字段"><strong>记录与字段</strong></h3>
<p>记录是一次读入的内容，通常是文件的一行，保存在字段变量$0中，记录可以被分割成字段，保存在变量$1，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi mathvariant="normal">，</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">，</mi></mrow><annotation encoding="application/x-tex">2，...，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord cjk_fallback">，</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord cjk_fallback">，</span></span></span></span>NF中。</p>
<h3 id="表达式与操作符"><strong>表达式与操作符</strong></h3>
<p>Awk表达式的符号与C语言的类似，基本的表达式有数字，字符串，变量，字段，数组以及函数调用。变量无需声明，它们在首次使用时被初始化为<code>null</code>。</p>
<pre><code class="language-bash">assignment          =  +=  -=  *=  /=  %=  ^=
conditional         ?  :
logical and         &amp;&amp;
logical or          ||
logical not         !
array membership    in
matching       		~   !~
relational          &lt;  &gt;   &lt;=  &gt;=  ==  !=
concatenation       (no explicit operator)
add ops             +  -
mul ops             *  /  %
unary               +  -
exponentiation      ^
inc and dec         ++ -- (both post and pre)
field               $
</code></pre>
<h3 id="正则表达式"><strong>正则表达式</strong></h3>
<p>在Awk中语言中，通常测试一个记录、字段或字符串是否与一个正则表达式匹配，匹配返回1，不匹配返回0。正则表达式用两个反斜杠<code>/</code>包围。</p>
<pre><code class="language-bash">expr ~ /r/							 # 评估expr是否与r匹配。匹配的意思是expr的一个子串是否在正则表达式r定义的字符串集中。

/r/ { action }, $0 ~ /r/ { action }	 # 两者相同， /r/ 等于 $0 ~ /r/
</code></pre>
<p>任何表达式都可以放到<code>~</code>和<code>!~</code>右边或者内建的需要正则表达式的地方。在必要的时候，该表达式会被转变成字符串，然后作为一个正则表达式来解释。以下三行awk命令完成同样的功能：输出第5列为10的的行。</p>
<pre><code class="language-bash">seq 20 | xargs -n5 &gt; file
# cat file
1 2 3 4 5
6 7 8 9 10
11 12 13 14 15
16 17 18 19 20

awk '$5 ~ /10/' file
awk '$5 ~ &quot;10&quot;' file
awk '$5 ~ 10' file
</code></pre>
<h3 id="数组"><strong>数组</strong></h3>
<p>Awk支持一维数组。其表示方法为<code>array[expr]</code>，<code>expr</code>在内部被统一转换成字符串类型，因此A[1]，与A[&quot;1&quot;]相同，事实上索引都是“1”。索引为字符串的数组被称为关联数组。<code>expr in array</code>用于判断数组元素array[expr]是否存在。</p>
<pre><code class="language-bash">for ( var in array ) statement
</code></pre>
<h3 id="控制语句"><strong>控制语句</strong></h3>
<pre><code class="language-bash">if ( expr ) statement
if ( expr ) statement else statement
while ( expr ) statement
do statement while ( expr )
for ( opt_expr ; opt_expr ; opt_expr ) statement
for ( var in array ) statement
continue
break
</code></pre>
<h3 id="内置变量"><strong>内置变量</strong></h3>
<ul>
<li><code>NR</code> - 当前行数</li>
<li><code>NF</code> - 当前行的列数</li>
<li><code>RS</code>，行分隔符，默认是换行符</li>
<li><code>FS</code>，列分隔符，默认是空格和制表符</li>
<li><code>ORS</code>，输出行分隔符，默认为换行符</li>
<li><code>OFS</code>，输出列分隔符，默认为空格</li>
<li><code>FILENAME</code>，当前文件名</li>
</ul>
<h3 id="内置函数"><strong>内置函数</strong></h3>
<h3 id="字符串函数"><strong>字符串函数</strong></h3>
<p>sub()、substr()、gsub()，sprintf()，index()，length()， match()，split()，tolower(), toupper()</p>
<h3 id="数学函数"><strong>数学函数</strong></h3>
<p>sin()，cos(), ...</p>
<h3 id="输入输出"><strong>输入输出</strong></h3>
<p>有两个输出语句，<code>print</code>和<code>printf</code></p>
<pre><code class="language-python">print							# 打印整条记录到标准输出，相当于print $0
print expr1, expr2, ..., exprn	# 打印指定字段到标准输出
printf format, expr-list		# C语言printf函数的重用
</code></pre>
<p>输入函数getline有以下几种形式：</p>
<pre><code class="language-bash">getline							# 读取下一条记录到$0，更新NF，NR和FNR
getline var						# 读取下一条记录到var，更新NR和FNR
getline &lt; file					# 从文件读取记录到$0，更新NF
getline var &lt; file				# 从文件读取记录到var
command | getline				# 通过管道传递command的结果到$0，更新NF
command | getline var			# 通过管道传递command的结果到var
seq 10 | awk '{print $0;getline}'					  # 显示奇数行
seq 10 | awk '{getline; print $0}'					  # 显示偶数行
seq 10 | awk '{getline tmp; print tmp; print $0}'	  # 奇偶行对调

awk 'BEGIN {&quot;date&quot; | getline;close(&quot;date&quot;);print $0}' # 得到系统当前时间

# fastq转换成fasta
awk '{getline seq; getline comment; getline quality; sub(&quot;@&quot;, &quot;&gt;&quot;, $0); print $0&quot;\n&quot;seq}' file
</code></pre>
<h3 id="示例"><strong>示例</strong></h3>
<pre><code class="language-bash">awk '{print $0}' file	# 打印整行
awk '{print $1}' file	# 打印第一列
awk '{print $2}' file	# 打印第二列
awk '{print $NF}' file	# 打印最后一列
awk '{print $(NF-1)}' file#打印倒数第二列
awk -F ';' -v OFS='\t' '{print $1,$2,$NF}' file	# 读入的文件以逗号;分隔列，打印第1列，第2列和最后一列，并且打印时以制表符作为列的分隔符
number=10;awk -v n=$number '{print n}' file	# number的值被传给了程序变量n
awk '$2 &gt; 100' file		# 打印第2列大于100的行
awk 'NR&gt;1 &amp;&amp; NR&lt;4' file # 打印第2~3行

awk '/EGFR/' file		# 打印含有EGFR的行，相当于grep EGFR file
awk '$1 ~ /EGFR/' file	# 打印第1列含有EGFR的列

# 按指定列去除重复行
# cat file
1 2 3 4 5
6 2 8 9 10
11 12 13 14 15
16 17 18 19 20
awk '!a[$2]++' file		# 第二列出现两次2，只保留第一次出现的那一行，结果如下：
1 2 3 4 5
11 12 13 14 15
16 17 18 19 20

awk '{sum+=$1} END {print sum}' file	# 累加文件的第一列
awk '{sum+=$1} END {print sum/NR}' file	# 求第一列的平均数

# 从含有多条fasta序列的文件中提取指定序列
 awk -v RS=&quot;&gt;&quot; '/chr1/ {print $0}' hg19.fa	# 提取chr1的序列
 awk -v RS=&quot;&gt;&quot; '/chr1|chr2/ {print $0}' hg19.fa	# 提取chr1和chr2的序列
</code></pre>
<h2 id="bash脚本模板"><strong>Bash脚本模板</strong></h2>
<pre><code class="language-bash">#!/bin/bash

command1

command2

...
</code></pre>
<p><code>chmod +x run.sh</code> 给run.sh脚本增加可执行权限</p>
<p>执行脚本，以下三种方式都可以：</p>
<pre><code class="language-bash"># 脚本在前台执行，标准输出和标准错误输出到屏幕
./run.sh
bash run.sh
sh run.sh		# 前提sh链接到了bash，如果没有，需要root权限执行命令：ln -sf /bin/bash /bin/sh

# 脚本在前台执行，标准输出和标准错误保存到文件
./run.sh &amp;&gt; run.sh.o

# 脚本在后台执行，在最后加上一个&amp;符号
./run.sh &amp;&gt; run.sh.o &amp;

# 脚本在后台执行，并且防断线（长时间运行任务时使用）
nohup ./run.sh &amp;&gt; run.sh.o &amp;
</code></pre>
<h2 id="其他命令"><strong>其他命令</strong></h2>
<pre><code class="language-bash">echo $PATH		# 显示环境变量
time command	# 显示命令执行时间
date			# 显示日期和时间
history			# 显示历史命令
export PATH=$PATH:/path/to/bin	# 将路径加入环境变量中
ln -s file file2# 为file文件创建软链接，名称为file2
exit			# 退出登录
Tab键自动补全	 # Tab键可以补全命令或文件路径，输入部分命令或路径时，尝试按Tab键补全
Ctrl + c		# 中止当前命令的执行
seq 10			# 产生1到10的整数
md5sum			# 生成，或验证文件的MD5值
</code></pre>
<hr>
<h2 id="1-帮助命令">1. 帮助命令</h2>
<p>1.1 <code>man 命令名称</code>，man 的意思是 manual，即手册，对于大多数命令都可以使用这个命令来查看其使用的方法。</p>
<p>1.2 <code>help 命令名称</code> 或者 <code>命令名称 --help</code>，可以查看命令的使用帮助。</p>
<h2 id="2-目录操作">2. 目录操作</h2>
<p>2.1 <code>pwd</code>，查看当前所在的目录路径。</p>
<p>2.2 <code>ls 路径</code>，查看指定路径下的文件列表，可以加上多个路径，例如：<code>ls /usr /etc</code>，分别显示根目录下的 user 目录和 etc 目录。</p>
<p>ls 命令的常用参数有：</p>
<ul>
<li><code>-a</code>，显示隐藏的目录或文件</li>
<li><code>-l</code>，显示文件的详细信息，<code>ls -l</code> 等价于 <code>ll</code></li>
<li><code>-h</code>，格式化显示文件的大小，如 1K，3M，1G，方便阅读</li>
<li><code>-t</code>，以修改时间排序文件列表</li>
<li><code>-r</code>，反序排序列表</li>
<li><code>-R</code>，递归显示所有子文件夹的内容</li>
<li><code>-S</code>，大写的 S，以文件的大小排序</li>
</ul>
<p>2.3 <code>cd 路径</code>，cd 的意思是 change directory，改变路径。</p>
<p>2.4 <code>mkdir 目录名称</code>，创建目录，可以加多个参数创建多个目录，例如 <code>mkdir /tmp/a /tmp/b</code>。</p>
<p>常用参数：<code>-p</code>，表示创建多级不存在的目录。</p>
<p>2.5 <code>rmdir 目录</code>，删除目录，注意只能删除空目录。</p>
<p>2.6 <code>cp</code>，复制文件或者目录的命令，例如将一个文件复制到另一个目录中：<code>cp test.txt /usr/local/</code></p>
<p>常用参数：</p>
<ul>
<li><code>-r</code>，用于复制目录，递归目录中的所有内容</li>
<li><code>-v</code>，显示复制的详细信息</li>
</ul>
<p>2.7 <code>mv</code>，这个命令有两个功能，一是重命名文件或文件夹，例如 <code>mv a.txt b.txt</code>，二是移动文件，例如将文件 a.txt 移动至 root 目录下 <code>mv a.txt /root/</code>。</p>
<h2 id="3-查看文件">3. 查看文件</h2>
<p>3.1 <code>cat 文件名</code>，查看文件的全部内容，常用参数 <code>-n</code>，可显示文件的行号。</p>
<p>3.2 <code>head 文件名</code>，查看文件头部的内容，默认显示前 10 行，可加参数 <code>-行数</code> 查看前 n 行，例如 <code>head -30 文件名</code>。</p>
<p>3.3 <code>tail 文件名</code>，查看文件尾部的内容，默认显示最后 10 行，常用参数 <code>-f</code>，可查看追加的文件内容。</p>
<p>3.4 <code>wc 文件名</code>，查看文件的统计信息，常用参数：</p>
<ul>
<li><code>-l</code>，显示文件的行数</li>
<li><code>-w</code>，显示文件内的总单词数</li>
<li><code>-c</code>，文件的字节数大小</li>
</ul>
<h2 id="4-压缩解压">4. 压缩解压</h2>
<p>4.1 打包命令：<code>tar cf 打包后存放路径和文件名 源文件</code>，例如打包根目录下的 /etc，命令：<code>tar cf /temp/etc-backup.tar /etc</code>，使用这个参数打包，不用压缩源文件。</p>
<p>4.1 压缩打包：</p>
<ul>
<li>gz 格式：<code>tar czf /temp/etc-backup.tar.gz /etc</code></li>
<li>bz2 格式：<code>tar cjf /temp/etc-backup.tar.bz2 /etc</code></li>
</ul>
<p>两种格式的区别：gz 格式压缩速度更快，bz2 个格式压缩后的文件更小。</p>
<p>.tar.gz 可以缩写为 <strong>.tgz</strong>，.tar.bz2 可以缩写为 <strong>.tbz2</strong>。</p>
<p>4.2 解压命令：</p>
<ul>
<li>解压 <strong>.tar</strong> 格式的文件：<code>tar xf 文件名</code>，可加参数 -C，指定解压后的存储路径</li>
<li>解压 <strong>.tar.gz</strong> 格式的文件：<code>tar zxf 文件名</code></li>
<li>解压 <strong>.tar.bz2</strong> 格式的文件：<code>tar jxf 文件名</code></li>
</ul>
<h2 id="5-权限操作">5. 权限操作</h2>
<p>5.1 添加用户：<code>useradd 用户名</code>。</p>
<p>5.2 修改用户密码：<code>passwd 用户名</code>，不加用户名的话，则默认修改当前用户的密码。</p>
<p>5.3 删除用户：<code>userdel 用户名</code>，可加参数 -f 强制删除，-r 删除用户主目录。</p>
<p>5.4 新建用户组：<code>groupadd 用户组名称</code>。</p>
<p>5.5 将某个用户加入到某个用户组中：<code>usermod -g 用户组名称 用户名</code></p>
<p>5.6 修改文件权限，文件权限的表示为 r（可读），w（可写），x（可执行），数字表示分别是 4， 2，1。</p>
<p><code>chmod u+x a.txt</code>，表示对文件 a.txt 添加可执行权限，选项 u 表示所属用户，类似的有 g（属组）、a（全部）；+ 表示添加权限，- 表示删除权限</p>
<p>5.7 修改文件的属主和属组权限：<code>chown root:root a.txt</code>，其中 : 前面的表示所属用户，后面的表示所属用户组。</p>
<p>也可以单独改变属主和属组的权限：</p>
<ul>
<li><code>chown root a.txt</code>，改变所属用户。</li>
<li><code>chown :root a.txt</code>，改变所属用户组。</li>
</ul>
<h2 id="6-软件安装">6. 软件安装</h2>
<p>6.1 rpm 包管理，文件后缀一般是以 .rpm 结尾的。</p>
<ul>
<li>安装的命令：<code>rpm -i xxx.rpm</code>，如果安装的包需要有其他的依赖，则会提示先手动安装依赖。</li>
<li>查看安装的软件包：<code>rpm -qa</code>，可加管道过滤想查询的软件包，<code>rpm -qa | grep mysql</code> 。</li>
<li>卸载软件包命令：<code>rpm -e 软件包名称</code>，注意这里必须输入软件包的名字全程。常加参数 <code>--nodeps</code> 表示卸载时不检查依赖。</li>
</ul>
<p>6.2 yum 是一个基于 rpm 的包管理器，可以自己检查依赖，维护包的升级移除，更加的自动化，在实际中的使用也更多。</p>
<ul>
<li>安装软件包：<code>yum install 软件包名称</code></li>
<li>卸载：<code>yum remove 软件包名称</code></li>
<li>查看安装的软件：<code>yum list</code></li>
</ul>
<p>6.3 Linux 上安装软件的第三种方式是源代码编译安装，在下载好的源代码中一般有一个 configure 文件，安装的步骤为：</p>
<ul>
<li>进入软件包目录，执行 configure 文件，<code>./configure --prefix=/软件包安装路径</code></li>
<li>然后执行命令 <code>make</code>，或者按照指示执行 <code>gmake</code>，两者是类似的命令</li>
<li>然后再执行 <code>make install</code>命令</li>
</ul>
<h2 id="7-vim命令">7. Vim命令</h2>
<p>Vim 是在 Linux 上经常使用的一个文本编辑器，熟练使用 Vim 的常用命令也是有必要的。</p>
<p>7.1 输入 <code>vim 文件名</code> 则进入了 vim 的正常模式，常用命令如下：</p>
<ul>
<li>插入：
<ul>
<li>i（光标处前一个字符编辑），I（大写的 i，光标所处行首编辑）</li>
<li>a（光标处后一个字符编辑），A（光标所处行尾编辑）</li>
<li>o（光标处向下新建一行编辑），O（大写的 o，光标处向上新建一行编辑）</li>
</ul>
</li>
<li>复制：
<ul>
<li>复制单行：光标处所处行按 YY，然后在目标行按 P</li>
<li>复制多行：按数字 + YY，例如复制 3 行，在光标处按 3 YY，然后在目标行按 P</li>
</ul>
</li>
<li>剪切：
<ul>
<li>剪切单行：光标所在行按 DD</li>
<li>剪切多行：数字 + DD</li>
</ul>
</li>
<li>撤销：按 U</li>
<li>删除光标所处的字符：X</li>
<li>替换光标所处的字符：按 R 后输入新的字符</li>
<li>光标移动至某行：行数 + GG</li>
<li>显示文件行数：按 ：后输入命令 <code>set nu</code></li>
<li>移动至文件的第一行：GG</li>
<li>移动至文件最后一行：shift + G</li>
<li>移动至一行的开头：shift + 6</li>
<li>移动至一行的末尾：shift + 4</li>
</ul>
<p>7.2 vim 的命令模式：</p>
<ul>
<li>
<p><code>:w /usr/local/a.txt</code>，w 表示保存，后面可以跟上保存的路径和文件名称</p>
</li>
<li>
<p><code>:wq</code> 表示保存并退出，<code>:q!</code> 表示强制退出，不保存修改</p>
</li>
<li>
<p><code>:! 其他Linux命令</code>，输入 ! 可以进入临时的命令模式，在编辑文件的时候执行其他的命令，按 Enter 键回到正在编辑的文件中</p>
</li>
<li>
<pre><code>/ 字符
</code></pre>
<p>，可以搜索文件中的内容，搜索后，匹配的文本会高亮显示，按 N 移动至下一个匹配的结果，按 shift + N 移动至上一个。</p>
<ul>
<li>搜索后的文件会高亮显示，如果需要取消高亮显示，输入命令：<code>:set nohlsearch</code>，如果需要重新高亮显示，去掉命令中的 no 即可：<code>:set hlsearch</code></li>
</ul>
</li>
<li>
<p>替换搜索到的内容：<code>:s/原文本/新的内容</code>，默认只会替换光标所在行的第一处搜索匹配的内容</p>
</li>
<li>
<p>全局替换搜索到的内容：<code>:%s/原文本/新的内容</code></p>
</li>
<li>
<p>如果匹配的内容有连续的，则全局替换时需要加参数 g：<code>:%s/原文本/新文件/g</code></p>
</li>
<li>
<p>替换某行的内容：<code>m,ns/原文本/新的内容</code>， m、n 分别表示起始行和结束行，同理也可加参数 /g 替换有连续匹配的内容。</p>
</li>
</ul>
<h1 id="考题">考题</h1>
<hr>
<h2 id="00-平常用什么-linux-命令比较多如何打开文件并进行查找某个单词怎么在某个目录下找到包含-txt-的文件">00 平常用什么 linux 命令比较多？如何打开文件并进行查找某个单词？怎么在某个目录下找到包含 txt 的文件？</h2>
<p>pwd：显示当前所在位置</p>
<p>sudo + 其他命令：以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。</p>
<p>grep：要搜索的字符串 要搜索的文件 --color ： 搜索命令，--color 代表高亮显示</p>
<p>ps - ef/ps aux： 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：</p>
<pre><code class="language-shell"> ps aux|grep redis
</code></pre>
<p>（查看包括redis的进程），也可使用</p>
<pre><code class="language-shell">pgrep redis -a
</code></pre>
<p>注意：如果直接用ps（（Process Status））命令，会显示所有进程的状态，通常结合 grep 命令查看某进程的状态。</p>
<p>kill -9 进程的 pid ： 杀死进程（-9 表示强制终止），先用 ps 查找进程，然后用 kill 杀掉。</p>
<p>find 目录 参数 ： 寻找目录（查）。在/home目录下查找以 .txt 结尾的文件名:</p>
<pre><code class="language-shell">find /home -name &quot;*.txt&quot;
</code></pre>
<p>ls 或者 ll :（ll 是 ls -l 的别名，ll 命令可以看到该目录下的所有目录和文件的详细信息）： 查看目录信息。</p>
<p>free : 显示系统内存的使用情况，包括物理内存、交换内存(swap)和内核缓冲区内存。</p>
<p>tar -zcvf 打包压缩后的文件名 要打包压缩的文件 : 打包并压缩文件，一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般 .tar.gz。c：压缩。</p>
<p>tar -xvf 压缩文件 - C 解压的位置 : 解压压缩包。x: 解压。</p>
<p>wget : 是从远程下载的工具。</p>
<p>vmstat : 虚拟内存性能监控、CPU 监控。</p>
<p>top : 常用来监控Linux的系统状况，比如CPU、内存的使用，显示系统上正在运行的进程。load average：系统负载，就是进程队列的长度。当这个值&gt;cpu核心数的时候就说明有进程在等待处理了，是负载过重。</p>
<p>2.18 用过 ping 命令么？简单介绍一下。TTL 是什么意思？<br>
ping : 查看与某台机器的连接情况。TTL：生存时间。数据报被路由器丢弃之前允许通过的网段数量。</p>
<p>2.19 怎么判断一个主机是不是开放某个端口？<br>
telnet IP 地址 端口</p>
<pre><code class="language-shell">telnet  127.0.0.1 3389 
</code></pre>
<h2 id="快捷键">快捷键</h2>
<p>接下来是大家很熟悉的一个环节了，许多软件都内置了快捷键供用户使用，Linux/Shell 也不例外，熟悉这些快捷键可以极大提高我们的工作效率，我尤其推荐那些用来“移动光标”的命令。有时候我们输入的命令很长，会遇到一些“卡在中间、进退两难”的情况，这时候它们可能会发挥大的作用哦：</p>
<table>
<thead>
<tr>
<th>快捷键名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>CTRL+A</td>
<td>把光标移到命令行开头</td>
</tr>
<tr>
<td>CTRL+E</td>
<td>把光标移到命令行结尾</td>
</tr>
<tr>
<td>CTRL+C</td>
<td>强制终止当前命令</td>
</tr>
<tr>
<td>CTRL+L</td>
<td>清屏，相当于clear命令</td>
</tr>
<tr>
<td>CTRL+U</td>
<td>删除/剪切当前行、光标前的内容</td>
</tr>
<tr>
<td>CTRL+K</td>
<td>删除/剪切当前行、光标后的内容</td>
</tr>
<tr>
<td>CTRL+Y</td>
<td>粘贴CTRL+U/K中剪切的内容</td>
</tr>
<tr>
<td>CTRL+R</td>
<td>在历史命令中搜索</td>
</tr>
<tr>
<td>CTRL+D</td>
<td>退出当前终端</td>
</tr>
<tr>
<td>CTRL+Z</td>
<td>刮起当前进程</td>
</tr>
<tr>
<td>CTRL+S</td>
<td>暂停屏幕输出</td>
</tr>
<tr>
<td>CTRL+Q</td>
<td>恢复屏幕输出</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker基础笔记]]></title>
        <id>https://flyingchase.github.io/post/docker-ji-chu-bi-ji/</id>
        <link href="https://flyingchase.github.io/post/docker-ji-chu-bi-ji/">
        </link>
        <updated>2021-05-03T12:25:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="00-虚拟化容器介绍">00 虚拟化容器介绍</h2>
<ul>
<li>
<p>虚拟机的不足之处在于对物理服务器资源的消耗，当我们在物理服务器创建一台虚拟机时，便需要虚拟出一套硬件并在上面运行完整的操作系统，每台虚拟机都占用许多的服务器资源。</p>
</li>
<li>
<p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。</p>
</li>
<li>
<p><code>Docker</code>是使用时下很火的<code>Golang</code>语言进行开发的，其技术核心是<code>Linux</code>内核的<code>Cgroup</code>,<code>Namespace</code>和<code>AUFS</code>类的<code>Union FS</code>等技术，这些技术都是<code>Linux</code>内核中早已存在很多年的技术，所以严格来说<code>Docker</code>并不是一个完全创新的技术，<code>Docker</code>通过这些底层的<code>Linux</code>技术，对<code>Linux</code>进程进行封装隔离，而被隔离的进程也被称为容器，完全独立于宿主机的进程。</p>
</li>
<li>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/aTm088.png" alt="aTm088" loading="lazy"></figure>
</li>
<li>
<p>Docker &amp; 虚拟机 比较</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/image-20210401175039725.png" alt="image-20210401175039725" loading="lazy"></figure>
</li>
</ul>
<p>0</p>
<h2 id="01-docker基本概念">01 Docker基本概念</h2>
<h3 id="0101-镜像-image">01.01 镜像 Image</h3>
<ul>
<li>
<p>Root 文件系统 提供容器运行时的程序 库 资源 配置等文件和配置参数</p>
<pre><code class="language-bash"># 列出镜像
docker image ls
# 拉取镜像
docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]
# 拉取一个镜像，需要指定Docker Registry的地址和端口号，默认是Docker Hub，还需要指定仓库名和标签，仓库名和标签唯一确定一个镜像，而标签是可能省略，如果省略，则默认使用latest作为标签名，另外，仓库名则由作者名和软件名组成。
# 运行镜像
docker run -it centos /bin/bash
# image_name表示镜像名，image_id表示镜像id
dockere image rm image_name/image_id

</code></pre>
</li>
<li>
<p><code>docker images</code> ：列出 docker host 机器上的镜像，可以使用 <code>-f</code> 进行过滤</p>
</li>
<li>
<p><code>docker build</code>：从 Dockerfile 中构建出一个镜像</p>
</li>
<li>
<p><code>docker history</code>：列出某个镜像的历史</p>
</li>
<li>
<p><code>dockerimport</code>：从 tarball 中创建一个新的文件系统镜像</p>
</li>
<li>
<p><code>docker pull</code>：从 docker registry 拉去镜像</p>
</li>
<li>
<p><code>docker push</code>：把本地镜像推送到 registry</p>
</li>
<li>
<p><code>docker rmi</code>：删除镜像</p>
</li>
<li>
<p><code>docker save</code>：把镜像保存为 tar 文件</p>
</li>
<li>
<p><code>docker search</code>：在 docker hub 上搜索镜像</p>
</li>
<li>
<p><code>docker tag</code>：为镜像打上 tag 标记</p>
</li>
</ul>
<h3 id="0102-容器-container">01.02 容器 container</h3>
<p>镜像是生成容器的模版</p>
<p><strong>镜像&amp;&amp;容器</strong></p>
<p>​	面向对象中的 类与对象的关系</p>
<pre><code class="language-bash"># 查看容器
docker container ls
docker ps
# 删除容器
docker rm container_id # (docker ps 可以看见container_id)
# 进入容器
docker exec -it container_id command

</code></pre>
<h3 id="0103-仓库-repository">01.03 仓库 Repository</h3>
<p>类似GitHub进行集中储存和分发镜像的服务</p>
<p>默认Docker Hub <code>hub.docker.com</code></p>
<h3 id="0104-docker架构">01.04 Docker架构</h3>
<p>使用C/S模型 通过客客户端调用服务端 Docker 客户端与 Docker 服务器进行交互，Docker服务端负责构建、运行和分发 Docker 镜像。</p>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/image-20210401182157890.png" alt="image-20210401182157890" loading="lazy"></figure>
<p>Docker Daemon 是服务器组建 为守护进程 响应客户端的请求并翻译为系统调用完成容器的管理操作</p>
<h2 id="02-打包程序">02 打包程序</h2>
<p>**普通打包方式: **</p>
<p>以js打包为例</p>
<ul>
<li>start with an OS</li>
<li>Install Node</li>
<li>Copy app files</li>
<li>Run node app.js</li>
</ul>
<p><strong>Dockerfileff打包:</strong></p>
<ul>
<li>首字母D大写 其他均小写 无后缀</li>
<li>FROM 镜像文件</li>
</ul>
<pre><code class="language-shell">docker build -t hellodocker .
docker images
docker image ls //列举出来的tag可以进行版本公职 versioning 

</code></pre>
<pre><code class="language-shell"># 回顾基础Linux操作commad
# 查看文件前2行
head -n 2 *.txt
# 查看文件最后2行
tail -n 2 *.txt
# less more查看长文件
# 重定向 &gt;
cat # 串联+合并 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[刷题笔记]]></title>
        <id>https://flyingchase.github.io/post/shua-ti-bi-ji/</id>
        <link href="https://flyingchase.github.io/post/shua-ti-bi-ji/">
        </link>
        <updated>2021-05-03T12:23:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="刷题坑">刷题坑</h1>
<hr>
<h2 id="00-杂项">00 杂项</h2>
<h3 id="0001-待刷备份-lintcode-leetcode">00.01 待刷备份 LintCode LeetCode</h3>
<h3 id="算法笔记">[[算法笔记]]</h3>
<p>待刷:</p>
<p>①<strong>初期，刷入门核心题</strong></p>
<p>这是针对毫无经验的刷题选手的策略。如果已经有一定刷题心得，可以跳过这步。</p>
<p>首先要给自己建立信心，我的策略是先把<strong>最基础的入门题刷个30道左右</strong>，熟悉coding的过程，找到刷题的感觉。</p>
<p>这些是我筛选过的还不错的入门题，我愿称之为——<strong>菜菜子必备的编程20题</strong>：</p>
<p>1.<a href="https://www.lintcode.com/problem/463/?utm_source=sc-zhihuniming-sy0309-2">整数排序</a></p>
<p>2.<a href="https://www.lintcode.com/problem/37//?utm_source=sc-zhihuniming-sy0309-2">反转一个3位整数</a></p>
<p>3.<a href="https://www.lintcode.com/problem/283//?utm_source=sc-zhihuniming-sy0309-2">三数之中的最大值</a></p>
<p>4.<a href="https://www.lintcode.com/problem/1921//?utm_source=sc-zhihuniming-sy0309-2">从不充值的玩家</a></p>
<p>5.<a href="https://www.lintcode.com/problem/298//?utm_source=sc-zhihuniming-sy0309-2">寻找素数</a></p>
<p>6.<a href="https://www.lintcode.com/problem/297//?utm_source=sc-zhihuniming-sy0309-2">寻找最大值</a></p>
<p>7.<a href="https://www.lintcode.com/problem/466//?utm_source=sc-zhihuniming-sy0309-2">链表节点计数</a></p>
<p>8.<a href="https://www.lintcode.com/problem/454//?utm_source=sc-zhihuniming-sy0309-2">矩阵面积</a></p>
<p>9.<a href="https://www.lintcode.com/problem/25//?utm_source=sc-zhihuniming-sy0309-2">打印X</a></p>
<p>10.<a href="https://www.lintcode.com/problem/1919//?utm_source=sc-zhihuniming-sy0309-2">分数超过组长的组员</a></p>
<p>11.<a href="https://www.lintcode.com/problem/1927//?utm_source=sc-zhihuniming-sy0309-2">硬币翻面</a></p>
<p>12.<a href="https://www.lintcode.com/problem/1934//?utm_source=sc-zhihuniming-sy0309-2">张三的故事</a></p>
<p>13.<a href="https://www.lintcode.com/problem/1931//?utm_source=sc-zhihuniming-sy0309-2">寻找特定的患者</a></p>
<p>14.<a href="https://www.lintcode.com/problem/1932//?utm_source=sc-zhihuniming-sy0309-2">挂科最多的同学</a></p>
<p>15.<a href="https://www.lintcode.com/problem/1938//?utm_source=sc-zhihuniming-sy0309-2">查询用户邮箱</a></p>
<p>16.<a href="https://www.lintcode.com/problem/1923//?utm_source=sc-zhihuniming-sy0309-2">增长的疫情感染人数</a></p>
<p>17.<a href="https://www.lintcode.com/problem/1930//?utm_source=sc-zhihuniming-sy0309-2">公租房信息查询</a></p>
<p>18.<a href="https://www.lintcode.com/problem/1920//?utm_source=sc-zhihuniming-sy0309-2">查找重名的同学</a></p>
<p>19.<a href="https://www.lintcode.com/problem/1925//?utm_source=sc-zhihuniming-sy0309-2">超过3名球员所得到的分数</a></p>
<p>20.<a href="https://www.lintcode.com/problem/1924//?utm_source=sc-zhihuniming-sy0309-2">推荐学理科的同学</a></p>
<p>②中期，按知识点tag刷题</p>
<hr>
<p>接下来就要真正的掌握算法和数据结构知识点。</p>
<p>我的策略是逮着一个知识点使劲刷，刷到掌握了为止（不限题数）。</p>
<p>但如果刷了30题以上还是不得其法，可以先放一放，不要给自己造成心理负担。</p>
<p><strong>最让人头疼的动态规划，可以循序渐进的刷这10道题：</strong></p>
<p>1.<a href="https://www.lintcode.com/problem/514/?utm_source=sc-zhihuniming-sy0309-2">栅栏染色</a></p>
<p>2.<a href="https://www.lintcode.com/problem/111/?utm_source=sc-zhihuniming-sy0309-2">爬楼梯</a></p>
<p>3.<a href="https://www.lintcode.com/problem/749/?utm_source=sc-zhihuniming-sy0309-2">约翰的后花园</a></p>
<p>4.<a href="https://www.lintcode.com/problem/683/?utm_source=sc-zhihuniming-sy0309-2">单词拆分</a></p>
<p>5.<a href="https://www.lintcode.com/problem/437/?utm_source=sc-zhihuniming-sy0309-2">书籍复印</a></p>
<p>6.<a href="https://www.lintcode.com/problem/512/?utm_source=sc-zhihuniming-sy0309-2">解码方法</a></p>
<p>7.<a href="http://lintcode.com/problem/192/?utm_source=sc-zhihuniming-sy0309-2">通配符匹配</a></p>
<p>8.<a href="https://www.lintcode.com/problem/816/?utm_source=sc-zhihuniming-sy0309-2">旅行商问题</a></p>
<p>9.<a href="https://www.lintcode.com/problem/622/?utm_source=sc-zhihuniming-sy0309-2">青蛙跳</a></p>
<p>10.<a href="https://www.lintcode.com/problem/20/?utm_source=sc-zhihuniming-sy0309-2">骰子求和</a></p>
<p><strong>双指针算法，高频算法之王，变形比较多。想掌握的话，刷这些题：</strong></p>
<p>1.<a href="https://www.lintcode.com/problem/148/?utm_source=sc-zhihuniming-sy0309-2">颜色分类</a></p>
<p>2.<a href="https://www.lintcode.com/problem/607/?utm_source=sc-zhihuniming-sy0309-2">两数之和 III-数据结构设计</a></p>
<p>3.<a href="https://www.lintcode.com/problem/143/?utm_source=sc-zhihuniming-sy0309-2">排颜色</a></p>
<p>4.<a href="https://www.lintcode.com/problem/32/?utm_source=sc-zhihuniming-sy0309-2">最长子串覆盖</a></p>
<p>5.<a href="https://www.lintcode.com/problem/891/?utm_source=sc-zhihuniming-sy0309-2">有效回文</a></p>
<p>6.<a href="https://www.lintcode.com/problem/102/?utm_source=sc-zhihuniming-sy0309-2">带环链表</a></p>
<p>7.<a href="https://www.lintcode.com/problem/144/?utm_source=sc-zhihuniming-sy0309-2">交错正负数</a></p>
<p>8.<a href="https://www.lintcode.com/problem/59/?utm_source=sc-zhihuniming-sy0309-2">最接近的三数之和</a></p>
<p>9.<a href="https://www.lintcode.com/problem/58/?utm_source=sc-zhihuniming-sy0309-2">四数之和</a></p>
<p>10.<a href="https://www.lintcode.com/problem/363/?utm_source=sc-zhihuniming-sy0309-2">接雨水</a></p>
<p><strong>宽度优先搜索，考察频率高，但实现不难，刷这7道题：</strong></p>
<p>1.<a href="https://www.lintcode.com/problem/433/?utm_source=sc-zhihuniming-sy0309-2">岛屿的个数</a></p>
<p>2.<a href="https://www.lintcode.com/problem/605/?utm_source=sc-zhihuniming-sy0309-2">序列重构</a></p>
<p>3.<a href="https://www.lintcode.com/problem/127/?utm_source=sc-zhihuniming-sy0309-2">拓扑排序</a></p>
<p>4.<a href="https://www.lintcode.com/problem/615/?utm_source=sc-zhihuniming-sy0309-2">课程表</a></p>
<p>5.<a href="https://www.lintcode.com/problem/151/?utm_source=sc-zhihuniming-sy0309-2">买卖股票的最佳时期</a></p>
<p>6.<a href="https://www.lintcode.com/problem/616/?utm_source=sc-zhihuniming-sy0309-2">安排课程</a></p>
<p>7.<a href="https://www.lintcode.com/problem/45/?utm_source=sc-zhihuniming-sy0309-2">最大子数组差</a></p>
<p><strong>深度优先搜索，考察频率高，主要是考察递归会不会写。</strong></p>
<p>1.<a href="https://www.lintcode.com/problem/17/?utm_source=sc-zhihuniming-sy0309-2">子集</a></p>
<p>2.<a href="https://www.lintcode.com/problem/178/?utm_source=sc-zhihuniming-sy0309-2">图是否是树</a></p>
<p>3.<a href="https://www.lintcode.com/problem/138/?utm_source=sc-zhihuniming-sy0309-2">子数组之和</a></p>
<p>4.<a href="https://www.lintcode.com/problem/425/?utm_source=sc-zhihuniming-sy0309-2">电话号码的字母组合</a></p>
<p>5.<a href="https://www.lintcode.com/problem/90/?utm_source=sc-zhihuniming-sy0309-2">K数和</a></p>
<p>6.<a href="https://www.lintcode.com/problem/652/?utm_source=sc-zhihuniming-sy0309-2">因式分解</a></p>
<p><strong>分治法，考察频率中等，一般和二叉树一起出现和考察，题一般不难。</strong></p>
<p>1.<a href="https://www.lintcode.com/problem/17/?utm_source=sc-zhihuniming-sy0309-2">子集</a></p>
<p>2.<a href="https://www.lintcode.com/problem/31/?utm_source=sc-zhihuniming-sy0309-2">数组划分</a></p>
<p>3.<a href="https://www.lintcode.com/problem/95/?utm_source=sc-zhihuniming-sy0309-2">验证二叉查找树</a></p>
<p>4.<a href="https://www.lintcode.com/problem/15/?utm_source=sc-zhihuniming-sy0309-2">全排列</a></p>
<p>5.<a href="https://www.lintcode.com/problem/137/?utm_source=sc-zhihuniming-sy0309-2">克隆图</a></p>
<p>6.<a href="https://www.lintcode.com/problem/143/?utm_source=sc-zhihuniming-sy0309-2">排颜色</a></p>
<p>7.<a href="https://www.lintcode.com/problem/138/?utm_source=sc-zhihuniming-sy0309-2">子数组之和</a></p>
<p><strong>哈希表，原理和应用都需要掌握，而且需要掌握代码实现。</strong></p>
<p>1.<a href="https://www.lintcode.com/problem/two-sum/?utm_source=sc-zhihuniming-sy0309-2">两数之和</a></p>
<p>2.<a href="https://www.lintcode.com/problem/longest-palindrome/?utm_source=sc-zhihuniming-sy0309-2">最长回文串</a></p>
<p>3.<a href="https://www.lintcode.com/problem/intersection-of-two-arrays/?utm_source=sc-zhihuniming-sy0309-2">两数组的交集</a></p>
<p>4.<a href="https://www.lintcode.com/problem/first-unique-number-in-data-stream/?utm_source=sc-zhihuniming-sy0309-2">数据流中第一个唯一的数字</a></p>
<p>5.<a href="https://www.lintcode.com/problem/two-sum-ii-input-array-is-sorted/?utm_source=sc-zhihuniming-sy0309-2">两数和 II-输入已排序的数组</a></p>
<p><strong>堆，经常会用到，原理必须掌握。高频。</strong></p>
<p>1.<a href="http://lintcode.com/problem/4/?utm_source=sc-zhihuniming-sy0309-2">丑数</a></p>
<p>2.<a href="https://www.lintcode.com/problem/130/?utm_source=sc-zhihuniming-sy0309-2">堆化</a></p>
<p>3.<a href="https://www.lintcode.com/problem/360/?utm_source=sc-zhihuniming-sy0309-2">滑动窗口的中位数</a></p>
<p>4.<a href="https://www.lintcode.com/problem/131/?utm_source=sc-zhihuniming-sy0309-2">大楼轮廓</a></p>
<p>5.<a href="https://www.lintcode.com/problem/518/?utm_source=sc-zhihuniming-sy0309-2">超级丑数</a></p>
<p>6.<a href="https://www.lintcode.com/problem/964/?utm_source=sc-zhihuniming-sy0309-2">食物集合</a></p>
<p>7.<a href="https://www.lintcode.com/problem/808/?utm_source=sc-zhihuniming-sy0309-2">影际网络</a></p>
<p><strong>贪心，考得不多，但起码要会用。</strong></p>
<p>1.<a href="https://www.lintcode.com/problem/919/?utm_source=sc-zhihuniming-sy0309-2">会议室</a></p>
<p>2.<a href="https://www.lintcode.com/problem/602/?utm_source=sc-zhihuniming-sy0309-2">俄罗斯套娃信封</a></p>
<p>3.<a href="https://www.lintcode.com/problem/304/?utm_source=sc-zhihuniming-sy0309-2">最大乘积</a></p>
<p>4.<a href="https://www.lintcode.com/problem/187/?utm_source=sc-zhihuniming-sy0309-2">加油站</a></p>
<p>5.<a href="https://www.lintcode.com/problem/45/?utm_source=sc-zhihuniming-sy0309-2">最大子数组差</a></p>
<p><strong>链表，中小公司考得多，大公司近年来考得少。题目一般不难，主要考察Reference。</strong></p>
<p>1.<a href="https://www.lintcode.com/problem/104/?utm_source=sc-zhihuniming-sy0309-2">合并k个排序链表</a></p>
<p>2.<a href="https://www.lintcode.com/problem/685/?utm_source=sc-zhihuniming-sy0309-2">数据流中第一个唯一的数字</a></p>
<p>3.<a href="https://www.lintcode.com/problem/102/?utm_source=sc-zhihuniming-sy0309-2">带环链表</a></p>
<p>4.<a href="https://www.lintcode.com/problem/170/?utm_source=sc-zhihuniming-sy0309-2">旋转链表</a></p>
<p>5.<a href="https://www.lintcode.com/problem/380/?utm_source=sc-zhihuniming-sy0309-2">两个链表的交叉</a></p>
<p>6.<a href="https://www.lintcode.com/problem/450/?utm_source=sc-zhihuniming-sy0309-2">K组翻转链表</a></p>
<p><strong>线段树，不太考。但当有的题目存在多种解法的时候，线段树可以帮忙降低思考难度。</strong></p>
<p>1.<a href="https://www.lintcode.com/problem/201/?utm_source=sc-zhihuniming-sy0309-2">线段树的构造</a></p>
<p>2.<a href="https://www.lintcode.com/problem/202/?utm_source=sc-zhihuniming-sy0309-2">线段树的查询</a></p>
<p>3.<a href="https://www.lintcode.com/problem/207/?utm_source=sc-zhihuniming-sy0309-2">区间求和</a></p>
<p>4.<a href="https://www.lintcode.com/problem/205/?utm_source=sc-zhihuniming-sy0309-2">区间最小数</a></p>
<p>5.<a href="https://www.lintcode.com/problem/1063/?utm_source=zhihuniming-sy0309-2">我的日历</a></p>
<p>6.<a href="https://www.lintcode.com/problem/290/?utm_source=sc-zhihuniming-sy0309-2">排序方案</a></p>
<p>7.<a href="https://www.lintcode.com/problem/998/?utm_source=sc-zhihuniming-sy0309-2">构造队列</a></p>
<p>8.<a href="https://www.lintcode.com/problem/1450/?utm_source=sc-zhihuniming-sy0309-2">矩形面积</a></p>
<p><strong>③面试前，按公司ladder刷题</strong></p>
<hr>
<p>在准备面试前，我建议直接刷目标公司的高频题。熟悉这些公司的常考题、出题风格，会比漫无目的地乱刷效率高很多。</p>
<p><strong>阿里巴巴：</strong></p>
<p><a href="https://www.lintcode.com/problem/bull-cards/?utm_source=sc-zhihuniming-sy0309-2">牛牌</a></p>
<p><a href="https://www.lintcode.com/problem/split-concatenated-strings/?utm_source=sc-zhihuniming-sy0309-2">连接字符串</a></p>
<p><a href="https://www.lintcode.com/problem/split-array-with-equal-sum/?utm_source=sc-zhihuniming-sy0309-2">同和分割数组</a></p>
<p><a href="https://www.lintcode.com/problem/valid-parenthesis-string/?utm_source=sc-zhihuniming-sy0309-2">有效的括号字符串</a></p>
<p><a href="https://www.lintcode.com/problem/path-sum-iv/?utm_source=sc-zhihuniming-sy0309-2">路径和</a></p>
<p><a href="https://www.lintcode.com/problem/array-score/?utm_source=sc-zhihuniming-sy0309-2">数组评分</a></p>
<p><strong>字节跳动：</strong></p>
<p><a href="https://www.lintcode.com/problem/delete-char/?utm_source=sc-zhihuniming-sy0309-2">删除字符</a></p>
<p><a href="https://www.lintcode.com/problem/longest-increasing-path-in-a-matrix/?utm_source=sc-zhihuniming-sy0309-2">矩阵中的最长递增路径</a></p>
<p><a href="https://www.lintcode.com/problem/restorearray/?utm_source=sc-zhihuniming-sy0309-2">恢复数组</a></p>
<p><a href="https://www.lintcode.com/problem/food-set/?utm_source=sc-zhihuniming-sy0309-2">食物组合</a></p>
<p><a href="https://www.lintcode.com/problem/combine-new-numbers/?utm_source=sc-zhihuniming-sy0309-2">组合新数字</a></p>
<p><a href="https://www.lintcode.com/problem/maximum-points-set/?utm_source=sc-zhihuniming-sy0309-2">最大点的集合</a></p>
<p><strong>腾讯：</strong></p>
<p><a href="https://www.lintcode.com/problem/minimum-rest-days/?utm_source=sc-zhihuniming-sy0309-2">最短休息日</a></p>
<p><a href="https://www.lintcode.com/problem/decrypt-the-string/?utm_source=sc-zhihuniming-sy0309-2">解压字符串</a></p>
<p><a href="https://www.lintcode.com/problem/median-ii/?utm_source=sc-zhihuniming-sy0309-2">中位数</a></p>
<p><a href="https://www.lintcode.com/problem/remove-boxes/?utm_source=sc-zhihuniming-sy0309-2">移除箱子</a></p>
<p><a href="https://www.lintcode.com/problem/minimum-factorization/?utm_source=sc-zhihuniming-sy0309-2">最小分解</a></p>
<p><a href="https://www.lintcode.com/problem/song-time/?utm_source=sc-zhihuniming-sy0309-2">歌曲时间</a></p>
<p><strong>百度：</strong></p>
<p><a href="https://www.lintcode.com/problem/arithmetic-slices/?utm_source=sc-zhihuniming-sy0309-2">等差切片</a></p>
<p><a href="https://www.lintcode.com/problem/zuma-game/?utm_source=sc-zhihuniming-sy0309-2">祖玛游戏</a></p>
<p><a href="https://www.lintcode.com/problem/game-of-life/?utm_source=sc-zhihuniming-sy0309-2">生命游戏</a></p>
<p><a href="https://www.lintcode.com/problem/longest-substring-with-at-least-k-repeating-characters/?utm_source=sc-zhihuniming-sy0309-2">字符至少出现K次的最长子串</a></p>
<p><a href="https://www.lintcode.com/problem/integer-replacement/?utm_source=sc-zhihuniming-sy0309-2">整数替换</a></p>
<p><a href="https://www.lintcode.com/problem/split-array-largest-sum/?utm_source=sc-zhihuniming-sy0309-2">拆分子数组</a></p>
<p><strong>美团：</strong></p>
<p><a href="https://www.lintcode.com/problem/test-strategy/?utm_source=sc-zhihuniming-sy0309-2">考试策略</a></p>
<p><a href="https://www.lintcode.com/problem/string-partition/?utm_source=sc-zhihuniming-sy0309-2">字符串划分</a></p>
<p><a href="https://www.lintcode.com/problem/xorsum-of-interval-extremum/?utm_source=sc-zhihuniming-sy0309-2">区间极值异或</a></p>
<p><a href="https://www.lintcode.com/problem/the-months-days/?utm_source=sc-zhihuniming-sy0309-2">月份天数</a></p>
<p><a href="https://www.lintcode.com/problem/associated-query/?utm_source=sc-zhihuniming-sy0309-2">关联查询</a></p>
<p><a href="https://www.lintcode.com/problem/character-deletion/?utm_source=sc-zhihuniming-sy0309-2">字符删除</a></p>
<p>Google</p>
<p><a href="https://www.lintcode.com/problem/kth-largest-element/?utm_source=sc-zhihuniming-sy0309-2">第k大元素</a></p>
<p><a href="https://www.lintcode.com/problem/lru-cache/?utm_source=sc-zhihuniming-sy0309-2">LRU缓存策略</a></p>
<p><a href="https://www.lintcode.com/problem/graph-valid-tree/?utm_source=sc-zhihuniming-sy0309-2">图是否是树</a></p>
<p><a href="https://www.lintcode.com/problem/sequence-reconstruction/?utm_source=sc-zhihuniming-sy0309-2">序列重构</a></p>
<p><a href="https://www.lintcode.com/problem/word-break/?utm_source=sc-zhihuniming-sy0309-2">单词拆分 I</a></p>
<p><a href="https://www.lintcode.com/problem/longest-substring-with-at-most-k-distinct-characters/?utm_source=sc-zhihuniming-sy0309-2">最多有k个不同字符的最长子字符串</a></p>
<p><strong>Facebook</strong></p>
<p><a href="https://www.lintcode.com/problem/3sum/?utm_source=sc-zhihuniming-sy0309-2">三数之和</a></p>
<p><a href="https://www.lintcode.com/problem/sort-colors/?utm_source=sc-zhihuniming-sy0309-2">颜色分类</a></p>
<p><a href="https://www.lintcode.com/problem/word-ladder/?utm_source=sc-zhihuniming-sy0309-2">单词接龙</a></p>
<p><a href="https://www.lintcode.com/problem/validate-binary-search-tree/?utm_source=sc-zhihuniming-sy0309-2">验证二叉查找树</a></p>
<p><a href="https://www.lintcode.com/problem/search-in-rotated-sorted-array/?utm_source=sc-zhihuniming-sy0309-2">搜索旋转排序数组</a></p>
<p><strong>Microsoft</strong></p>
<p><a href="https://www.lintcode.com/problem/best-time-to-buy-and-sell-stock/?utm_source=sc-zhihuniming-sy0309-2">买卖股票的最佳时机</a></p>
<p><a href="https://www.lintcode.com/problem/sliding-window-maximum/?utm_source=sc-zhihuniming-sy0309-2">滑动窗口的最大值</a></p>
<p><a href="https://www.lintcode.com/problem/binary-tree-zigzag-level-order-traversal/?utm_source=sc-zhihuniming-sy0309-2">二叉树的锯齿形层次遍历</a></p>
<p><a href="https://www.lintcode.com/problem/intersection-of-two-linked-lists/?utm_source=sc-zhihuniming-sy0309-2">两个链表的交叉</a></p>
<p><a href="https://www.lintcode.com/problem/copy-list-with-random-pointer/?utm_source=sc-zhihuniming-sy0309-2">复制带随机指针的链表</a></p>
<p><strong>Amazon</strong></p>
<p><a href="https://www.lintcode.com/problem/627/?utm_source=sc-zhihuniming-sy0309-2">最长回文串</a></p>
<p><a href="https://www.lintcode.com/problem/615/?utm_source=sc-zhihuniming-sy0309-2">课程表</a></p>
<p><a href="https://www.lintcode.com/problem/384/?utm_source=sc-zhihuniming-sy0309-2">最长无重复字符的子串</a></p>
<p><a href="https://www.lintcode.com/problem/616/?utm_source=sc-zhihuniming-sy0309-2">安排课程</a></p>
<p><a href="https://www.lintcode.com/problem/1565/?utm_source=sc-zhihuniming-sy0309-2">飞行棋</a></p>
<p><a href="https://www.lintcode.com/problem/380/?utm_source=sc-zhihuniming-sy0309-2">两个链表的交叉</a></p>
<p><strong>领英</strong></p>
<p><a href="https://www.lintcode.com/problem/392/?utm_source=sc-zhihuniming-sy0309-2">打劫房屋</a></p>
<p><a href="https://www.lintcode.com/problem/645/?utm_source=sc-zhihuniming-sy0309-2">识别名人</a></p>
<p><a href="https://www.lintcode.com/problem/1360/?utm_source=sc-zhihuniming-sy0309-2">对称树</a></p>
<p><a href="https://www.lintcode.com/problem/588/?utm_source=sc-zhihuniming-sy0309-2">划分和相等的子集</a></p>
<p><a href="https://www.lintcode.com/problem/859/?utm_source=sc-zhihuniming-sy0309-2">最大栈</a></p>
<p><strong>Apple</strong></p>
<p><a href="https://www.lintcode.com/problem/363/?utm_source=sc-zhihuniming-sy0309-2">接雨水</a></p>
<p><a href="http://lintcode.com/problem/413/?utm_source=sc-zhihuniming-sy0309-2">反转整数</a></p>
<p><a href="https://www.lintcode.com/problem/1270/?utm_source=sc-zhihuniming-sy0309-2">勒索信</a></p>
<p><a href="https://www.lintcode.com/problem/1352/?utm_source=sc-zhihuniming-sy0309-2">比较版本号</a></p>
<p><a href="https://www.lintcode.com/problem/1355/?utm_source=sc-zhihuniming-sy0309-2">杨辉三角</a></p>
<p><a href="https://www.lintcode.com/problem/1532/?utm_source=sc-zhihuniming-sy0309-2">序列化和反序列N叉树</a></p>
<hr>
<h3 id="0002-求中点">00.02 求中点</h3>
<hr>
<ul>
<li>
<pre><code class="language-java">int mid = left + ((right-left) &gt;&gt; 1);	//(L+R)/2
//防止溢出 a&gt;&gt;1 相当于a/2  使用位运算 速度更快
</code></pre>
</li>
</ul>
<h3 id="0003-函数返回新建数组">00.03 函数返回新建数组</h3>
<hr>
<pre><code class="language-java">return new int[] {less+1 ,more-1};
</code></pre>
<h3 id="0004-打印数组">00.04 打印数组</h3>
<hr>
<pre><code class="language-java">System.out.println(Arrays.toString(nums)); //打印结果为[1,2,3,4,]
</code></pre>
<h3 id="0005-int与integer互转">00.05 int[]与Integer[]互转</h3>
<hr>
<pre><code class="language-java">import java.util.stream.IntStream;
import java.util.stream.Stream;

// int[]nums 转化为Integer[] 数组
Integer[] integers = Arrays.stream(nums).boxed().toArray(Integer[]::new);
//转化为int[] 数组
int[] nums = Arrays.stream(integers).mapToInt(Integer::valueOf).toArray();

// 解释
//将int数组转换为Integer数组
int[] nums = {1,2,3};
//先将int数组转换为数值流
IntStream stream = Arrays.stream(nums);
//流中的元素全部装箱，转换为流 ----&gt;int转为Integer
Stream&lt;Integer&gt; integerStream = stream.boxed();
//将流转换为数组
Integer[] integers = integerStream.toArray(Integer[]::new);
</code></pre>
<h3 id="0006-int-与-listnode转换">00.06 int[] 与 ListNode转换</h3>
<hr>
<pre><code class="language-java">public class ListNode{
    int val;
    ListNode next=null;
    ListNode(int val) {
        this.val=val;
    }
}
    // 将Integer[] nums转为ListNode
public static ListNode arrayToListNode(Integer[] nums) {
    ListNode head= new  ListNode(nums[0]);
    ListNode oher = head;	//暂存头节点 避免丢失
    for(int i=1;i&lt;nums.length;i++) {
        ListNode temp = new ListNode(nums[i]); //借助中间temp实现
		other.next=temp;     //将other下一节点指向新生节点temp
        other=temp;			//将other后移 指向最后一个节点
    }
    return head;	//找回头节点    
}

	//将ListNode转化为int[] nums
public static int[] 
</code></pre>
<h3 id="0007-int-nums中最小的k数大根堆partition">00.07 int[] nums中最小的k数—大根堆/partition</h3>
<ul>
<li>复杂度：O(NlogK) + O(K)</li>
<li>特别适合处理海量数据</li>
</ul>
<p>维护一个大小为 K 的最小堆过程如下：使用大顶堆。在添加一个元素之后，如果大顶堆的大小大于 K，那么将大顶堆的堆顶元素去除，也就是将当前堆中值最大的元素去除，从而使得留在堆中的元素都比被去除的元素来得小。</p>
<p>应该使用大顶堆来维护最小堆，而不能直接创建一个小顶堆并设置一个大小，企图让小顶堆中的元素都是最小元素。</p>
<p>Java 的 PriorityQueue 实现了堆的能力，PriorityQueue 默认是小顶堆，可以在在初始化时使用 Lambda 表达式 (o1, o2) -&gt; o2 - o1 来实现大顶堆。</p>
<p><code>lambda(o1,o2)-&gt;o2-o1</code> <code>Comparator.reverseOrder()</code></p>
<pre><code class="language-java">public ArrayList&lt;Integer&gt; getLeastNumbers(int[] nums, int k) {
    if(k&gt;nums.length||k&lt;1) {
        return new ArrayList&lt;&gt;();
    }
    // 使用lambda表达式
    PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((o1,o2)-&gt;o2-o1);
    // 使用Comparator
    priorityQueue&lt;Integer. maxHeap = new PriorityQueue&lt;&gt;(k,Comparator.reverseOrder());
    
    for(int num :nums) {
        if(maxHeap.size()&lt;k) {
            maxHeap.add(num);
        }else{
            if(maxHeap.peek()&gt;e) {
                maxHeap.poll();
                maxHeap.add(num);
            }
        }
    }
    return new ArrayList&lt;&gt;(maxHeap);
}
</code></pre>
<h3 id="0008-assert-断言">00.08 assert 断言</h3>
<p>IDEA中JVM设置自定义参数-ea后即可打开</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/v6WKwP.png" alt="v6WKwP" loading="lazy"></figure>
<pre><code class="language-java">assert [boolean//表达式]
</code></pre>
<p>只有当 表达式为真——&gt;继续执行后续代码否则终止执行并抛出<code>AssertionError</code></p>
<h3 id="009-两链表长度差值">0.09 两链表长度差值</h3>
<p>一个变量即可实现</p>
<pre><code class="language-java">int cnt = 0;
while (cur1!=null) {
    cnt++; //遍历第一个链表时++
    cur1=cur1.next;
}
while (cur2!=null) {
    cnt--;	//遍历第二个链表时--
    cur2=cur2.next;
}
cnt = Math.abs(cnt);	// 二链表长&gt;一链表长时cnt&lt;0 
</code></pre>
<h3 id="010-堆化">0.10 堆化</h3>
<p>O(N)</p>
<pre><code class="language-java">    PriorityQueue&lt;Integer&gt; minheap = new PriorityQueue&lt;&gt;();		 // 默认最小堆    PriorityQueue&lt;Integer&gt; maxheap = new PriorityQueue&lt;&gt;(Collections.reverseOrder());//    minheap.add();//    peek() 查看堆顶元素//    poll() 弹出堆顶元素并删除//    size() 堆的大小
</code></pre>
<h3 id="011-arraylist-与-int转换">0.11 ArrayList 与 int[]转换</h3>
<pre><code class="language-java">int[] res = integers.stream().mapToInt(Integer::intValue).toArray();// 使用 stream流 和 方法引用
</code></pre>
<pre><code class="language-java">List&lt;Integer&gt; lists = Arrays.stream(res).boxed().collect(Collectors.toList());// 装箱
</code></pre>
<h3 id="012-统计出现的频率得到频率数组">0.12 统计出现的频率——&gt;得到频率数组</h3>
<pre><code class="language-java">Map&lt;Integer, Integer&gt; frequents = new HashMap&lt;&gt;();
for (int num:
     nums) {
    frequents.put(num,frequents.getOrDefault(num,0)+1)
}
// 将 Map 转换为 Set
Set&lt;Map.Entry&lt;Integer,Integer&gt;&gt; entries = frequents.entrySet();
</code></pre>
<h3 id="013-最短子串">0.13 最短子串</h3>
<p>找到 minwindow 的 len 同时记住起始的left 即可</p>
<p>​	使用 substring(left,left+resLen)</p>
<h2 id="01-排序">01 排序</h2>
<ul>
<li>
<p>**排序的稳定性: **</p>
<p>意义: 保留业务数据中的原始信息 不被抹去(两次排序中第二次排序可以保留第一次排序后结果)</p>
<ul>
<li>在原序列中相同值的原始相对次序位置不变</li>
<li>冒泡、插入(数据量小60的时候均适用、因为常数项低 )、归并、桶排序、计数排序、基数排序</li>
<li>快排不稳定——&gt;partition随机选择分割</li>
<li>堆排不稳定——&gt;</li>
</ul>
</li>
<li>
<p><strong>工程中综合排序:</strong></p>
<ul>
<li>基本数据类型——&gt;快排</li>
<li>自定义类——&gt;归并</li>
<li>小样本——&gt;插入</li>
</ul>
</li>
<li>
<p><strong>比较器的使用:</strong></p>
<ul>
<li>
<p>利用系统提供的Arrays.sort(nums, new comparator()) 实现排序 相当于c中的sort 的第二个参数实现</p>
</li>
<li>
<p>无comparator的实现默认按照nums的内存地址排序</p>
<pre><code class="language-java">// 继承Comparator&lt;&gt;接口 重写这个比较的Compare()函数

public static class AgeAscendingComparator implements Comparator&lt;Student&gt; {

	@Override
	public int compare(Student o1, Student o2) {
		return o1.age - o2.age;
	}
}
Arrays.sort(students, new IdAscendingComparator());
// 无返回值
</code></pre>
</li>
<li>
<p>利用系统的 **优先级队列PriorityQueue&lt;&gt;**实现堆排序 **add() poll()**方法分别实现建堆和弹出堆头</p>
</li>
<li>
<p>利用系统的 **TreeSetp&lt;&gt; **实现红黑树</p>
</li>
</ul>
</li>
</ul>
<p>常见基于比较的排序方法性能汇总表</p>
<table>
<thead>
<tr>
<th>排序方法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>选择</td>
<td>N<sup>2</sup></td>
<td>1</td>
<td>no</td>
</tr>
<tr>
<td>冒泡</td>
<td>N<sup>2</sup></td>
<td>1</td>
<td>yes</td>
</tr>
<tr>
<td>插入</td>
<td>N<sup>2</sup></td>
<td>1</td>
<td>yes</td>
</tr>
<tr>
<td>归并</td>
<td>N*logN</td>
<td>N</td>
<td>yes</td>
</tr>
<tr>
<td>快排</td>
<td>N*logN</td>
<td>logN</td>
<td>no</td>
</tr>
<tr>
<td>堆</td>
<td>N*logN</td>
<td>1</td>
<td>no</td>
</tr>
</tbody>
</table>
<p><strong>常见注意事项：</strong></p>
<ol>
<li>“原定归并排序”会让时间复杂度上升到 N<sup>2</sup> 不实用；</li>
<li>工程上在小数量样本下，使用插入排序进行综合排序利用 NLogN和 N<sup>2</sup>的优势；</li>
<li></li>
</ol>
<p>快排的常数项实践下来最快</p>
<h3 id="0101-快排">01.01 快排</h3>
<p>思想: 荷兰国旗问题——&gt;在左右区间内再次荷兰国旗划分</p>
<img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/Zq7KoU.png" alt="Zq7KoU" style="zoom: 50%;" />
<pre><code class="language-java">public static int[] partition(int[] arr, int l, int r, int p) {	int less = l - 1; //小于p的区域的下标最大值边界	int more = r + 1; //大于p的区域下标最小值边界	while (l &lt; more) {		if (arr[l] &lt; p) {			swap(arr, ++less, l++);		} else if (arr[l] &gt; p) {			swap(arr, --more, l);		} else {			l++;		}	}	return new int[] { less + 1, more - 1 };	//返回等于区域的数组下标范围}public static int[] swap(int[] arr, int i, int j) {    int temp = arr[i];    arr[i] = arr[j];    arr[j] = temp;    return arr;}
</code></pre>
<ul>
<li>
<p>经典快排</p>
<ul>
<li>
<p>以数组最后一个数作为基准 重复荷兰国旗划分</p>
<pre><code class="language-java">public static void quickSort(int[] arr) {	if (arr == null || arr.length &lt; 2) {		return;	}	quickSort(arr, 0, arr.length - 1);}public static void quickSort(int[] arr, int l, int r) {	if (l &lt; r) {		swap(arr, l + (int) (Math.random() * (r - l + 1)), r);		int[] p = partition(arr, l, r);        //经典快排的改进——&gt;对于等于选择基点的区域不参与递归排序		quickSort(arr, l, p[0] - 1);		quickSort(arr, p[1] + 1, r);	}}public static int[] partition(int[] arr, int l, int r) {	int less = l - 1;	int more = r;	while (l &lt; more) {		if (arr[l] &lt; arr[r]) {			swap(arr, ++less, l++);		} else if (arr[l] &gt; arr[r]) {			swap(arr, --more, l);		} else {			l++;		}	}	swap(arr, more, r);	return new int[] { less + 1, more };}public static void swap(int[] arr, int i, int j) {	int tmp = arr[i];	arr[i] = arr[j];	arr[j] = tmp;}
</code></pre>
</li>
<li>
<p>问题:  大于和小于基准的区域大小不相等(总拿数组最后一个数作为基准 最坏情况下会是O(N^2)) 与数据状态息息相关</p>
</li>
</ul>
</li>
<li>
<p>随机快排: 使得概率事件 使用长期期望方式算出时间复杂度 <strong>O(N*logN)</strong> 随机快排的空间复杂度O(logN)</p>
<ul>
<li>
<pre><code class="language-java">swap(arr, L + (int) (Math.random()*(R - L + 1)), R);// L-R上等概率的随机选择一个数将其与最后一个数交换 使得函数结构上复用 //hash也可以
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="0102-堆排序">01.02 堆排序</h3>
<ul>
<li>
<p>完全二叉树: 依次在下一层按照顺序从左到右补齐</p>
<ul>
<li>
<p>堆可以用数组来实现  又称为<strong>优先级队列</strong></p>
<ul>
<li>数组与完全二叉树之间的转换:</li>
<li>数组中位置i的左孩子的下标为<code>2*i+1</code> 右孩子为<code>2*i+2</code>  父节点的对应下标为<code>(i-1)/2</code>  0的父节点为0</li>
</ul>
</li>
<li>
<p><strong>堆的理解</strong>: 完全二叉树</p>
<ul>
<li>
<p>大根堆——&gt;完全二叉树中任何一个子树的最大值都是头部</p>
<ul>
<li>
<p>建立: 遍历数组, 与其父节点比较直至到根节点, 过程中自己比父节点的值大则swap 若小/等则跳出向上比较的循环 与现有的树高度有关h O(logN)</p>
<p>建立过程中的复杂度：</p>
</li>
<li>
<p>调整:  下沉 heapify() 不断与孩子中的最大值比较</p>
</li>
<li>
<pre><code class="language-java">	public static void heapify(int[] arr, int index, int size) {  		int left = index * 2 + 1;  		while (left &lt; size) {  			//这里是右孩子存在&amp;&amp;右孩子大于左孩子的值情况下选择left+1 否则都是left  			int largest = left + 1 &lt; size &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left;  			// 比较与我待查本身的值  			largest = arr[largest] &gt; arr[index] ? largest : index;  			if (largest == index) {  				break;  			}  			swap(arr, largest, index);  			// while循环继续的增量条件  			index = largest;  			left = index * 2 + 1;  		}  	}
</code></pre>
</li>
</ul>
</li>
<li>
<p>小根堆——&gt;任何一个子树的最小值都是其头部</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="0103-非基于比较的排序">01.03 非基于比较的排序</h3>
<hr>
<p>一种数据状况出现的词频</p>
<h4 id="桶排序">桶排序</h4>
<h3 id="0104-bubbleinsertsortselectsort">01.04 Bubble+InsertSort+SelectSort</h3>
<ul>
<li>
<p><code>BubbleSort</code></p>
<ul>
<li>
<p>逐个比较 最值上浮——&gt;则外围循环为从右到左 使得j+1与j比较得到最值上浮</p>
<pre><code class="language-java">public static void BubbleSort(int[] nums) {    if (nums == null || nums.length &lt; 2) {        return;    }    for (int i = nums.length - 1; i &gt; 0; i--) {        for (int j = 0; j &lt; i; j++) {            if (nums[j] &gt; nums[j + 1]) {                swap(nums, j, j + 1);            }        }    }}
</code></pre>
</li>
</ul>
</li>
<li>
<p><code>InsertSort</code></p>
<ul>
<li>
<p>的</p>
<pre><code class="language-java">public static void InsertionSort(int[] nums) {    if (nums==null||nums.length&lt;2) {        return;    }    for (int i = 1; i &lt; nums.length; i++) {        for (int j = i-1; j &gt;0; j--) {            if (nums[j]&gt;nums[j+1]) {                swap(nums,j,j+1);            }        }    }}
</code></pre>
</li>
</ul>
</li>
<li>
<p><code>SelectionSort</code></p>
<ul>
<li>
<p>a</p>
<pre><code class="language-java">public static void SelectionSort(int[] nums) {    if (nums == null || nums.length &lt; 2) {        return;    }    for (int i = 0; i &lt; nums.length - 1; i++) {        int minIndex = i;        for (int j = i + 1; j &lt; nums.length; j++) {            minIndex = nums[j] &lt; nums[minIndex] ? j : minIndex;        }        swap(nums, i, minIndex);    }}
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="02-stack-queue">02 Stack Queue</h2>
<h4 id="0201-队列实现栈结构">02.01 队列实现栈结构</h4>
<pre><code class="language-java">public static class TwoQueuesStack {
    private Queue&lt;Integer&gt; queue;
    private Queue&lt;Integer&gt; help;

    public TwoQueuesStack() {
        queue = new LinkedList&lt;Integer&gt;();
        help = new LinkedList&lt;Integer&gt;();
    }

    public void push(int pushInt) {
        queue.add(pushInt);
    }

    public int peek() {
        if (queue.isEmpty()) {
            throw new RuntimeExceptioan(&quot;Stack is empty!&quot;);
        }
        while (queue.size() != 1) {
            help.add(queue.poll());
        }
        int res = queue.poll();
        help.add(res);
        swap();
        return res;
    }

    public int pop() {
        if (queue.isEmpty()) {
            throw new RuntimeException(&quot;Stack is empty!&quot;);
        }
        while (queue.size() &gt; 1) {
            help.add(queue.poll());
        }
        int res = queue.poll();
        swap();
        return res;
    }

    private void swap() {
        Queue&lt;Integer&gt; tmp = help;
        help = queue;
        queue = tmp;
    }

}
</code></pre>
<h4 id="0202-栈实现队列结构">02.02 栈实现队列结构</h4>
<p>使用两个栈实现队列,支持队列的基本操作(add poll peek)</p>
<ul>
<li>stackPush向stackPop压入数据, 必须一次性将stackPush数据压入;</li>
<li>stackPop非空, 不可压入数据</li>
</ul>
<pre><code class="language-java">import java.util.Stack;

public class TwoStackWithQueue {

    public Stack&lt;Integer&gt; stackPush;
    public Stack&lt;Integer&gt; stackPop;
    public TwoStackWithQueue(){
        stackPop=new Stack&lt;Integer&gt;();
        stackPush=new Stack&lt;Integer&gt;();
    }

    //push栈向pop栈倒入数据
    private void pushTopop() {
        if(stackPop.empty()) {
            while (!stackPush.empty()) {
                stackPop.push(stackPush.pop());
            }
        }
    }
    public void add(int pushInt) {
        stackPush.push(pushInt);
        pushTopop();
    }

    public int poll() {
        if(stackPop.empty()&amp;&amp;stackPush.empty()) {
            throw new RuntimeException(&quot;Queue is empty!&quot;);
        }
        pushTopop();
        return stackPop.pop();
    }

    public int peek() {
        if(stackPop.empty()&amp;&amp;stackPush.empty()) {
            throw new RuntimeException(&quot;Queue is empty!&quot;);
        }
        pushTopop();
        return stackPop.peek();
    }
}

</code></pre>
<h2 id="03-链表">03 链表</h2>
<pre><code class="language-java">public class ListNode{
    int val;
    ListNode next = null;
    
    ListNode(int val) {
        this.val = val;
    }
}
</code></pre>
<p>回文链表</p>
<ul>
<li>快慢指针,当快指针到链尾即慢指针到链中。慢指针继续遍历的下一半链表不断入栈, 入完后弹出与前半比较;</li>
<li>不用辅助空间</li>
</ul>
<p>访问 搜索 插入 删除</p>
<pre><code class="language-java">private ListNode reverseListNode (ListNode head) {
    ListNode cur =head;
    ListNode prev =null;
    while (cur != null) {
        ListNode next = cur.Next;
        cur.Next=prev;
        prev=cur;
        cur=next;
    }
    return prev;
}
</code></pre>
<h3 id="0301-数组与链表的转化">03.01 数组与链表的转化</h3>
<pre><code class="language-java">ListNode listNode = new ListNode(Arrays.asList(arry));
</code></pre>
<h3 id="0302-链表环">03.02 链表环</h3>
<ul>
<li>
<p><strong>找环思路</strong></p>
<ul>
<li>快慢分别走 直到两只相遇</li>
<li>其中快指针回到头结点 以正常步伐+1 与慢指针同步走 直到两者相遇</li>
<li>相遇结点即为头结点</li>
</ul>
</li>
<li>
<p>**两表首个公共结点思路: **</p>
<ul>
<li>先判断是否有环 Ring  成环必然在环处开始重合</li>
<li>无环则 长链表走两表长度差值 gap 步伐  再长短链表指针同步走直到相遇 相遇点为首公共结点</li>
</ul>
</li>
</ul>
<h3 id="0303-两表长度差值一个变量">03.03 两表长度差值—一个变量</h3>
<p>一个变量即可实现</p>
<pre><code class="language-java">int cnt = 0;
while (cur1!=null) {
    cnt++; //遍历第一个链表时++
    cur1=cur1.next;
}
while (cur2!=null) {
    cnt--;	//遍历第二个链表时--
    cur2=cur2.next;
}
cnt = Math.abs(cnt);	// 二链表长&gt;一链表长时cnt&lt;0 
</code></pre>
<h2 id="04-二叉树">04 二叉树</h2>
<pre><code class="language-java">public static class TreeNode {	public int val;    public TreeNode left;    public TreeNode right;    public TreeNode(int val) {        this.val = val;    }}
</code></pre>
<h4 id="0401-递归遍历二叉树">04.01 递归遍历二叉树</h4>
<hr>
<p>三者访问访问二叉树的次序一致, 只是不同时机输出</p>
<pre><code class="language-java">// 先序递归遍历二叉树public static void preOrderRecur(TreeNode head) {    if(head == null) {        return;    }    System.out.print(head.val+&quot; &quot;);    preOrderRecur(head.left);    preOrderRecur(head.right);}// 中序递归遍历二叉树public static void preOrderRecur(TreeNode head) {    if(head == null) {        return;    }    preOrderRecur(head.left);    System.out.print(head.val+&quot; &quot;);    preOrderRecur(head.right);}// 后序递归遍历二叉树public static void preOrderRecur(TreeNode head) {    if(head == null) {        return;    }    preOrderRecur(head.left);    preOrderRecur(head.right);    System.out.print(head.val+&quot; &quot;);}// 三者访问访问二叉树的次序一致, 只是不同实际输出
</code></pre>
<h4 id="0402-非递归遍历二叉树">04.02 非递归遍历二叉树</h4>
<hr>
<p>递归本质上就是栈 由于二叉树提供节点只能向下访问 无法返回 故而使用栈结构实现返回</p>
<pre><code class="language-java">public static List&lt;Integer&gt; inOrderTraversalBT(TreeNode root) {    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();    //空树则直接返回null的res    if (root == null) {        return res;    }    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();    // 保存root    TreeNode cur = root;    while (cur != null || !stack.isEmpty()) {        // 向树的最左侧走 并不断压栈        while (cur != null) {            stack.push(cur);            cur = cur.left;        }        // 走完最左侧后弹栈顶        TreeNode node = stack.pop();        res.add(node.val);        // 往上层的右边去再重复找最左侧        cur = node.right;    }    return res;}public static List&lt;Integer&gt; preOrderTraversalBT(TreeNode root) {    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();    //空树则直接返回null的res    if (root == null) {        return res;    }    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();    // 保存root    TreeNode cur = root;    while (cur != null || !stack.isEmpty()) {        // 向树的最左侧走 并不断压栈入数组        while (cur != null) {            res.add(cur.val);            stack.push(cur);            cur = cur.left;        }        // 走完最左侧后弹栈顶 无须入组 cur循环内已经入组        TreeNode node = stack.pop();        // 往上层的右边去 再重复找最左侧        cur = node.right;    }    return res;}public static List&lt;Integer&gt; postOrderTraversalBT(TreeNode root) {    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();    //空树则直接返回null的res    if (root == null) {        return res;    }    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();    // 保存root    TreeNode cur = root;    while (cur != null || !stack.isEmpty()) {        // 向树的最右侧走 并不断压栈入数组        while (cur != null) {            res.add(cur.val);            stack.push(cur);            cur = cur.right; // 使得reverse后正常左在前        }        // 走完最右侧后弹栈顶 无须入组 cur循环内已经入组        TreeNode node = stack.pop();        // 往上层的左边去 再重复找最右侧        cur=node.left;    }    Collections.reverse(res);    return res;}
</code></pre>
<p><strong>后继节点:</strong> 二叉树的<em>中序遍历</em>中的下一节点</p>
<p>前驱节点: 二叉树的<em>中序遍历</em>的前一节点</p>
<h4 id="0403-查找后继节点">04.03 查找后继节点</h4>
<hr>
<ul>
<li>通过parent找到根节点 再中序遍历</li>
<li></li>
</ul>
<h4 id="0404-平衡二叉树">04.04 平衡二叉树</h4>
<hr>
<p>树中的任何一个节点其左右子树高度差在1以内</p>
<p>满二叉树一定是平衡二叉树</p>
<p>空树是平衡树</p>
<pre><code class="language-java">
</code></pre>
<h4 id="0404-搜索二叉树-bst">04.04 搜索二叉树 BST</h4>
<hr>
<p>二叉树中序遍历的结果是依次升序的 一般无重复节点</p>
<p>LC-99-recoverTree</p>
<p>​	两结点被错误交换 还原</p>
<pre><code class="language-java">// 非常妙的两个if 使得中序遍历的pre和node在不断比较大小找出错误的位置if (firstNode == null &amp;&amp; preNode.val &gt; node.val) {    firstNode = preNode;}if (firstNode != null &amp;&amp; preNode.val &gt; node.val) {    secondNode = node;}
</code></pre>
<blockquote>
<p>第一个节点，是第一个按照中序遍历时候前一个节点大于后一个节点，我们选取前一个节点，这里指节点 ；</p>
<p>第二个节点，是在第一个节点找到之后，后面出现前一个节点大于后一个节点，我们选择后一个节点，这里指节点 ；</p>
</blockquote>
<h4 id="0405-完全二叉树">04.05 完全二叉树</h4>
<hr>
<p><strong>判断</strong>标准二叉树按层遍历:</p>
<p>​	该节点有左孩子无右孩子; false</p>
<p>​	该节点有左孩子没有右孩子/两者都没有: 后面遇到的节点均为叶节点;</p>
<p>​</p>
<p>求完全二叉树节点个数:</p>
<p>满二叉树: 高度l 则节点个数<strong>2^l-1</strong></p>
<p>找出</p>
<h4 id="0406-重建二叉树">04.06 重建二叉树</h4>
<pre><code class="language-java">package Tree;import DataStructure.TreeNode;import java.util.Arrays;import static Tree._100_SameTree.isSameTree;public class _105_BuildTree {    /*     * 从前序和后序遍历结果构造二叉树     * */    public static void main(String[] args) {        TreeNode root = new TreeNode(1);        root.left = new TreeNode(2);        root.right = new TreeNode(3);        root.left.left = new TreeNode(4);        root.left.right = new TreeNode(5);        root.right.right = new TreeNode(7);        root.right.left = new TreeNode(6);        root.left.left.left = new TreeNode(8);        root.left.left.right = new TreeNode(9);        int[] preorder = {1, 2, 4, 8, 9, 5, 3, 6, 7};        int[] inorder = {8, 4, 9, 2, 5, 1, 6, 3, 7};        TreeNode root2 = buildTree(preorder, inorder);        System.out.println(isSameTree(root2, root));    }    public static TreeNode buildTree(int[] preorder, int[] inorder) {        if (preorder.length == 0) {            return null;        }        assert (preorder.length == inorder.length);        TreeNode root = new TreeNode(preorder[0]);        for (int i = 0; i &lt; preorder.length; i++) {            // 找到root在中序遍历数组中的位置            if (preorder[0] == inorder[i]) {                /*将前 中序遍历数组各分为两半*/                int[] preLeft = Arrays.copyOfRange(preorder, 1, i + 1);                int[] preRight = Arrays.copyOfRange(preorder, i + 1, preorder.length);                int[] inLeft = Arrays.copyOfRange(inorder, 0, i);                int[] inRight = Arrays.copyOfRange(inorder, i + 1, inorder.length);                // 递归处理左右两部分                root.left = buildTree(preLeft, inLeft);                root.right = buildTree(preRight, inRight);                break;            }        }        return root;    }}
</code></pre>
<pre><code class="language-java">public static TreeNode buildTree(int[] inorder, int[] postorder) {    if (inorder == null || postorder == null) {        return null;    }    return helper(inorder, postorder);}private static TreeNode helper(int[] in, int[] post) {    if (in.length == 0) {        return null;    }    //根据后序数组的最后一个元素，创建根节点    TreeNode root = new TreeNode(post[post.length - 1]);    //在中序数组中查找值等于【后序数组最后一个元素】的下标    for (int i = 0; i &lt; in.length; ++i) {        if (in[i] == post[post.length - 1]) {            //确定这个下标i后，将中序数组分成两部分，后序数组分成两部分            int[] inLeft = Arrays.copyOfRange(in, 0, i);            int[] inRight = Arrays.copyOfRange(in, i + 1, in.length);            int[] postLeft = Arrays.copyOfRange(post, 0, i);            int[] postRight = Arrays.copyOfRange(post, i, post.length - 1);            //递归处理中序数组左边，后序数组左边            root.left = helper(inLeft, postLeft);            //递归处理中序数组右边，后序数组右边            root.right = helper(inRight, postRight);            break;        }    }    return root;}
</code></pre>
<h2 id="05-lfu-lfu算法">05 <code>LFU &amp; LFU</code>算法</h2>
<p>https://mp.weixin.qq.com/s?__biz=MzA4NDE4MzY2MA==&amp;mid=2647524319&amp;idx=1&amp;sn=fdca85b7bb34d46e428a0d240f810811&amp;chksm=87d1bcdcb0a635caecf466761bcd224846f9fa93711c0da35115bb25ea904ddfb4b172389a2f&amp;mpshare=1&amp;scene=1&amp;srcid=0522hQRdOsdk14xOj8EYzGDY&amp;sharer_sharetime=1621651227490&amp;sharer_shareid=116ef760e9b961326f61bb96be400660#rd</p>
<blockquote></blockquote>
<h3 id="概念">概念</h3>
<p>LFU 算法即为 Least Frequently Used Algorithm 最不常用算法，发生缺页中断时选择访问次数最少的页面中断</p>
<p>LRU 算法即为 Least Recently Usef Algorithm 最近常用算法，缺页中断时优先最久没有访问的页面</p>
<blockquote>
<p>LRU 考察多久未访问，时间越短越好；</p>
<p>LFU 考虑访问频率，访问次数越多越好</p>
</blockquote>
<h3 id="question">Question</h3>
<blockquote>
<p>请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。</p>
<p>实现 LFUCache 类：</p>
<p><code>LFUCache(int capacity)</code> - 用 LFU 的容量 capacity 初始化对象<code>int get(int key)</code> - 如果键存在于缓存中，则获取键的值并返回，否则返回 -1。<code>void put(int key, int value)</code> - 如果键已存在，则更新其值；如果键不存在，请插入键值对。当缓存达到其容量时，则应该在插入新页之前，淘汰最不经常使用的页。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 <strong>最近最久未使用</strong> 的键。注意「项的使用次数」就是自插入该项以来对其调用 get 和 put 函数的次数之和。使用次数会在对应项被移除后置为 0 。</p>
<p>为了确定最不常使用的键，可以为缓存中的每个键维护一个 使用计数器 。使用计数最小的键是最久未使用的键。</p>
<p>当一个键首次插入到缓存中时，它的使用计数器被设置为 1 (由于 put 操作)。对缓存中的键执行 get 或 put 操作，使用计数器的值将会递增。</p>
</blockquote>
<h3 id="solution">Solution</h3>
<p>哈希算法+双向链表可以实现查找、插入删除均为 O(1)的数据结构</p>
<pre><code class="language-java">class Cache {    private Map&lt;Integer,Node&gt; cache;    public int get(int key) {}    public void put(int key, int value) {}    class DoublelinkedList {}}
</code></pre>
<h2 id="06-表">06 表</h2>
<h3 id="0601-概念">06.01 概念</h3>
<p><strong>哈希表：</strong></p>
<ol>
<li>使用可被视为集合结构 不允许重复</li>
<li>只有 <code>Key</code>使用 HashSet，有<code>Key &amp; Value</code>使用 HashMap 两者的底层结构实际一致</li>
<li>哈希表的增删改查可视为时间复杂度为<code>O(1)</code> 但常数时间较大 put remove put get</li>
<li>基础类型存放内部按值传递——&gt;占用大小为其本身；其他按引用传递，内存占用为其本身内存地址大小</li>
</ol>
<p><strong>有序表：</strong></p>
<ol>
<li>集合结构</li>
<li>TreeSet 和 TreeMap 结构表示，两者底层一致；有序（双向链表）</li>
<li>红黑树 AVL树 size-balance-tree  跳表均为有序表</li>
<li></li>
</ol>
<h2 id="07-堆">07 堆</h2>
<h3 id="0701-数据流问题">07.01 数据流问题</h3>
<h4 id="滑动窗口最大值">滑动窗口最大值</h4>
<ul>
<li>
<p>最大堆</p>
<ul>
<li>
<p>时间复杂度是 O(N*log K)</p>
</li>
<li>
<pre><code class="language-java">PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(Comparator.reverseOrder());
int[] res = new int[nums.length - k + 1];
for (int i = 0; i &lt; k; i++) {
    maxHeap.add(nums[i]);
}
res[0]= maxHeap.peek();
for (int i = 0,j=i+k;j&lt;nums.length;j++,i++) {
    maxHeap.remove(nums[i]);
    maxHeap.add(nums[j]);
    res[i+1]= maxHeap.peek();
}
return res;
</code></pre>
</li>
</ul>
</li>
<li>
<p>单调队列——&gt;Dqueue 双端队列 队首为最大值 队尾为数据流进入的入口 单向流动的队列</p>
<ul>
<li>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/image-20210731171727928.png" alt="image-20210731171727928" loading="lazy"></figure>
</li>
<li>
<p>有效降低复杂度</p>
</li>
</ul>
</li>
</ul>
<pre><code class="language-java">Deque&lt;Integer&gt; queue = new ArrayDeque&lt;&gt;();
int index = 0;
int[] res = new int[nums.length - k + 1];
for (int i = 0; i &lt; nums.length; i++) {
    // peekLast 从后面看的最后一个元素
    while (!queue.isEmpty() &amp;&amp; nums[i] &gt; queue.peekLast()) {
		// 弹出最后一个元素
        queue.pollLast();  
    }
    queue.addLast(nums[i]);
    if (i&gt;=k-1) {
        res[index++] = queue.peekFirst();
        if (i&gt;=k-1&amp;&amp;nums[i-k+1]==queue.peekFirst()) {
            queue.removeFirst();
        }
    }
}
return res;
</code></pre>
<h4 id="中位数">中位数</h4>
<p>大根堆存较小部分 小根堆存较大部分 小根堆长度尽量长</p>
<p>​	先入大根堆MaxHeap.add(num) 将大根堆的堆顶为较大部分 再讲较大部分入小根堆 MinHeao</p>
<p>minHeap.add(maxHeap.poll())</p>
<p>两堆的 size 相同则取 (minHeap.peek()+maxHeap.peek())/2.0</p>
<p>不等则取 minHeap.peek() (因为保证小根堆较长)</p>
<pre><code class="language-java">Queue&lt;Integer&gt; minHeap, maxHeap;

public void addNum(int num) {
    minHeap = new PriorityQueue&lt;&gt;();
    maxHeap = new PriorityQueue&lt;Integer&gt;(Comparator.reverseOrder());
    if (minHeap.size() == maxHeap.size()) {
        maxHeap.add(num); // 利用大根堆过滤出较大的部分maxHeap.poll() 再入小根堆minHeap
        minHeap.add(maxHeap.poll());
    } else {
        minHeap.add(num);
        maxHeap.add(minHeap.poll());
    }
}

public double findMedian() {
    // 两堆大小相等则取中值 不等为小根堆堆顶
    return maxHeap.size() == minHeap.size() ? ((minHeap.peek() + maxHeap.peek()) / 2.0) : minHeap.peek();

}
</code></pre>
<h2 id="08-单调栈">08 单调栈</h2>
<p><code>Monotonic Stack</code> 栈中元素按照单调顺序排列 ——&gt; 时间复杂度为线性 O(N) 每个元素遍历一次</p>
<h3 id="0801-模板">08.01 模板</h3>
<ul>
<li>维持递增栈</li>
<li>放入最后结果</li>
<li>当前元素入栈</li>
</ul>
<p>eg:</p>
<pre><code class="language-java">private static int[] nextGreaterElemenet(int[] nums) {
    int[] res = new int[nums.length];
    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
    for (int i = nums.length - 1; i &gt;= 0; i--) {
        // 维护单调栈的递增顺序 当要加入的值大于栈顶元素时 抛出栈顶丢弃 保证栈顶最小
        while (!stack.isEmpty() &amp;&amp; nums[i] &gt;= stack.peek()) {
            stack.pop();
        }
        // add the result to stack
        res[i] = stack.isEmpty() ? -1 : stack.peek();
        // action to come in stack
        stack.push(nums[i]);
    }
    return res;
}
</code></pre>
<h3 id="0802-tips">08.02 tips</h3>
<ul>
<li>
<p>最近最大的数——&gt;单调栈的特征</p>
</li>
<li>
<p>循环数组——&gt;</p>
</li>
<li>
<pre><code class="language-java">for (int i = 0; i &lt; 2 * len; i++) {
	// 遍历值的下标为 i%len
    int num = nums[i % len];
    while (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; num) {
        res[stack.pop()]=num;
    }
    if (i&lt;len) {
        stack.push(i);
    }
}
</code></pre>
</li>
<li></li>
</ul>
<h2 id="09-滑动窗口">09 滑动窗口</h2>
<p>连续元素 String subarray  linkedlistst</p>
<p>min max longest shorte  key word</p>
<p>本质上是two points 左边是 left 右边是 iterator(i)</p>
<h3 id="0901-模板">09.01 模板</h3>
<p>进——&gt;出——&gt;算</p>
<ul>
<li>将当前遍历值入窗口</li>
<li>窗口条件不符合时候 left 持续退出</li>
<li>窗口有效 valid 情况下 计算结果</li>
</ul>
<pre><code class="language-java">public int lengthofLongestSubstringTwoDistinct(String s, int k) {
    HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();
    int left = 0, res = 0;
    for (int i = 0; i &lt; s.length(); i++) {
        char cur = s.charAt(i);
        // 遍历值入窗口
        map.put(cur, map.getOrDefault(cur, 0) + 1);
        // 窗口不符合条件 left 持续退出
        while (map.size() &gt; k) {
            char c = s.charAt(left);
            map.put(c, map.get(c) - 1);
            if (map.get(c) == 0) {
                map.remove(c);
            }
            // size超过窗口大小即left 左移
            left++;
        }
        // 计算子串最值
        res = Math.max(res, i - left + 1);
    }
    return res;
}
</code></pre>
<h2 id="tips"><code>Tips</code></h2>
<h3 id="01-位移运算">01 位移运算</h3>
<ul>
<li>
<p>左移 扩大</p>
<ul>
<li>
<p><code>1&gt;&gt;4</code> 即1 * 2 * 2 * 2 * 2 = 16 左移 4 位即pow（2,4）</p>
</li>
<li>
<p>Java提供的位运算符有：左移( <code>&lt;&lt;</code> )、右移( <code>&gt;&gt;</code> ) 、无符号右移( <code>&gt;&gt;&gt;</code> ) 、位与( <code>&amp;</code> ) 、位或( <code>|</code> )、位非( <code>~</code> )、位异或( <code>^</code> )，除了位非( <code>~</code> )是一元操作符外，其它的都是二元操作符。</p>
<h4 id="1-左移">1. 左移( &lt;&lt; )</h4>
<p>a &lt;&lt; b 表示将数值 a 的二进制数值从 0 位算起到第 b - 1 位，整体向左方向移动 b 位，符号位不变，低位空出来的位补数值 0。</p>
<pre><code class="language-shell">a &lt;&lt; b = a * (2 ^ b)
</code></pre>
<h4 id="2-右移">2. 右移( &gt;&gt; )</h4>
<p><strong>a &gt;&gt; b</strong> 表示将数值 a 的二进制数值从 0 位算起到第 b - 1 位，整体向右方向移动 b 位，符号位不变，高位空出来的位补数值 0。</p>
<pre><code>a &gt;&gt; b = a / ( 2 ^ b )
</code></pre>
<h4 id="3-无符号右移">3. 无符号右移( &gt;&gt;&gt; )</h4>
<p>无符号右移运算符&gt;&gt;&gt;和右移运算符&gt;&gt;是一样的，只不过右移时左边是补上符号位，而无符号右移运算符是补上0，也就是说，对于正数移位来说等同于：&gt;&gt;，负数通过此移位运算符能移位成正数。</p>
<h4 id="4-位与">4. 位与( &amp; )</h4>
<p>与运算时，进行运算的两个数，从最低位到最高位，一一对应。如果某 bit 的两个数值对应的值都是 1，则结果值相应的 bit 就是 1，否则为 0.</p>
<pre><code class="language-java">0 &amp; 0 = 0,

0 &amp; 1 = 0,

1 &amp; 1 = 1
</code></pre>
<h4 id="5-位或">5. 位或( | )</h4>
<p>与运算时，进行运算的两个数，从最低位到最高位，一一对应。如果某 bit 的两个数值对应的值只要 1 个为 1，则结果值相应的 bit 就是 1，否则为 0。</p>
<pre><code class="language-java">0 | 0 = 0,0 | 1 = 1,1 | 1 = 1
</code></pre>
<h4 id="6-位异或">6. 位异或( ^ )</h4>
<p>两个操作数进行异或时，对于同一位上，如果数值相同则为 0，数值不同则为 1。</p>
<pre><code class="language-java">1 ^ 0 = 1,1 ^ 1 = 0,0 ^ 0 = 0;
</code></pre>
<h4 id="7-位非-~">7. 位非( ~ )</h4>
<p>对操作数的每一位进行操作，1 变成 0，0 变成 1。</p>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[XPS 7590 Hackintosh黑苹果]]></title>
        <id>https://flyingchase.github.io/post/xps-7590-hackintosh-hei-ping-guo/</id>
        <link href="https://flyingchase.github.io/post/xps-7590-hackintosh-hei-ping-guo/">
        </link>
        <updated>2021-05-03T12:20:28.000Z</updated>
        <content type="html"><![CDATA[<h1 id="xps-7590-hackinosh黑苹果">XPS 7590 Hackinosh黑苹果</h1>
<h2 id="注意️">注意⚠️</h2>
<p>本 EFI 适用于 bigsur 11.1-11.2.2  其余版本未经过测试</p>
<p>仅为个人使用，故 README 写的杂乱，欢迎交流推进 XPS-7590 的 Hackintosh 进程</p>
<p>部分内容涉及 BIOS 修改 有硬件损坏的风险</p>
<h2 id="1-参考">1 参考</h2>
<p>GitHub:</p>
<ul>
<li>https://github.com/gorquan/OC-XPS-7590</li>
<li>https://github.com/Liyunlock/DELL-XPS-15-7590-4K-Touchscreen_OpenCore_Hackintosh</li>
<li>https://github.com/romancin/Dell-XPS-7590-OpenCore</li>
<li>https://github.com/kirainmoe/hasee-tongfang-macos/issues/33</li>
<li>https://github.com/xxxzc/xps15-9570-macos/issues/40</li>
<li>https://github.com/Drowningfish223/Xps-7590-BigSur</li>
<li>https://github.com/stakeout55/Dell-XPS-7590-mac-OS-Big-Sur-11.1</li>
<li>https://github.com/xxxzc/xps15-9570-macos/issues/69</li>
</ul>
<h2 id="2-准备">2 准备</h2>
<h3 id="21-硬件概况">2.1 硬件概况</h3>
<table>
<thead>
<tr>
<th style="text-align:center">name</th>
<th>introduction</th>
<th style="text-align:center">name</th>
<th style="text-align:center">introduction</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">型号</td>
<td>XPS15-7590</td>
<td style="text-align:center">Cpu</td>
<td style="text-align:center">i7-9750h</td>
</tr>
<tr>
<td style="text-align:center">屏幕</td>
<td>4k 夏普触控屏</td>
<td style="text-align:center">网卡</td>
<td style="text-align:center">Dw1820a(更换)</td>
</tr>
<tr>
<td style="text-align:center">固态</td>
<td>SN720 512G</td>
<td style="text-align:center">声卡</td>
<td style="text-align:center">ALC298(原生)</td>
</tr>
<tr>
<td style="text-align:center">内存</td>
<td>48G(32+16) 英睿达</td>
<td style="text-align:center">Bios</td>
<td style="text-align:center">v1.7.0</td>
</tr>
</tbody>
</table>
<h3 id="22-bios设置">2.2 Bios设置</h3>
<p>雷电设置关键</p>
<h3 id="23-cfg解锁">2.3 CFG解锁</h3>
<p>setup_var_3 0x789 0x00 to disable overclocking lock</p>
<p>setup_var_3 0x6ED 0x00 to disable CFG lock</p>
<p>https://www.imacpc.net/archives/1549</p>
<p>dvmt-preallocted 设置为 96MB</p>
<h2 id="3-bug及解决方法备份">3 Bug及解决方法备份</h2>
<h3 id="31-啰嗦模式问题">3.1 啰嗦模式问题</h3>
<ul>
<li>
<p>OC引导Big Sur卡在<code>IOConsoleUsers: gIOScreenLockState 3, hs 0, bs 0 now</code> 注入苹果显示器EDID 48HZ (45 46字节替换为A6A6 再使用128计算最后一位字节 )</p>
</li>
<li>
<p>DeviceP.. 删除注入EDID</p>
</li>
<li>
<p>现在新版WhateverGreen kexts 可以直接内屏 60Hz——&gt;无须注入 EDID</p>
</li>
</ul>
<h3 id="32-4k内屏闪屏">3.2 4k内屏闪屏</h3>
<p>使用<code>ioreg -lw0 | grep IODisplayEDID | sed &quot;/[^&lt;]*&lt;/s///&quot; | xxd -p -r | strings -6</code> 查看屏幕的生产型号</p>
<p>夏普屏幕安装对应的显示器描述文件, 位置<code>/Library/ColorSync/Profiles</code></p>
<p>外接4k显示器 延迟高 卡顿: 重建缓存解决 <code>sudo kextchache -i\</code></p>
<p>UI 4K设置: dlcd-max 1400000 UIscale—&gt;02</p>
<p>目前type-c 低电压输入下首次链接type-c仍然出现</p>
<h3 id="33-雷电3设备">3.3 雷电3设备</h3>
<p>BIOS 设置：</p>
<p>​	ThunderBolt Adapter Configuration：勾选 Thunder 和 NoSecurity 其他关闭</p>
<p>​	ThunderBolt Auto Switch：取消 AutoSwitch 勾选 Native Enumeration</p>
<p>​	BIOS修改：</p>
<pre><code class="language-shell">setup_var 0x4F0 0x01
setup_var 0x4F6 0x01
</code></pre>
<p>关闭其他 type-c 和tb3 相关的 ssdt 使用TbtOnPch.aml 并 patch 修改_E42 to XE42</p>
<p>重置 nvrm 后即可</p>
<img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/6XeA6p.png" alt="6XeA6p" style="zoom:50%;" />
<p>注意第一次睡眠前拔掉雷电设备或者采用开机后即睡眠再唤醒</p>
<p>感谢群内大佬！</p>
<h3 id="35-关于08ghz锁频">3.5 关于0.8ghz锁频</h3>
<blockquote>
<p>资讯：</p>
<p>​	解锁EC�风扇控制位，动态注入风扇控制<br>
​	目前采用bios关闭DPTF解决此问题</p>
</blockquote>
<p>个人尝试：</p>
<ol>
<li>
<p>改造散热VRM后有效 降频次数减少 时间缩短为几秒</p>
</li>
<li>
<p>替换cpufriends 后改善极少出现锁频情况 实现27档变频</p>
</li>
<li>
<p>拔掉电池  按开机键释放主板静电 放置 5mins 后插上电池开机——&gt;无效</p>
</li>
<li>
<p>更改 DVMT 的最大值从 256 到 MAX（BIOS 内pre-allocation 没有 128MB 分配的可选项 最大 64MB） 无效</p>
</li>
<li>
<p>使用 voltageshift 降压后 偶尔出现</p>
<p>Intel Power Gradget 动态监测在高负载出现 0.78ghz 锁频时插入原装 dell 充电器cpu 频率恢复正常但五秒后再次锁0.8ghz 此时拔出电源又恢复正常 但五秒后重复锁频</p>
<p>即拔掉电源线以改善性能——&gt;醉了</p>
</li>
<li>
<p>修改 BIOS 中的 Bi-dorectional PROCHOT  关闭——&gt;修改 BIOS 有风险 ⚠️</p>
<blockquote>
<p>查找有指出可能是主板上温度传感器出错 使用 5.3 中修改 BIOS 方法<code>setup_var_3 0x724 0x00</code>关闭 BD PROCHOT</p>
<p><a href="https://zhuanlan.zhihu.com/p/27624654">CPU 风扇停转后发生什么</a></p>
</blockquote>
<p>关闭 BD 后仍然出现，但使用电池供电很少出现</p>
</li>
<li>
<p>爬远景评论发现以下几种方式</p>
<ol>
<li>拔掉电池 按住开机键 20s 再装上电池 使用电池供电开机后再插上电源</li>
<li>dell 原装圆孔充电器接口内针口损坏——&gt;使用手电筒照射充电器圆孔内部看不大清，但是本机使用 type-c供电出现0.78ghz锁频的次数更多</li>
</ol>
</li>
<li>
<p>交流群内提供 BIOS 降压方式：</p>
<pre><code class="language-shell">0x855 0x01
0x856 0x01
0x85B 0x64
0x85D 0x01
0xAFF 0x1E
0xB01 0x01
</code></pre>
</li>
</ol>
<p>现状：</p>
<p>​	重 GPU 需求下仍然出现降频 0.8ghz 现象 拔出电源恢复几秒后再次降频 视负载情况恢复正常睿频 大概在 10s-Long 最长有过持续十分钟</p>
<p>总结：</p>
<p>​	目前存在可能是主板上元件损坏/原装充电器圆孔内针脚损坏/BIOS需要更新或者刷低版/电池不合格需要更换</p>
<h3 id="37-lcd亮度调节">3.7 LCD亮度调节</h3>
<p>改为<code>Fn+S/B</code></p>
<ul>
<li>karabiner软件实现快捷键更改</li>
</ul>
<h3 id="36-睡眠后蓝牙不可用">3.6 睡眠后蓝牙不可用</h3>
<p>Q: 睡眠开机后蓝牙显示打开但不可连接设备 不可搜索新设备</p>
<p>​	1. 将蓝牙内建后+睡眠修复(hackintosh) —&gt;仍然出现</p>
<pre><code class="language-html">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;
&lt;plist version=&quot;1.0&quot;&gt;
&lt;dict&gt;
	&lt;key&gt;PciRoot(0x0)/Pci(0x1c,0x0)/Pci(0x0,0x0)&lt;/key&gt;
	&lt;dict&gt;
		&lt;key&gt;AAPL,slot-name&lt;/key&gt;
		&lt;string&gt;WLAN&lt;/string&gt;
		&lt;key&gt;compatible&lt;/key&gt;
		&lt;string&gt;pci14e4,43a3&lt;/string&gt; // 也有改为43a0的
		&lt;key&gt;device-type&lt;/key&gt;
		&lt;string&gt;Airport Extreme&lt;/string&gt;
		&lt;key&gt;model&lt;/key&gt;
		&lt;string&gt;DW1820A (BCM4350) 802.11ac Wireless&lt;/string&gt;
		&lt;key&gt;name&lt;/key&gt;
		&lt;string&gt;Airport&lt;/string&gt;
		&lt;key&gt;pci-aspm-default&lt;/key&gt;
		&lt;integer&gt;0&lt;/integer&gt;
	&lt;/dict&gt;
&lt;/dict&gt;
&lt;/plist&gt;

</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/lL2kFd.png" alt="lL2kFd" loading="lazy"></figure>
<p>​	2. 屏蔽背面两脚针后生效</p>
<h3 id="39-替换主板编号后-12-位后触控板二指失效">3.9 替换主板编号后 12 位后触控板二指失效</h3>
<p>退出 iCloud 并在其他设备上删除本机，重新修改二码，清除 NVRM 开机重建缓存，设置触控板三指/二指拖 玄学好了。。。</p>
<h3 id="38-hackintool-中工具无法查看-cfg-信息">3.8 Hackintool 中工具无法查看 CFG 信息</h3>
<p>总是在安全性与隐私中 允许签名再重启</p>
<p>https://www.mfpud.com/topics/4303/</p>
<pre><code class="language-shell"># 进入 Hackintool 程序包内Content-resources-kexts
sudo chown -R root:wheel AppleIntelInfo.kext
sudo kextutil AppleIntelInfo.kext
sudo cat /tmp/AppleIntelInfo.dat
# 最后取消注入驱动
sudo kextunload AppleIntelInfo.kext
</code></pre>
<h2 id="4-三码更新">4 三码更新</h2>
<p><a href="https://heipg.cn/tutorial/macserial-and-iservice-opencore.html">三码参考链接-写的很详细很完备</a></p>
<p>使用<code>opencorepkg</code>下载下来的   <code>macserial</code>内置程序进行PlatformInfo-Generic-MLB和SystemSeriaNumber填写(先在apple序列号保修查询官网确保未使用过)</p>
<p>重启后:</p>
<p><code>ioreg -d2 -c IOPlatformExpertDevice | awk -F\&quot; '/IOPlatformUUID/{print $(NF-1)}’</code>获得本机主班的UUID填入SystemUUID</p>
<p>⚠️：SystemUUID最后的十二位替换为网卡的mac地址 （mac地址中:去除并将所有小写字母大写再去替换）</p>
<p>​	该法使得 imessage 和 facetime 体验提升巨大</p>
<p>ROM：修改为en0的网卡mac地址 注意删掉: 最后四位与前面有空格</p>
<h2 id="5-优化">5 优化</h2>
<h3 id="51-cpu降压调节">5.1 CPU降压调节</h3>
<p>使用<code>voltageShif</code>调节，主要参考：</p>
<p><a href="https://www.insanelymac.com/forum/topic/331775-guide-how-to-undervolt-your-haswell-and-above-cpu/">Guide-undervolt</a></p>
<p><a href="https://github.com/stakeout55/presigned_VoltageShift_Kext_DellXPS7590">XPS-7590_VoltageShift</a></p>
<p>感谢！</p>
<p>更改设置时先执行remove再launchd</p>
<p><code>sudo ./voltageshift buildlaunchd &lt;CPU&gt; &lt;GPU&gt; &lt;CPUCache&gt; &lt;SA&gt; &lt;AI/O&gt; &lt;DI/O&gt; &lt;turbo&gt; &lt;pl1&gt; &lt;pl2&gt; &lt;remain&gt; &lt;UpdateMins (0 only apply at bootup)&gt;</code></p>
<p><code>sudo ./voltageshift buildlaunchd -135 -92 -125 -75 0 0 1 75 90 1 60</code></p>
<p>打开 turbo 并设置 PL1 56w PL2 90w  将 kexts 留在系统中并 60mins 执行一次</p>
<blockquote>
<p>https://github.com/syscl/CPUTune</p>
<p>https://github.com/SeptemberHX/VoltageShift</p>
<pre><code class="language-shell">sudo chown -R root:wheel VoltageShift.kext
chmod +x voltageshift


# load kexts
./voltageshift loadkext
# OR 
sudo kextutil  -r ./  -b com.sicreative.VoltageShift

# unload kexts 
./voltageshift unloadkext
# OR
sudo kextunload -b com.sicreative.VoltageShift

# 检查是否 load kexts
kextstat | grep -v com.apple

# 下述两条命令使得 voltageshift 在任意地方均可执行
sudo cp -r VoltageShift.kext /Library/Extensions/
sudo cp voltageshift /usr/local/bin
</code></pre>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/TypOYq.png" alt="TypOYq" loading="lazy"></figure>
<h3 id="52-电池供电睡眠后耳机杂音">5.2 电池供电睡眠后耳机杂音</h3>
<p>注入ALC守护进程即可</p>
<h3 id="53-dvmt-offset修改为最大值-max">5.3 DVMT offset修改为最大值 MAX</h3>
<p>解决4k 内屏/低电压 type-c 输入时外接 4k显示器闪屏</p>
<ul>
<li>
<p>在 Window 下使用 DELL_PFS_Extract 工具实现官网对应本机 BIOS.exe 文件提取.bin 文件 （使用方式为将 bios.exe 直接拖到应用图标上打开即可） 感谢远景论坛网友的分享</p>
</li>
<li>
<p>得到文件中<code>1 -- 1 System BIOS with BIOS Guard.bin</code>为待提取文件</p>
</li>
<li>
<p>使用 UEFI Tool 打开<code>.bin</code>文件</p>
<ul>
<li>
<p>查找<code>DVMT</code>并定位到 PE32<img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/hiBhVr.png" alt="hiBhVr" loading="lazy"></p>
</li>
<li>
<p>将 PE32 处导出为 <code>Section_PE32_image_Setup.sct</code>文件 <img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/GET145.png" alt="GET145" loading="lazy"></p>
<ul>
<li>
<p>使用 <code>ifrextract</code>工具将 <code>.sct</code>文件转化为 <code>.txt</code>格式 再查找 CFG/DVMT 等offset 偏移量</p>
</li>
<li>
<p>参考 CFG 解锁制作的 UEFI 引导盘 使用命令<code>setup_var_3 0xA11 0x02/0x03</code> 设置 再使用<code>setup_var_3 0xA10 ***</code>   但是 BIOS 设置无 64MB更大</p>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/FXa9XI.png" alt="FXa9XI" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/yKs00E.png" alt="yKs00E" loading="lazy"></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>配合 WEG.kext 设置 dvmt 属性可以有效解决上述问题</p>
<p>4k 内屏在使用新版 WhateverGreen.kext 基础上配置相应的 framebuffer补丁后，在低电压45/60w 的PD 充电高负载场景、外接 4k 显示器并睡眠唤醒情况下均未出现闪屏现象</p>
<h2 id="其他待整理">其他待整理</h2>
<h3 id="acpi整理">ACPI整理：</h3>
<blockquote>
<p>笔记本背光亮度调节 SSDT-PNLF.aml SSDT-ALS0.aml<br>
睡眠秒唤醒 SSDT-GPRW SSDT-UPRW</p>
</blockquote>
<p>不通用的ACPI</p>
<blockquote>
<p>电量显示0 SSDT-BATT.aml<br>
节能 SSDT-PLUG<br>
禁用独显 SSDT-DDGPU.aml<br>
解除USB端口限制 SSDT-EC.aml<br>
苹果原生电源管理SSDT-PLUG.aml</p>
</blockquote>
<h3 id="网络接口">网络接口</h3>
<p>wifi 非 en0</p>
<ol>
<li>进入系统设置-网络，删除左边列表所有项</li>
<li>删除 <code>/Library/Preferences/SystemConfiguration/NetworkInterfaces.plist</code></li>
<li>重启电脑</li>
<li>进入系统设置-网络，点击左侧的 '+'，将 Wi-Fi 添加回来。</li>
</ol>
]]></content>
    </entry>
</feed>