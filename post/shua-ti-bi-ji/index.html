
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>刷题笔记 | flyingchase</title>
<meta name="description" content="记录成长的脚印">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://flyingchase.github.io/favicon.ico?v=1633694813516">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://flyingchase.github.io/styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://flyingchase.github.io">
        <img class="avatar" src="https://flyingchase.github.io/images/avatar.png?v=1633694813516" alt="" width="32px" height="32px">
      </a>
      <a href="https://flyingchase.github.io">
        <h1 class="site-title">flyingchase</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/" class="menu purple-link">
            首页
          </a>
        
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/tags" class="menu purple-link">
            标签
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
          <h2 class="post-title">刷题笔记</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2021-05-03</span>
            
          </div>
          <div class="post-content">
            <h1 id="刷题坑">刷题坑</h1>
<hr>
<h2 id="00-杂项">00 杂项</h2>
<h3 id="0001-待刷备份-lintcode-leetcode">00.01 待刷备份 LintCode LeetCode</h3>
<h3 id="算法笔记">[[算法笔记]]</h3>
<p>待刷:</p>
<p>①<strong>初期，刷入门核心题</strong></p>
<p>这是针对毫无经验的刷题选手的策略。如果已经有一定刷题心得，可以跳过这步。</p>
<p>首先要给自己建立信心，我的策略是先把<strong>最基础的入门题刷个30道左右</strong>，熟悉coding的过程，找到刷题的感觉。</p>
<p>这些是我筛选过的还不错的入门题，我愿称之为——<strong>菜菜子必备的编程20题</strong>：</p>
<p>1.<a href="https://www.lintcode.com/problem/463/?utm_source=sc-zhihuniming-sy0309-2">整数排序</a></p>
<p>2.<a href="https://www.lintcode.com/problem/37//?utm_source=sc-zhihuniming-sy0309-2">反转一个3位整数</a></p>
<p>3.<a href="https://www.lintcode.com/problem/283//?utm_source=sc-zhihuniming-sy0309-2">三数之中的最大值</a></p>
<p>4.<a href="https://www.lintcode.com/problem/1921//?utm_source=sc-zhihuniming-sy0309-2">从不充值的玩家</a></p>
<p>5.<a href="https://www.lintcode.com/problem/298//?utm_source=sc-zhihuniming-sy0309-2">寻找素数</a></p>
<p>6.<a href="https://www.lintcode.com/problem/297//?utm_source=sc-zhihuniming-sy0309-2">寻找最大值</a></p>
<p>7.<a href="https://www.lintcode.com/problem/466//?utm_source=sc-zhihuniming-sy0309-2">链表节点计数</a></p>
<p>8.<a href="https://www.lintcode.com/problem/454//?utm_source=sc-zhihuniming-sy0309-2">矩阵面积</a></p>
<p>9.<a href="https://www.lintcode.com/problem/25//?utm_source=sc-zhihuniming-sy0309-2">打印X</a></p>
<p>10.<a href="https://www.lintcode.com/problem/1919//?utm_source=sc-zhihuniming-sy0309-2">分数超过组长的组员</a></p>
<p>11.<a href="https://www.lintcode.com/problem/1927//?utm_source=sc-zhihuniming-sy0309-2">硬币翻面</a></p>
<p>12.<a href="https://www.lintcode.com/problem/1934//?utm_source=sc-zhihuniming-sy0309-2">张三的故事</a></p>
<p>13.<a href="https://www.lintcode.com/problem/1931//?utm_source=sc-zhihuniming-sy0309-2">寻找特定的患者</a></p>
<p>14.<a href="https://www.lintcode.com/problem/1932//?utm_source=sc-zhihuniming-sy0309-2">挂科最多的同学</a></p>
<p>15.<a href="https://www.lintcode.com/problem/1938//?utm_source=sc-zhihuniming-sy0309-2">查询用户邮箱</a></p>
<p>16.<a href="https://www.lintcode.com/problem/1923//?utm_source=sc-zhihuniming-sy0309-2">增长的疫情感染人数</a></p>
<p>17.<a href="https://www.lintcode.com/problem/1930//?utm_source=sc-zhihuniming-sy0309-2">公租房信息查询</a></p>
<p>18.<a href="https://www.lintcode.com/problem/1920//?utm_source=sc-zhihuniming-sy0309-2">查找重名的同学</a></p>
<p>19.<a href="https://www.lintcode.com/problem/1925//?utm_source=sc-zhihuniming-sy0309-2">超过3名球员所得到的分数</a></p>
<p>20.<a href="https://www.lintcode.com/problem/1924//?utm_source=sc-zhihuniming-sy0309-2">推荐学理科的同学</a></p>
<p>②中期，按知识点tag刷题</p>
<hr>
<p>接下来就要真正的掌握算法和数据结构知识点。</p>
<p>我的策略是逮着一个知识点使劲刷，刷到掌握了为止（不限题数）。</p>
<p>但如果刷了30题以上还是不得其法，可以先放一放，不要给自己造成心理负担。</p>
<p><strong>最让人头疼的动态规划，可以循序渐进的刷这10道题：</strong></p>
<p>1.<a href="https://www.lintcode.com/problem/514/?utm_source=sc-zhihuniming-sy0309-2">栅栏染色</a></p>
<p>2.<a href="https://www.lintcode.com/problem/111/?utm_source=sc-zhihuniming-sy0309-2">爬楼梯</a></p>
<p>3.<a href="https://www.lintcode.com/problem/749/?utm_source=sc-zhihuniming-sy0309-2">约翰的后花园</a></p>
<p>4.<a href="https://www.lintcode.com/problem/683/?utm_source=sc-zhihuniming-sy0309-2">单词拆分</a></p>
<p>5.<a href="https://www.lintcode.com/problem/437/?utm_source=sc-zhihuniming-sy0309-2">书籍复印</a></p>
<p>6.<a href="https://www.lintcode.com/problem/512/?utm_source=sc-zhihuniming-sy0309-2">解码方法</a></p>
<p>7.<a href="http://lintcode.com/problem/192/?utm_source=sc-zhihuniming-sy0309-2">通配符匹配</a></p>
<p>8.<a href="https://www.lintcode.com/problem/816/?utm_source=sc-zhihuniming-sy0309-2">旅行商问题</a></p>
<p>9.<a href="https://www.lintcode.com/problem/622/?utm_source=sc-zhihuniming-sy0309-2">青蛙跳</a></p>
<p>10.<a href="https://www.lintcode.com/problem/20/?utm_source=sc-zhihuniming-sy0309-2">骰子求和</a></p>
<p><strong>双指针算法，高频算法之王，变形比较多。想掌握的话，刷这些题：</strong></p>
<p>1.<a href="https://www.lintcode.com/problem/148/?utm_source=sc-zhihuniming-sy0309-2">颜色分类</a></p>
<p>2.<a href="https://www.lintcode.com/problem/607/?utm_source=sc-zhihuniming-sy0309-2">两数之和 III-数据结构设计</a></p>
<p>3.<a href="https://www.lintcode.com/problem/143/?utm_source=sc-zhihuniming-sy0309-2">排颜色</a></p>
<p>4.<a href="https://www.lintcode.com/problem/32/?utm_source=sc-zhihuniming-sy0309-2">最长子串覆盖</a></p>
<p>5.<a href="https://www.lintcode.com/problem/891/?utm_source=sc-zhihuniming-sy0309-2">有效回文</a></p>
<p>6.<a href="https://www.lintcode.com/problem/102/?utm_source=sc-zhihuniming-sy0309-2">带环链表</a></p>
<p>7.<a href="https://www.lintcode.com/problem/144/?utm_source=sc-zhihuniming-sy0309-2">交错正负数</a></p>
<p>8.<a href="https://www.lintcode.com/problem/59/?utm_source=sc-zhihuniming-sy0309-2">最接近的三数之和</a></p>
<p>9.<a href="https://www.lintcode.com/problem/58/?utm_source=sc-zhihuniming-sy0309-2">四数之和</a></p>
<p>10.<a href="https://www.lintcode.com/problem/363/?utm_source=sc-zhihuniming-sy0309-2">接雨水</a></p>
<p><strong>宽度优先搜索，考察频率高，但实现不难，刷这7道题：</strong></p>
<p>1.<a href="https://www.lintcode.com/problem/433/?utm_source=sc-zhihuniming-sy0309-2">岛屿的个数</a></p>
<p>2.<a href="https://www.lintcode.com/problem/605/?utm_source=sc-zhihuniming-sy0309-2">序列重构</a></p>
<p>3.<a href="https://www.lintcode.com/problem/127/?utm_source=sc-zhihuniming-sy0309-2">拓扑排序</a></p>
<p>4.<a href="https://www.lintcode.com/problem/615/?utm_source=sc-zhihuniming-sy0309-2">课程表</a></p>
<p>5.<a href="https://www.lintcode.com/problem/151/?utm_source=sc-zhihuniming-sy0309-2">买卖股票的最佳时期</a></p>
<p>6.<a href="https://www.lintcode.com/problem/616/?utm_source=sc-zhihuniming-sy0309-2">安排课程</a></p>
<p>7.<a href="https://www.lintcode.com/problem/45/?utm_source=sc-zhihuniming-sy0309-2">最大子数组差</a></p>
<p><strong>深度优先搜索，考察频率高，主要是考察递归会不会写。</strong></p>
<p>1.<a href="https://www.lintcode.com/problem/17/?utm_source=sc-zhihuniming-sy0309-2">子集</a></p>
<p>2.<a href="https://www.lintcode.com/problem/178/?utm_source=sc-zhihuniming-sy0309-2">图是否是树</a></p>
<p>3.<a href="https://www.lintcode.com/problem/138/?utm_source=sc-zhihuniming-sy0309-2">子数组之和</a></p>
<p>4.<a href="https://www.lintcode.com/problem/425/?utm_source=sc-zhihuniming-sy0309-2">电话号码的字母组合</a></p>
<p>5.<a href="https://www.lintcode.com/problem/90/?utm_source=sc-zhihuniming-sy0309-2">K数和</a></p>
<p>6.<a href="https://www.lintcode.com/problem/652/?utm_source=sc-zhihuniming-sy0309-2">因式分解</a></p>
<p><strong>分治法，考察频率中等，一般和二叉树一起出现和考察，题一般不难。</strong></p>
<p>1.<a href="https://www.lintcode.com/problem/17/?utm_source=sc-zhihuniming-sy0309-2">子集</a></p>
<p>2.<a href="https://www.lintcode.com/problem/31/?utm_source=sc-zhihuniming-sy0309-2">数组划分</a></p>
<p>3.<a href="https://www.lintcode.com/problem/95/?utm_source=sc-zhihuniming-sy0309-2">验证二叉查找树</a></p>
<p>4.<a href="https://www.lintcode.com/problem/15/?utm_source=sc-zhihuniming-sy0309-2">全排列</a></p>
<p>5.<a href="https://www.lintcode.com/problem/137/?utm_source=sc-zhihuniming-sy0309-2">克隆图</a></p>
<p>6.<a href="https://www.lintcode.com/problem/143/?utm_source=sc-zhihuniming-sy0309-2">排颜色</a></p>
<p>7.<a href="https://www.lintcode.com/problem/138/?utm_source=sc-zhihuniming-sy0309-2">子数组之和</a></p>
<p><strong>哈希表，原理和应用都需要掌握，而且需要掌握代码实现。</strong></p>
<p>1.<a href="https://www.lintcode.com/problem/two-sum/?utm_source=sc-zhihuniming-sy0309-2">两数之和</a></p>
<p>2.<a href="https://www.lintcode.com/problem/longest-palindrome/?utm_source=sc-zhihuniming-sy0309-2">最长回文串</a></p>
<p>3.<a href="https://www.lintcode.com/problem/intersection-of-two-arrays/?utm_source=sc-zhihuniming-sy0309-2">两数组的交集</a></p>
<p>4.<a href="https://www.lintcode.com/problem/first-unique-number-in-data-stream/?utm_source=sc-zhihuniming-sy0309-2">数据流中第一个唯一的数字</a></p>
<p>5.<a href="https://www.lintcode.com/problem/two-sum-ii-input-array-is-sorted/?utm_source=sc-zhihuniming-sy0309-2">两数和 II-输入已排序的数组</a></p>
<p><strong>堆，经常会用到，原理必须掌握。高频。</strong></p>
<p>1.<a href="http://lintcode.com/problem/4/?utm_source=sc-zhihuniming-sy0309-2">丑数</a></p>
<p>2.<a href="https://www.lintcode.com/problem/130/?utm_source=sc-zhihuniming-sy0309-2">堆化</a></p>
<p>3.<a href="https://www.lintcode.com/problem/360/?utm_source=sc-zhihuniming-sy0309-2">滑动窗口的中位数</a></p>
<p>4.<a href="https://www.lintcode.com/problem/131/?utm_source=sc-zhihuniming-sy0309-2">大楼轮廓</a></p>
<p>5.<a href="https://www.lintcode.com/problem/518/?utm_source=sc-zhihuniming-sy0309-2">超级丑数</a></p>
<p>6.<a href="https://www.lintcode.com/problem/964/?utm_source=sc-zhihuniming-sy0309-2">食物集合</a></p>
<p>7.<a href="https://www.lintcode.com/problem/808/?utm_source=sc-zhihuniming-sy0309-2">影际网络</a></p>
<p><strong>贪心，考得不多，但起码要会用。</strong></p>
<p>1.<a href="https://www.lintcode.com/problem/919/?utm_source=sc-zhihuniming-sy0309-2">会议室</a></p>
<p>2.<a href="https://www.lintcode.com/problem/602/?utm_source=sc-zhihuniming-sy0309-2">俄罗斯套娃信封</a></p>
<p>3.<a href="https://www.lintcode.com/problem/304/?utm_source=sc-zhihuniming-sy0309-2">最大乘积</a></p>
<p>4.<a href="https://www.lintcode.com/problem/187/?utm_source=sc-zhihuniming-sy0309-2">加油站</a></p>
<p>5.<a href="https://www.lintcode.com/problem/45/?utm_source=sc-zhihuniming-sy0309-2">最大子数组差</a></p>
<p><strong>链表，中小公司考得多，大公司近年来考得少。题目一般不难，主要考察Reference。</strong></p>
<p>1.<a href="https://www.lintcode.com/problem/104/?utm_source=sc-zhihuniming-sy0309-2">合并k个排序链表</a></p>
<p>2.<a href="https://www.lintcode.com/problem/685/?utm_source=sc-zhihuniming-sy0309-2">数据流中第一个唯一的数字</a></p>
<p>3.<a href="https://www.lintcode.com/problem/102/?utm_source=sc-zhihuniming-sy0309-2">带环链表</a></p>
<p>4.<a href="https://www.lintcode.com/problem/170/?utm_source=sc-zhihuniming-sy0309-2">旋转链表</a></p>
<p>5.<a href="https://www.lintcode.com/problem/380/?utm_source=sc-zhihuniming-sy0309-2">两个链表的交叉</a></p>
<p>6.<a href="https://www.lintcode.com/problem/450/?utm_source=sc-zhihuniming-sy0309-2">K组翻转链表</a></p>
<p><strong>线段树，不太考。但当有的题目存在多种解法的时候，线段树可以帮忙降低思考难度。</strong></p>
<p>1.<a href="https://www.lintcode.com/problem/201/?utm_source=sc-zhihuniming-sy0309-2">线段树的构造</a></p>
<p>2.<a href="https://www.lintcode.com/problem/202/?utm_source=sc-zhihuniming-sy0309-2">线段树的查询</a></p>
<p>3.<a href="https://www.lintcode.com/problem/207/?utm_source=sc-zhihuniming-sy0309-2">区间求和</a></p>
<p>4.<a href="https://www.lintcode.com/problem/205/?utm_source=sc-zhihuniming-sy0309-2">区间最小数</a></p>
<p>5.<a href="https://www.lintcode.com/problem/1063/?utm_source=zhihuniming-sy0309-2">我的日历</a></p>
<p>6.<a href="https://www.lintcode.com/problem/290/?utm_source=sc-zhihuniming-sy0309-2">排序方案</a></p>
<p>7.<a href="https://www.lintcode.com/problem/998/?utm_source=sc-zhihuniming-sy0309-2">构造队列</a></p>
<p>8.<a href="https://www.lintcode.com/problem/1450/?utm_source=sc-zhihuniming-sy0309-2">矩形面积</a></p>
<p><strong>③面试前，按公司ladder刷题</strong></p>
<hr>
<p>在准备面试前，我建议直接刷目标公司的高频题。熟悉这些公司的常考题、出题风格，会比漫无目的地乱刷效率高很多。</p>
<p><strong>阿里巴巴：</strong></p>
<p><a href="https://www.lintcode.com/problem/bull-cards/?utm_source=sc-zhihuniming-sy0309-2">牛牌</a></p>
<p><a href="https://www.lintcode.com/problem/split-concatenated-strings/?utm_source=sc-zhihuniming-sy0309-2">连接字符串</a></p>
<p><a href="https://www.lintcode.com/problem/split-array-with-equal-sum/?utm_source=sc-zhihuniming-sy0309-2">同和分割数组</a></p>
<p><a href="https://www.lintcode.com/problem/valid-parenthesis-string/?utm_source=sc-zhihuniming-sy0309-2">有效的括号字符串</a></p>
<p><a href="https://www.lintcode.com/problem/path-sum-iv/?utm_source=sc-zhihuniming-sy0309-2">路径和</a></p>
<p><a href="https://www.lintcode.com/problem/array-score/?utm_source=sc-zhihuniming-sy0309-2">数组评分</a></p>
<p><strong>字节跳动：</strong></p>
<p><a href="https://www.lintcode.com/problem/delete-char/?utm_source=sc-zhihuniming-sy0309-2">删除字符</a></p>
<p><a href="https://www.lintcode.com/problem/longest-increasing-path-in-a-matrix/?utm_source=sc-zhihuniming-sy0309-2">矩阵中的最长递增路径</a></p>
<p><a href="https://www.lintcode.com/problem/restorearray/?utm_source=sc-zhihuniming-sy0309-2">恢复数组</a></p>
<p><a href="https://www.lintcode.com/problem/food-set/?utm_source=sc-zhihuniming-sy0309-2">食物组合</a></p>
<p><a href="https://www.lintcode.com/problem/combine-new-numbers/?utm_source=sc-zhihuniming-sy0309-2">组合新数字</a></p>
<p><a href="https://www.lintcode.com/problem/maximum-points-set/?utm_source=sc-zhihuniming-sy0309-2">最大点的集合</a></p>
<p><strong>腾讯：</strong></p>
<p><a href="https://www.lintcode.com/problem/minimum-rest-days/?utm_source=sc-zhihuniming-sy0309-2">最短休息日</a></p>
<p><a href="https://www.lintcode.com/problem/decrypt-the-string/?utm_source=sc-zhihuniming-sy0309-2">解压字符串</a></p>
<p><a href="https://www.lintcode.com/problem/median-ii/?utm_source=sc-zhihuniming-sy0309-2">中位数</a></p>
<p><a href="https://www.lintcode.com/problem/remove-boxes/?utm_source=sc-zhihuniming-sy0309-2">移除箱子</a></p>
<p><a href="https://www.lintcode.com/problem/minimum-factorization/?utm_source=sc-zhihuniming-sy0309-2">最小分解</a></p>
<p><a href="https://www.lintcode.com/problem/song-time/?utm_source=sc-zhihuniming-sy0309-2">歌曲时间</a></p>
<p><strong>百度：</strong></p>
<p><a href="https://www.lintcode.com/problem/arithmetic-slices/?utm_source=sc-zhihuniming-sy0309-2">等差切片</a></p>
<p><a href="https://www.lintcode.com/problem/zuma-game/?utm_source=sc-zhihuniming-sy0309-2">祖玛游戏</a></p>
<p><a href="https://www.lintcode.com/problem/game-of-life/?utm_source=sc-zhihuniming-sy0309-2">生命游戏</a></p>
<p><a href="https://www.lintcode.com/problem/longest-substring-with-at-least-k-repeating-characters/?utm_source=sc-zhihuniming-sy0309-2">字符至少出现K次的最长子串</a></p>
<p><a href="https://www.lintcode.com/problem/integer-replacement/?utm_source=sc-zhihuniming-sy0309-2">整数替换</a></p>
<p><a href="https://www.lintcode.com/problem/split-array-largest-sum/?utm_source=sc-zhihuniming-sy0309-2">拆分子数组</a></p>
<p><strong>美团：</strong></p>
<p><a href="https://www.lintcode.com/problem/test-strategy/?utm_source=sc-zhihuniming-sy0309-2">考试策略</a></p>
<p><a href="https://www.lintcode.com/problem/string-partition/?utm_source=sc-zhihuniming-sy0309-2">字符串划分</a></p>
<p><a href="https://www.lintcode.com/problem/xorsum-of-interval-extremum/?utm_source=sc-zhihuniming-sy0309-2">区间极值异或</a></p>
<p><a href="https://www.lintcode.com/problem/the-months-days/?utm_source=sc-zhihuniming-sy0309-2">月份天数</a></p>
<p><a href="https://www.lintcode.com/problem/associated-query/?utm_source=sc-zhihuniming-sy0309-2">关联查询</a></p>
<p><a href="https://www.lintcode.com/problem/character-deletion/?utm_source=sc-zhihuniming-sy0309-2">字符删除</a></p>
<p>Google</p>
<p><a href="https://www.lintcode.com/problem/kth-largest-element/?utm_source=sc-zhihuniming-sy0309-2">第k大元素</a></p>
<p><a href="https://www.lintcode.com/problem/lru-cache/?utm_source=sc-zhihuniming-sy0309-2">LRU缓存策略</a></p>
<p><a href="https://www.lintcode.com/problem/graph-valid-tree/?utm_source=sc-zhihuniming-sy0309-2">图是否是树</a></p>
<p><a href="https://www.lintcode.com/problem/sequence-reconstruction/?utm_source=sc-zhihuniming-sy0309-2">序列重构</a></p>
<p><a href="https://www.lintcode.com/problem/word-break/?utm_source=sc-zhihuniming-sy0309-2">单词拆分 I</a></p>
<p><a href="https://www.lintcode.com/problem/longest-substring-with-at-most-k-distinct-characters/?utm_source=sc-zhihuniming-sy0309-2">最多有k个不同字符的最长子字符串</a></p>
<p><strong>Facebook</strong></p>
<p><a href="https://www.lintcode.com/problem/3sum/?utm_source=sc-zhihuniming-sy0309-2">三数之和</a></p>
<p><a href="https://www.lintcode.com/problem/sort-colors/?utm_source=sc-zhihuniming-sy0309-2">颜色分类</a></p>
<p><a href="https://www.lintcode.com/problem/word-ladder/?utm_source=sc-zhihuniming-sy0309-2">单词接龙</a></p>
<p><a href="https://www.lintcode.com/problem/validate-binary-search-tree/?utm_source=sc-zhihuniming-sy0309-2">验证二叉查找树</a></p>
<p><a href="https://www.lintcode.com/problem/search-in-rotated-sorted-array/?utm_source=sc-zhihuniming-sy0309-2">搜索旋转排序数组</a></p>
<p><strong>Microsoft</strong></p>
<p><a href="https://www.lintcode.com/problem/best-time-to-buy-and-sell-stock/?utm_source=sc-zhihuniming-sy0309-2">买卖股票的最佳时机</a></p>
<p><a href="https://www.lintcode.com/problem/sliding-window-maximum/?utm_source=sc-zhihuniming-sy0309-2">滑动窗口的最大值</a></p>
<p><a href="https://www.lintcode.com/problem/binary-tree-zigzag-level-order-traversal/?utm_source=sc-zhihuniming-sy0309-2">二叉树的锯齿形层次遍历</a></p>
<p><a href="https://www.lintcode.com/problem/intersection-of-two-linked-lists/?utm_source=sc-zhihuniming-sy0309-2">两个链表的交叉</a></p>
<p><a href="https://www.lintcode.com/problem/copy-list-with-random-pointer/?utm_source=sc-zhihuniming-sy0309-2">复制带随机指针的链表</a></p>
<p><strong>Amazon</strong></p>
<p><a href="https://www.lintcode.com/problem/627/?utm_source=sc-zhihuniming-sy0309-2">最长回文串</a></p>
<p><a href="https://www.lintcode.com/problem/615/?utm_source=sc-zhihuniming-sy0309-2">课程表</a></p>
<p><a href="https://www.lintcode.com/problem/384/?utm_source=sc-zhihuniming-sy0309-2">最长无重复字符的子串</a></p>
<p><a href="https://www.lintcode.com/problem/616/?utm_source=sc-zhihuniming-sy0309-2">安排课程</a></p>
<p><a href="https://www.lintcode.com/problem/1565/?utm_source=sc-zhihuniming-sy0309-2">飞行棋</a></p>
<p><a href="https://www.lintcode.com/problem/380/?utm_source=sc-zhihuniming-sy0309-2">两个链表的交叉</a></p>
<p><strong>领英</strong></p>
<p><a href="https://www.lintcode.com/problem/392/?utm_source=sc-zhihuniming-sy0309-2">打劫房屋</a></p>
<p><a href="https://www.lintcode.com/problem/645/?utm_source=sc-zhihuniming-sy0309-2">识别名人</a></p>
<p><a href="https://www.lintcode.com/problem/1360/?utm_source=sc-zhihuniming-sy0309-2">对称树</a></p>
<p><a href="https://www.lintcode.com/problem/588/?utm_source=sc-zhihuniming-sy0309-2">划分和相等的子集</a></p>
<p><a href="https://www.lintcode.com/problem/859/?utm_source=sc-zhihuniming-sy0309-2">最大栈</a></p>
<p><strong>Apple</strong></p>
<p><a href="https://www.lintcode.com/problem/363/?utm_source=sc-zhihuniming-sy0309-2">接雨水</a></p>
<p><a href="http://lintcode.com/problem/413/?utm_source=sc-zhihuniming-sy0309-2">反转整数</a></p>
<p><a href="https://www.lintcode.com/problem/1270/?utm_source=sc-zhihuniming-sy0309-2">勒索信</a></p>
<p><a href="https://www.lintcode.com/problem/1352/?utm_source=sc-zhihuniming-sy0309-2">比较版本号</a></p>
<p><a href="https://www.lintcode.com/problem/1355/?utm_source=sc-zhihuniming-sy0309-2">杨辉三角</a></p>
<p><a href="https://www.lintcode.com/problem/1532/?utm_source=sc-zhihuniming-sy0309-2">序列化和反序列N叉树</a></p>
<hr>
<h3 id="0002-求中点">00.02 求中点</h3>
<hr>
<ul>
<li>
<pre><code class="language-java">int mid = left + ((right-left) &gt;&gt; 1);	//(L+R)/2
//防止溢出 a&gt;&gt;1 相当于a/2  使用位运算 速度更快
</code></pre>
</li>
</ul>
<h3 id="0003-函数返回新建数组">00.03 函数返回新建数组</h3>
<hr>
<pre><code class="language-java">return new int[] {less+1 ,more-1};
</code></pre>
<h3 id="0004-打印数组">00.04 打印数组</h3>
<hr>
<pre><code class="language-java">System.out.println(Arrays.toString(nums)); //打印结果为[1,2,3,4,]
</code></pre>
<h3 id="0005-int与integer互转">00.05 int[]与Integer[]互转</h3>
<hr>
<pre><code class="language-java">import java.util.stream.IntStream;
import java.util.stream.Stream;

// int[]nums 转化为Integer[] 数组
Integer[] integers = Arrays.stream(nums).boxed().toArray(Integer[]::new);
//转化为int[] 数组
int[] nums = Arrays.stream(integers).mapToInt(Integer::valueOf).toArray();

// 解释
//将int数组转换为Integer数组
int[] nums = {1,2,3};
//先将int数组转换为数值流
IntStream stream = Arrays.stream(nums);
//流中的元素全部装箱，转换为流 ----&gt;int转为Integer
Stream&lt;Integer&gt; integerStream = stream.boxed();
//将流转换为数组
Integer[] integers = integerStream.toArray(Integer[]::new);
</code></pre>
<h3 id="0006-int-与-listnode转换">00.06 int[] 与 ListNode转换</h3>
<hr>
<pre><code class="language-java">public class ListNode{
    int val;
    ListNode next=null;
    ListNode(int val) {
        this.val=val;
    }
}
    // 将Integer[] nums转为ListNode
public static ListNode arrayToListNode(Integer[] nums) {
    ListNode head= new  ListNode(nums[0]);
    ListNode oher = head;	//暂存头节点 避免丢失
    for(int i=1;i&lt;nums.length;i++) {
        ListNode temp = new ListNode(nums[i]); //借助中间temp实现
		other.next=temp;     //将other下一节点指向新生节点temp
        other=temp;			//将other后移 指向最后一个节点
    }
    return head;	//找回头节点    
}

	//将ListNode转化为int[] nums
public static int[] 
</code></pre>
<h3 id="0007-int-nums中最小的k数大根堆partition">00.07 int[] nums中最小的k数—大根堆/partition</h3>
<ul>
<li>复杂度：O(NlogK) + O(K)</li>
<li>特别适合处理海量数据</li>
</ul>
<p>维护一个大小为 K 的最小堆过程如下：使用大顶堆。在添加一个元素之后，如果大顶堆的大小大于 K，那么将大顶堆的堆顶元素去除，也就是将当前堆中值最大的元素去除，从而使得留在堆中的元素都比被去除的元素来得小。</p>
<p>应该使用大顶堆来维护最小堆，而不能直接创建一个小顶堆并设置一个大小，企图让小顶堆中的元素都是最小元素。</p>
<p>Java 的 PriorityQueue 实现了堆的能力，PriorityQueue 默认是小顶堆，可以在在初始化时使用 Lambda 表达式 (o1, o2) -&gt; o2 - o1 来实现大顶堆。</p>
<p><code>lambda(o1,o2)-&gt;o2-o1</code> <code>Comparator.reverseOrder()</code></p>
<pre><code class="language-java">public ArrayList&lt;Integer&gt; getLeastNumbers(int[] nums, int k) {
    if(k&gt;nums.length||k&lt;1) {
        return new ArrayList&lt;&gt;();
    }
    // 使用lambda表达式
    PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((o1,o2)-&gt;o2-o1);
    // 使用Comparator
    priorityQueue&lt;Integer. maxHeap = new PriorityQueue&lt;&gt;(k,Comparator.reverseOrder());
    
    for(int num :nums) {
        if(maxHeap.size()&lt;k) {
            maxHeap.add(num);
        }else{
            if(maxHeap.peek()&gt;e) {
                maxHeap.poll();
                maxHeap.add(num);
            }
        }
    }
    return new ArrayList&lt;&gt;(maxHeap);
}
</code></pre>
<h3 id="0008-assert-断言">00.08 assert 断言</h3>
<p>IDEA中JVM设置自定义参数-ea后即可打开</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/v6WKwP.png" alt="v6WKwP" loading="lazy"></figure>
<pre><code class="language-java">assert [boolean//表达式]
</code></pre>
<p>只有当 表达式为真——&gt;继续执行后续代码否则终止执行并抛出<code>AssertionError</code></p>
<h3 id="009-两链表长度差值">0.09 两链表长度差值</h3>
<p>一个变量即可实现</p>
<pre><code class="language-java">int cnt = 0;
while (cur1!=null) {
    cnt++; //遍历第一个链表时++
    cur1=cur1.next;
}
while (cur2!=null) {
    cnt--;	//遍历第二个链表时--
    cur2=cur2.next;
}
cnt = Math.abs(cnt);	// 二链表长&gt;一链表长时cnt&lt;0 
</code></pre>
<h3 id="010-堆化">0.10 堆化</h3>
<p>O(N)</p>
<pre><code class="language-java">    PriorityQueue&lt;Integer&gt; minheap = new PriorityQueue&lt;&gt;();		 // 默认最小堆    PriorityQueue&lt;Integer&gt; maxheap = new PriorityQueue&lt;&gt;(Collections.reverseOrder());//    minheap.add();//    peek() 查看堆顶元素//    poll() 弹出堆顶元素并删除//    size() 堆的大小
</code></pre>
<h3 id="011-arraylist-与-int转换">0.11 ArrayList 与 int[]转换</h3>
<pre><code class="language-java">int[] res = integers.stream().mapToInt(Integer::intValue).toArray();// 使用 stream流 和 方法引用
</code></pre>
<pre><code class="language-java">List&lt;Integer&gt; lists = Arrays.stream(res).boxed().collect(Collectors.toList());// 装箱
</code></pre>
<h3 id="012-统计出现的频率得到频率数组">0.12 统计出现的频率——&gt;得到频率数组</h3>
<pre><code class="language-java">Map&lt;Integer, Integer&gt; frequents = new HashMap&lt;&gt;();
for (int num:
     nums) {
    frequents.put(num,frequents.getOrDefault(num,0)+1)
}
// 将 Map 转换为 Set
Set&lt;Map.Entry&lt;Integer,Integer&gt;&gt; entries = frequents.entrySet();
</code></pre>
<h3 id="013-最短子串">0.13 最短子串</h3>
<p>找到 minwindow 的 len 同时记住起始的left 即可</p>
<p>​	使用 substring(left,left+resLen)</p>
<h2 id="01-排序">01 排序</h2>
<ul>
<li>
<p>**排序的稳定性: **</p>
<p>意义: 保留业务数据中的原始信息 不被抹去(两次排序中第二次排序可以保留第一次排序后结果)</p>
<ul>
<li>在原序列中相同值的原始相对次序位置不变</li>
<li>冒泡、插入(数据量小60的时候均适用、因为常数项低 )、归并、桶排序、计数排序、基数排序</li>
<li>快排不稳定——&gt;partition随机选择分割</li>
<li>堆排不稳定——&gt;</li>
</ul>
</li>
<li>
<p><strong>工程中综合排序:</strong></p>
<ul>
<li>基本数据类型——&gt;快排</li>
<li>自定义类——&gt;归并</li>
<li>小样本——&gt;插入</li>
</ul>
</li>
<li>
<p><strong>比较器的使用:</strong></p>
<ul>
<li>
<p>利用系统提供的Arrays.sort(nums, new comparator()) 实现排序 相当于c中的sort 的第二个参数实现</p>
</li>
<li>
<p>无comparator的实现默认按照nums的内存地址排序</p>
<pre><code class="language-java">// 继承Comparator&lt;&gt;接口 重写这个比较的Compare()函数

public static class AgeAscendingComparator implements Comparator&lt;Student&gt; {

	@Override
	public int compare(Student o1, Student o2) {
		return o1.age - o2.age;
	}
}
Arrays.sort(students, new IdAscendingComparator());
// 无返回值
</code></pre>
</li>
<li>
<p>利用系统的 **优先级队列PriorityQueue&lt;&gt;**实现堆排序 **add() poll()**方法分别实现建堆和弹出堆头</p>
</li>
<li>
<p>利用系统的 **TreeSetp&lt;&gt; **实现红黑树</p>
</li>
</ul>
</li>
</ul>
<p>常见基于比较的排序方法性能汇总表</p>
<table>
<thead>
<tr>
<th>排序方法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>选择</td>
<td>N<sup>2</sup></td>
<td>1</td>
<td>no</td>
</tr>
<tr>
<td>冒泡</td>
<td>N<sup>2</sup></td>
<td>1</td>
<td>yes</td>
</tr>
<tr>
<td>插入</td>
<td>N<sup>2</sup></td>
<td>1</td>
<td>yes</td>
</tr>
<tr>
<td>归并</td>
<td>N*logN</td>
<td>N</td>
<td>yes</td>
</tr>
<tr>
<td>快排</td>
<td>N*logN</td>
<td>logN</td>
<td>no</td>
</tr>
<tr>
<td>堆</td>
<td>N*logN</td>
<td>1</td>
<td>no</td>
</tr>
</tbody>
</table>
<p><strong>常见注意事项：</strong></p>
<ol>
<li>“原定归并排序”会让时间复杂度上升到 N<sup>2</sup> 不实用；</li>
<li>工程上在小数量样本下，使用插入排序进行综合排序利用 NLogN和 N<sup>2</sup>的优势；</li>
<li></li>
</ol>
<p>快排的常数项实践下来最快</p>
<h3 id="0101-快排">01.01 快排</h3>
<p>思想: 荷兰国旗问题——&gt;在左右区间内再次荷兰国旗划分</p>
<img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/Zq7KoU.png" alt="Zq7KoU" style="zoom: 50%;" />
<pre><code class="language-java">public static int[] partition(int[] arr, int l, int r, int p) {	int less = l - 1; //小于p的区域的下标最大值边界	int more = r + 1; //大于p的区域下标最小值边界	while (l &lt; more) {		if (arr[l] &lt; p) {			swap(arr, ++less, l++);		} else if (arr[l] &gt; p) {			swap(arr, --more, l);		} else {			l++;		}	}	return new int[] { less + 1, more - 1 };	//返回等于区域的数组下标范围}public static int[] swap(int[] arr, int i, int j) {    int temp = arr[i];    arr[i] = arr[j];    arr[j] = temp;    return arr;}
</code></pre>
<ul>
<li>
<p>经典快排</p>
<ul>
<li>
<p>以数组最后一个数作为基准 重复荷兰国旗划分</p>
<pre><code class="language-java">public static void quickSort(int[] arr) {	if (arr == null || arr.length &lt; 2) {		return;	}	quickSort(arr, 0, arr.length - 1);}public static void quickSort(int[] arr, int l, int r) {	if (l &lt; r) {		swap(arr, l + (int) (Math.random() * (r - l + 1)), r);		int[] p = partition(arr, l, r);        //经典快排的改进——&gt;对于等于选择基点的区域不参与递归排序		quickSort(arr, l, p[0] - 1);		quickSort(arr, p[1] + 1, r);	}}public static int[] partition(int[] arr, int l, int r) {	int less = l - 1;	int more = r;	while (l &lt; more) {		if (arr[l] &lt; arr[r]) {			swap(arr, ++less, l++);		} else if (arr[l] &gt; arr[r]) {			swap(arr, --more, l);		} else {			l++;		}	}	swap(arr, more, r);	return new int[] { less + 1, more };}public static void swap(int[] arr, int i, int j) {	int tmp = arr[i];	arr[i] = arr[j];	arr[j] = tmp;}
</code></pre>
</li>
<li>
<p>问题:  大于和小于基准的区域大小不相等(总拿数组最后一个数作为基准 最坏情况下会是O(N^2)) 与数据状态息息相关</p>
</li>
</ul>
</li>
<li>
<p>随机快排: 使得概率事件 使用长期期望方式算出时间复杂度 <strong>O(N*logN)</strong> 随机快排的空间复杂度O(logN)</p>
<ul>
<li>
<pre><code class="language-java">swap(arr, L + (int) (Math.random()*(R - L + 1)), R);// L-R上等概率的随机选择一个数将其与最后一个数交换 使得函数结构上复用 //hash也可以
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="0102-堆排序">01.02 堆排序</h3>
<ul>
<li>
<p>完全二叉树: 依次在下一层按照顺序从左到右补齐</p>
<ul>
<li>
<p>堆可以用数组来实现  又称为<strong>优先级队列</strong></p>
<ul>
<li>数组与完全二叉树之间的转换:</li>
<li>数组中位置i的左孩子的下标为<code>2*i+1</code> 右孩子为<code>2*i+2</code>  父节点的对应下标为<code>(i-1)/2</code>  0的父节点为0</li>
</ul>
</li>
<li>
<p><strong>堆的理解</strong>: 完全二叉树</p>
<ul>
<li>
<p>大根堆——&gt;完全二叉树中任何一个子树的最大值都是头部</p>
<ul>
<li>
<p>建立: 遍历数组, 与其父节点比较直至到根节点, 过程中自己比父节点的值大则swap 若小/等则跳出向上比较的循环 与现有的树高度有关h O(logN)</p>
<p>建立过程中的复杂度：</p>
</li>
<li>
<p>调整:  下沉 heapify() 不断与孩子中的最大值比较</p>
</li>
<li>
<pre><code class="language-java">	public static void heapify(int[] arr, int index, int size) {  		int left = index * 2 + 1;  		while (left &lt; size) {  			//这里是右孩子存在&amp;&amp;右孩子大于左孩子的值情况下选择left+1 否则都是left  			int largest = left + 1 &lt; size &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left;  			// 比较与我待查本身的值  			largest = arr[largest] &gt; arr[index] ? largest : index;  			if (largest == index) {  				break;  			}  			swap(arr, largest, index);  			// while循环继续的增量条件  			index = largest;  			left = index * 2 + 1;  		}  	}
</code></pre>
</li>
</ul>
</li>
<li>
<p>小根堆——&gt;任何一个子树的最小值都是其头部</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="0103-非基于比较的排序">01.03 非基于比较的排序</h3>
<hr>
<p>一种数据状况出现的词频</p>
<h4 id="桶排序">桶排序</h4>
<h3 id="0104-bubbleinsertsortselectsort">01.04 Bubble+InsertSort+SelectSort</h3>
<ul>
<li>
<p><code>BubbleSort</code></p>
<ul>
<li>
<p>逐个比较 最值上浮——&gt;则外围循环为从右到左 使得j+1与j比较得到最值上浮</p>
<pre><code class="language-java">public static void BubbleSort(int[] nums) {    if (nums == null || nums.length &lt; 2) {        return;    }    for (int i = nums.length - 1; i &gt; 0; i--) {        for (int j = 0; j &lt; i; j++) {            if (nums[j] &gt; nums[j + 1]) {                swap(nums, j, j + 1);            }        }    }}
</code></pre>
</li>
</ul>
</li>
<li>
<p><code>InsertSort</code></p>
<ul>
<li>
<p>的</p>
<pre><code class="language-java">public static void InsertionSort(int[] nums) {    if (nums==null||nums.length&lt;2) {        return;    }    for (int i = 1; i &lt; nums.length; i++) {        for (int j = i-1; j &gt;0; j--) {            if (nums[j]&gt;nums[j+1]) {                swap(nums,j,j+1);            }        }    }}
</code></pre>
</li>
</ul>
</li>
<li>
<p><code>SelectionSort</code></p>
<ul>
<li>
<p>a</p>
<pre><code class="language-java">public static void SelectionSort(int[] nums) {    if (nums == null || nums.length &lt; 2) {        return;    }    for (int i = 0; i &lt; nums.length - 1; i++) {        int minIndex = i;        for (int j = i + 1; j &lt; nums.length; j++) {            minIndex = nums[j] &lt; nums[minIndex] ? j : minIndex;        }        swap(nums, i, minIndex);    }}
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="02-stack-queue">02 Stack Queue</h2>
<h4 id="0201-队列实现栈结构">02.01 队列实现栈结构</h4>
<pre><code class="language-java">public static class TwoQueuesStack {
    private Queue&lt;Integer&gt; queue;
    private Queue&lt;Integer&gt; help;

    public TwoQueuesStack() {
        queue = new LinkedList&lt;Integer&gt;();
        help = new LinkedList&lt;Integer&gt;();
    }

    public void push(int pushInt) {
        queue.add(pushInt);
    }

    public int peek() {
        if (queue.isEmpty()) {
            throw new RuntimeExceptioan(&quot;Stack is empty!&quot;);
        }
        while (queue.size() != 1) {
            help.add(queue.poll());
        }
        int res = queue.poll();
        help.add(res);
        swap();
        return res;
    }

    public int pop() {
        if (queue.isEmpty()) {
            throw new RuntimeException(&quot;Stack is empty!&quot;);
        }
        while (queue.size() &gt; 1) {
            help.add(queue.poll());
        }
        int res = queue.poll();
        swap();
        return res;
    }

    private void swap() {
        Queue&lt;Integer&gt; tmp = help;
        help = queue;
        queue = tmp;
    }

}
</code></pre>
<h4 id="0202-栈实现队列结构">02.02 栈实现队列结构</h4>
<p>使用两个栈实现队列,支持队列的基本操作(add poll peek)</p>
<ul>
<li>stackPush向stackPop压入数据, 必须一次性将stackPush数据压入;</li>
<li>stackPop非空, 不可压入数据</li>
</ul>
<pre><code class="language-java">import java.util.Stack;

public class TwoStackWithQueue {

    public Stack&lt;Integer&gt; stackPush;
    public Stack&lt;Integer&gt; stackPop;
    public TwoStackWithQueue(){
        stackPop=new Stack&lt;Integer&gt;();
        stackPush=new Stack&lt;Integer&gt;();
    }

    //push栈向pop栈倒入数据
    private void pushTopop() {
        if(stackPop.empty()) {
            while (!stackPush.empty()) {
                stackPop.push(stackPush.pop());
            }
        }
    }
    public void add(int pushInt) {
        stackPush.push(pushInt);
        pushTopop();
    }

    public int poll() {
        if(stackPop.empty()&amp;&amp;stackPush.empty()) {
            throw new RuntimeException(&quot;Queue is empty!&quot;);
        }
        pushTopop();
        return stackPop.pop();
    }

    public int peek() {
        if(stackPop.empty()&amp;&amp;stackPush.empty()) {
            throw new RuntimeException(&quot;Queue is empty!&quot;);
        }
        pushTopop();
        return stackPop.peek();
    }
}

</code></pre>
<h2 id="03-链表">03 链表</h2>
<pre><code class="language-java">public class ListNode{
    int val;
    ListNode next = null;
    
    ListNode(int val) {
        this.val = val;
    }
}
</code></pre>
<p>回文链表</p>
<ul>
<li>快慢指针,当快指针到链尾即慢指针到链中。慢指针继续遍历的下一半链表不断入栈, 入完后弹出与前半比较;</li>
<li>不用辅助空间</li>
</ul>
<p>访问 搜索 插入 删除</p>
<pre><code class="language-java">private ListNode reverseListNode (ListNode head) {
    ListNode cur =head;
    ListNode prev =null;
    while (cur != null) {
        ListNode next = cur.Next;
        cur.Next=prev;
        prev=cur;
        cur=next;
    }
    return prev;
}
</code></pre>
<h3 id="0301-数组与链表的转化">03.01 数组与链表的转化</h3>
<pre><code class="language-java">ListNode listNode = new ListNode(Arrays.asList(arry));
</code></pre>
<h3 id="0302-链表环">03.02 链表环</h3>
<ul>
<li>
<p><strong>找环思路</strong></p>
<ul>
<li>快慢分别走 直到两只相遇</li>
<li>其中快指针回到头结点 以正常步伐+1 与慢指针同步走 直到两者相遇</li>
<li>相遇结点即为头结点</li>
</ul>
</li>
<li>
<p>**两表首个公共结点思路: **</p>
<ul>
<li>先判断是否有环 Ring  成环必然在环处开始重合</li>
<li>无环则 长链表走两表长度差值 gap 步伐  再长短链表指针同步走直到相遇 相遇点为首公共结点</li>
</ul>
</li>
</ul>
<h3 id="0303-两表长度差值一个变量">03.03 两表长度差值—一个变量</h3>
<p>一个变量即可实现</p>
<pre><code class="language-java">int cnt = 0;
while (cur1!=null) {
    cnt++; //遍历第一个链表时++
    cur1=cur1.next;
}
while (cur2!=null) {
    cnt--;	//遍历第二个链表时--
    cur2=cur2.next;
}
cnt = Math.abs(cnt);	// 二链表长&gt;一链表长时cnt&lt;0 
</code></pre>
<h2 id="04-二叉树">04 二叉树</h2>
<pre><code class="language-java">public static class TreeNode {	public int val;    public TreeNode left;    public TreeNode right;    public TreeNode(int val) {        this.val = val;    }}
</code></pre>
<h4 id="0401-递归遍历二叉树">04.01 递归遍历二叉树</h4>
<hr>
<p>三者访问访问二叉树的次序一致, 只是不同时机输出</p>
<pre><code class="language-java">// 先序递归遍历二叉树public static void preOrderRecur(TreeNode head) {    if(head == null) {        return;    }    System.out.print(head.val+&quot; &quot;);    preOrderRecur(head.left);    preOrderRecur(head.right);}// 中序递归遍历二叉树public static void preOrderRecur(TreeNode head) {    if(head == null) {        return;    }    preOrderRecur(head.left);    System.out.print(head.val+&quot; &quot;);    preOrderRecur(head.right);}// 后序递归遍历二叉树public static void preOrderRecur(TreeNode head) {    if(head == null) {        return;    }    preOrderRecur(head.left);    preOrderRecur(head.right);    System.out.print(head.val+&quot; &quot;);}// 三者访问访问二叉树的次序一致, 只是不同实际输出
</code></pre>
<h4 id="0402-非递归遍历二叉树">04.02 非递归遍历二叉树</h4>
<hr>
<p>递归本质上就是栈 由于二叉树提供节点只能向下访问 无法返回 故而使用栈结构实现返回</p>
<pre><code class="language-java">public static List&lt;Integer&gt; inOrderTraversalBT(TreeNode root) {    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();    //空树则直接返回null的res    if (root == null) {        return res;    }    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();    // 保存root    TreeNode cur = root;    while (cur != null || !stack.isEmpty()) {        // 向树的最左侧走 并不断压栈        while (cur != null) {            stack.push(cur);            cur = cur.left;        }        // 走完最左侧后弹栈顶        TreeNode node = stack.pop();        res.add(node.val);        // 往上层的右边去再重复找最左侧        cur = node.right;    }    return res;}public static List&lt;Integer&gt; preOrderTraversalBT(TreeNode root) {    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();    //空树则直接返回null的res    if (root == null) {        return res;    }    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();    // 保存root    TreeNode cur = root;    while (cur != null || !stack.isEmpty()) {        // 向树的最左侧走 并不断压栈入数组        while (cur != null) {            res.add(cur.val);            stack.push(cur);            cur = cur.left;        }        // 走完最左侧后弹栈顶 无须入组 cur循环内已经入组        TreeNode node = stack.pop();        // 往上层的右边去 再重复找最左侧        cur = node.right;    }    return res;}public static List&lt;Integer&gt; postOrderTraversalBT(TreeNode root) {    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();    //空树则直接返回null的res    if (root == null) {        return res;    }    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();    // 保存root    TreeNode cur = root;    while (cur != null || !stack.isEmpty()) {        // 向树的最右侧走 并不断压栈入数组        while (cur != null) {            res.add(cur.val);            stack.push(cur);            cur = cur.right; // 使得reverse后正常左在前        }        // 走完最右侧后弹栈顶 无须入组 cur循环内已经入组        TreeNode node = stack.pop();        // 往上层的左边去 再重复找最右侧        cur=node.left;    }    Collections.reverse(res);    return res;}
</code></pre>
<p><strong>后继节点:</strong> 二叉树的<em>中序遍历</em>中的下一节点</p>
<p>前驱节点: 二叉树的<em>中序遍历</em>的前一节点</p>
<h4 id="0403-查找后继节点">04.03 查找后继节点</h4>
<hr>
<ul>
<li>通过parent找到根节点 再中序遍历</li>
<li></li>
</ul>
<h4 id="0404-平衡二叉树">04.04 平衡二叉树</h4>
<hr>
<p>树中的任何一个节点其左右子树高度差在1以内</p>
<p>满二叉树一定是平衡二叉树</p>
<p>空树是平衡树</p>
<pre><code class="language-java">
</code></pre>
<h4 id="0404-搜索二叉树-bst">04.04 搜索二叉树 BST</h4>
<hr>
<p>二叉树中序遍历的结果是依次升序的 一般无重复节点</p>
<p>LC-99-recoverTree</p>
<p>​	两结点被错误交换 还原</p>
<pre><code class="language-java">// 非常妙的两个if 使得中序遍历的pre和node在不断比较大小找出错误的位置if (firstNode == null &amp;&amp; preNode.val &gt; node.val) {    firstNode = preNode;}if (firstNode != null &amp;&amp; preNode.val &gt; node.val) {    secondNode = node;}
</code></pre>
<blockquote>
<p>第一个节点，是第一个按照中序遍历时候前一个节点大于后一个节点，我们选取前一个节点，这里指节点 ；</p>
<p>第二个节点，是在第一个节点找到之后，后面出现前一个节点大于后一个节点，我们选择后一个节点，这里指节点 ；</p>
</blockquote>
<h4 id="0405-完全二叉树">04.05 完全二叉树</h4>
<hr>
<p><strong>判断</strong>标准二叉树按层遍历:</p>
<p>​	该节点有左孩子无右孩子; false</p>
<p>​	该节点有左孩子没有右孩子/两者都没有: 后面遇到的节点均为叶节点;</p>
<p>​</p>
<p>求完全二叉树节点个数:</p>
<p>满二叉树: 高度l 则节点个数<strong>2^l-1</strong></p>
<p>找出</p>
<h4 id="0406-重建二叉树">04.06 重建二叉树</h4>
<pre><code class="language-java">package Tree;import DataStructure.TreeNode;import java.util.Arrays;import static Tree._100_SameTree.isSameTree;public class _105_BuildTree {    /*     * 从前序和后序遍历结果构造二叉树     * */    public static void main(String[] args) {        TreeNode root = new TreeNode(1);        root.left = new TreeNode(2);        root.right = new TreeNode(3);        root.left.left = new TreeNode(4);        root.left.right = new TreeNode(5);        root.right.right = new TreeNode(7);        root.right.left = new TreeNode(6);        root.left.left.left = new TreeNode(8);        root.left.left.right = new TreeNode(9);        int[] preorder = {1, 2, 4, 8, 9, 5, 3, 6, 7};        int[] inorder = {8, 4, 9, 2, 5, 1, 6, 3, 7};        TreeNode root2 = buildTree(preorder, inorder);        System.out.println(isSameTree(root2, root));    }    public static TreeNode buildTree(int[] preorder, int[] inorder) {        if (preorder.length == 0) {            return null;        }        assert (preorder.length == inorder.length);        TreeNode root = new TreeNode(preorder[0]);        for (int i = 0; i &lt; preorder.length; i++) {            // 找到root在中序遍历数组中的位置            if (preorder[0] == inorder[i]) {                /*将前 中序遍历数组各分为两半*/                int[] preLeft = Arrays.copyOfRange(preorder, 1, i + 1);                int[] preRight = Arrays.copyOfRange(preorder, i + 1, preorder.length);                int[] inLeft = Arrays.copyOfRange(inorder, 0, i);                int[] inRight = Arrays.copyOfRange(inorder, i + 1, inorder.length);                // 递归处理左右两部分                root.left = buildTree(preLeft, inLeft);                root.right = buildTree(preRight, inRight);                break;            }        }        return root;    }}
</code></pre>
<pre><code class="language-java">public static TreeNode buildTree(int[] inorder, int[] postorder) {    if (inorder == null || postorder == null) {        return null;    }    return helper(inorder, postorder);}private static TreeNode helper(int[] in, int[] post) {    if (in.length == 0) {        return null;    }    //根据后序数组的最后一个元素，创建根节点    TreeNode root = new TreeNode(post[post.length - 1]);    //在中序数组中查找值等于【后序数组最后一个元素】的下标    for (int i = 0; i &lt; in.length; ++i) {        if (in[i] == post[post.length - 1]) {            //确定这个下标i后，将中序数组分成两部分，后序数组分成两部分            int[] inLeft = Arrays.copyOfRange(in, 0, i);            int[] inRight = Arrays.copyOfRange(in, i + 1, in.length);            int[] postLeft = Arrays.copyOfRange(post, 0, i);            int[] postRight = Arrays.copyOfRange(post, i, post.length - 1);            //递归处理中序数组左边，后序数组左边            root.left = helper(inLeft, postLeft);            //递归处理中序数组右边，后序数组右边            root.right = helper(inRight, postRight);            break;        }    }    return root;}
</code></pre>
<h2 id="05-lfu-lfu算法">05 <code>LFU &amp; LFU</code>算法</h2>
<p>https://mp.weixin.qq.com/s?__biz=MzA4NDE4MzY2MA==&amp;mid=2647524319&amp;idx=1&amp;sn=fdca85b7bb34d46e428a0d240f810811&amp;chksm=87d1bcdcb0a635caecf466761bcd224846f9fa93711c0da35115bb25ea904ddfb4b172389a2f&amp;mpshare=1&amp;scene=1&amp;srcid=0522hQRdOsdk14xOj8EYzGDY&amp;sharer_sharetime=1621651227490&amp;sharer_shareid=116ef760e9b961326f61bb96be400660#rd</p>
<blockquote></blockquote>
<h3 id="概念">概念</h3>
<p>LFU 算法即为 Least Frequently Used Algorithm 最不常用算法，发生缺页中断时选择访问次数最少的页面中断</p>
<p>LRU 算法即为 Least Recently Usef Algorithm 最近常用算法，缺页中断时优先最久没有访问的页面</p>
<blockquote>
<p>LRU 考察多久未访问，时间越短越好；</p>
<p>LFU 考虑访问频率，访问次数越多越好</p>
</blockquote>
<h3 id="question">Question</h3>
<blockquote>
<p>请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。</p>
<p>实现 LFUCache 类：</p>
<p><code>LFUCache(int capacity)</code> - 用 LFU 的容量 capacity 初始化对象<code>int get(int key)</code> - 如果键存在于缓存中，则获取键的值并返回，否则返回 -1。<code>void put(int key, int value)</code> - 如果键已存在，则更新其值；如果键不存在，请插入键值对。当缓存达到其容量时，则应该在插入新页之前，淘汰最不经常使用的页。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 <strong>最近最久未使用</strong> 的键。注意「项的使用次数」就是自插入该项以来对其调用 get 和 put 函数的次数之和。使用次数会在对应项被移除后置为 0 。</p>
<p>为了确定最不常使用的键，可以为缓存中的每个键维护一个 使用计数器 。使用计数最小的键是最久未使用的键。</p>
<p>当一个键首次插入到缓存中时，它的使用计数器被设置为 1 (由于 put 操作)。对缓存中的键执行 get 或 put 操作，使用计数器的值将会递增。</p>
</blockquote>
<h3 id="solution">Solution</h3>
<p>哈希算法+双向链表可以实现查找、插入删除均为 O(1)的数据结构</p>
<pre><code class="language-java">class Cache {    private Map&lt;Integer,Node&gt; cache;    public int get(int key) {}    public void put(int key, int value) {}    class DoublelinkedList {}}
</code></pre>
<h2 id="06-表">06 表</h2>
<h3 id="0601-概念">06.01 概念</h3>
<p><strong>哈希表：</strong></p>
<ol>
<li>使用可被视为集合结构 不允许重复</li>
<li>只有 <code>Key</code>使用 HashSet，有<code>Key &amp; Value</code>使用 HashMap 两者的底层结构实际一致</li>
<li>哈希表的增删改查可视为时间复杂度为<code>O(1)</code> 但常数时间较大 put remove put get</li>
<li>基础类型存放内部按值传递——&gt;占用大小为其本身；其他按引用传递，内存占用为其本身内存地址大小</li>
</ol>
<p><strong>有序表：</strong></p>
<ol>
<li>集合结构</li>
<li>TreeSet 和 TreeMap 结构表示，两者底层一致；有序（双向链表）</li>
<li>红黑树 AVL树 size-balance-tree  跳表均为有序表</li>
<li></li>
</ol>
<h2 id="07-堆">07 堆</h2>
<h3 id="0701-数据流问题">07.01 数据流问题</h3>
<h4 id="滑动窗口最大值">滑动窗口最大值</h4>
<ul>
<li>
<p>最大堆</p>
<ul>
<li>
<p>时间复杂度是 O(N*log K)</p>
</li>
<li>
<pre><code class="language-java">PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(Comparator.reverseOrder());
int[] res = new int[nums.length - k + 1];
for (int i = 0; i &lt; k; i++) {
    maxHeap.add(nums[i]);
}
res[0]= maxHeap.peek();
for (int i = 0,j=i+k;j&lt;nums.length;j++,i++) {
    maxHeap.remove(nums[i]);
    maxHeap.add(nums[j]);
    res[i+1]= maxHeap.peek();
}
return res;
</code></pre>
</li>
</ul>
</li>
<li>
<p>单调队列——&gt;Dqueue 双端队列 队首为最大值 队尾为数据流进入的入口 单向流动的队列</p>
<ul>
<li>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/image-20210731171727928.png" alt="image-20210731171727928" loading="lazy"></figure>
</li>
<li>
<p>有效降低复杂度</p>
</li>
</ul>
</li>
</ul>
<pre><code class="language-java">Deque&lt;Integer&gt; queue = new ArrayDeque&lt;&gt;();
int index = 0;
int[] res = new int[nums.length - k + 1];
for (int i = 0; i &lt; nums.length; i++) {
    // peekLast 从后面看的最后一个元素
    while (!queue.isEmpty() &amp;&amp; nums[i] &gt; queue.peekLast()) {
		// 弹出最后一个元素
        queue.pollLast();  
    }
    queue.addLast(nums[i]);
    if (i&gt;=k-1) {
        res[index++] = queue.peekFirst();
        if (i&gt;=k-1&amp;&amp;nums[i-k+1]==queue.peekFirst()) {
            queue.removeFirst();
        }
    }
}
return res;
</code></pre>
<h4 id="中位数">中位数</h4>
<p>大根堆存较小部分 小根堆存较大部分 小根堆长度尽量长</p>
<p>​	先入大根堆MaxHeap.add(num) 将大根堆的堆顶为较大部分 再讲较大部分入小根堆 MinHeao</p>
<p>minHeap.add(maxHeap.poll())</p>
<p>两堆的 size 相同则取 (minHeap.peek()+maxHeap.peek())/2.0</p>
<p>不等则取 minHeap.peek() (因为保证小根堆较长)</p>
<pre><code class="language-java">Queue&lt;Integer&gt; minHeap, maxHeap;

public void addNum(int num) {
    minHeap = new PriorityQueue&lt;&gt;();
    maxHeap = new PriorityQueue&lt;Integer&gt;(Comparator.reverseOrder());
    if (minHeap.size() == maxHeap.size()) {
        maxHeap.add(num); // 利用大根堆过滤出较大的部分maxHeap.poll() 再入小根堆minHeap
        minHeap.add(maxHeap.poll());
    } else {
        minHeap.add(num);
        maxHeap.add(minHeap.poll());
    }
}

public double findMedian() {
    // 两堆大小相等则取中值 不等为小根堆堆顶
    return maxHeap.size() == minHeap.size() ? ((minHeap.peek() + maxHeap.peek()) / 2.0) : minHeap.peek();

}
</code></pre>
<h2 id="08-单调栈">08 单调栈</h2>
<p><code>Monotonic Stack</code> 栈中元素按照单调顺序排列 ——&gt; 时间复杂度为线性 O(N) 每个元素遍历一次</p>
<h3 id="0801-模板">08.01 模板</h3>
<ul>
<li>维持递增栈</li>
<li>放入最后结果</li>
<li>当前元素入栈</li>
</ul>
<p>eg:</p>
<pre><code class="language-java">private static int[] nextGreaterElemenet(int[] nums) {
    int[] res = new int[nums.length];
    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
    for (int i = nums.length - 1; i &gt;= 0; i--) {
        // 维护单调栈的递增顺序 当要加入的值大于栈顶元素时 抛出栈顶丢弃 保证栈顶最小
        while (!stack.isEmpty() &amp;&amp; nums[i] &gt;= stack.peek()) {
            stack.pop();
        }
        // add the result to stack
        res[i] = stack.isEmpty() ? -1 : stack.peek();
        // action to come in stack
        stack.push(nums[i]);
    }
    return res;
}
</code></pre>
<h3 id="0802-tips">08.02 tips</h3>
<ul>
<li>
<p>最近最大的数——&gt;单调栈的特征</p>
</li>
<li>
<p>循环数组——&gt;</p>
</li>
<li>
<pre><code class="language-java">for (int i = 0; i &lt; 2 * len; i++) {
	// 遍历值的下标为 i%len
    int num = nums[i % len];
    while (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; num) {
        res[stack.pop()]=num;
    }
    if (i&lt;len) {
        stack.push(i);
    }
}
</code></pre>
</li>
<li></li>
</ul>
<h2 id="09-滑动窗口">09 滑动窗口</h2>
<p>连续元素 String subarray  linkedlistst</p>
<p>min max longest shorte  key word</p>
<p>本质上是two points 左边是 left 右边是 iterator(i)</p>
<h3 id="0901-模板">09.01 模板</h3>
<p>进——&gt;出——&gt;算</p>
<ul>
<li>将当前遍历值入窗口</li>
<li>窗口条件不符合时候 left 持续退出</li>
<li>窗口有效 valid 情况下 计算结果</li>
</ul>
<pre><code class="language-java">public int lengthofLongestSubstringTwoDistinct(String s, int k) {
    HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();
    int left = 0, res = 0;
    for (int i = 0; i &lt; s.length(); i++) {
        char cur = s.charAt(i);
        // 遍历值入窗口
        map.put(cur, map.getOrDefault(cur, 0) + 1);
        // 窗口不符合条件 left 持续退出
        while (map.size() &gt; k) {
            char c = s.charAt(left);
            map.put(c, map.get(c) - 1);
            if (map.get(c) == 0) {
                map.remove(c);
            }
            // size超过窗口大小即left 左移
            left++;
        }
        // 计算子串最值
        res = Math.max(res, i - left + 1);
    }
    return res;
}
</code></pre>
<h2 id="tips"><code>Tips</code></h2>
<h3 id="01-位移运算">01 位移运算</h3>
<ul>
<li>
<p>左移 扩大</p>
<ul>
<li>
<p><code>1&gt;&gt;4</code> 即1 * 2 * 2 * 2 * 2 = 16 左移 4 位即pow（2,4）</p>
</li>
<li>
<p>Java提供的位运算符有：左移( <code>&lt;&lt;</code> )、右移( <code>&gt;&gt;</code> ) 、无符号右移( <code>&gt;&gt;&gt;</code> ) 、位与( <code>&amp;</code> ) 、位或( <code>|</code> )、位非( <code>~</code> )、位异或( <code>^</code> )，除了位非( <code>~</code> )是一元操作符外，其它的都是二元操作符。</p>
<h4 id="1-左移">1. 左移( &lt;&lt; )</h4>
<p>a &lt;&lt; b 表示将数值 a 的二进制数值从 0 位算起到第 b - 1 位，整体向左方向移动 b 位，符号位不变，低位空出来的位补数值 0。</p>
<pre><code class="language-shell">a &lt;&lt; b = a * (2 ^ b)
</code></pre>
<h4 id="2-右移">2. 右移( &gt;&gt; )</h4>
<p><strong>a &gt;&gt; b</strong> 表示将数值 a 的二进制数值从 0 位算起到第 b - 1 位，整体向右方向移动 b 位，符号位不变，高位空出来的位补数值 0。</p>
<pre><code>a &gt;&gt; b = a / ( 2 ^ b )
</code></pre>
<h4 id="3-无符号右移">3. 无符号右移( &gt;&gt;&gt; )</h4>
<p>无符号右移运算符&gt;&gt;&gt;和右移运算符&gt;&gt;是一样的，只不过右移时左边是补上符号位，而无符号右移运算符是补上0，也就是说，对于正数移位来说等同于：&gt;&gt;，负数通过此移位运算符能移位成正数。</p>
<h4 id="4-位与">4. 位与( &amp; )</h4>
<p>与运算时，进行运算的两个数，从最低位到最高位，一一对应。如果某 bit 的两个数值对应的值都是 1，则结果值相应的 bit 就是 1，否则为 0.</p>
<pre><code class="language-java">0 &amp; 0 = 0,

0 &amp; 1 = 0,

1 &amp; 1 = 1
</code></pre>
<h4 id="5-位或">5. 位或( | )</h4>
<p>与运算时，进行运算的两个数，从最低位到最高位，一一对应。如果某 bit 的两个数值对应的值只要 1 个为 1，则结果值相应的 bit 就是 1，否则为 0。</p>
<pre><code class="language-java">0 | 0 = 0,0 | 1 = 1,1 | 1 = 1
</code></pre>
<h4 id="6-位异或">6. 位异或( ^ )</h4>
<p>两个操作数进行异或时，对于同一位上，如果数值相同则为 0，数值不同则为 1。</p>
<pre><code class="language-java">1 ^ 0 = 1,1 ^ 1 = 0,0 ^ 0 = 0;
</code></pre>
<h4 id="7-位非-~">7. 位非( ~ )</h4>
<p>对操作数的每一位进行操作，1 变成 0，0 变成 1。</p>
</li>
</ul>
</li>
</ul>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://flyingchase.github.io/post/xps-7590-hackintosh-hei-ping-guo/">
              <h3 class="post-title">
                下一篇：XPS 7590 Hackintosh黑苹果
              </h3>
            </a>
          </div>
          
      </div>

      

      <div class="site-footer">
  <div class="slogan">记录成长的脚印</div>
  <div class="social-container">
    
      
        <a href="https://github.com/flyingchase" target="_blank">
          <i class="fab fa-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
   | <a class="rss" href="https://flyingchase.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
