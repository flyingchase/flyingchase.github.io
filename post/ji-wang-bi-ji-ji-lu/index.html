
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>计网笔记记录 | flyingchase</title>
<meta name="description" content="一两黄金一两风">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://flyingchase.github.io/favicon.ico?v=1637729984440">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://flyingchase.github.io/styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://flyingchase.github.io">
        <img class="avatar" src="https://flyingchase.github.io/images/avatar.png?v=1637729984440" alt="" width="32px" height="32px">
      </a>
      <a href="https://flyingchase.github.io">
        <h1 class="site-title">flyingchase</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/" class="menu purple-link">
            首页
          </a>
        
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/tags" class="menu purple-link">
            标签
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
          <h2 class="post-title">计网笔记记录</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2021-10-31</span>
            
          </div>
          <div class="post-content">
            <p>收集于互联网，侵删</p>
<h1 id="计网八股文">计网八股文</h1>
<h2 id="osi-参考模型">OSI 参考模型</h2>
<p>OSI 从上到下分为 7 层：</p>
<p>应用层：应用层协议定义的是应用进程间的通信和交互的规则，不同的网络应用需要不同的应用层协议<br>
表示层：把数据转换为能与接收者的系统格式兼容并适合传输的格式<br>
会话层：在数据传输中设置和维护电脑网络中两台电脑之间的通信连接<br>
传输层：向两台主机进程之间的通信提供通用的数据传输服务<br>
网络层：基于网络层地址（IP地址）进行不同网络系统间的路径选择<br>
数据链路层：在不可靠的物理介质上提供可靠的传输<br>
物理层：在局域网上透明地传送比特，尽可能屏蔽掉具体传输介质和物理设备的差异</p>
<h2 id="tcpip-参考模型">TCP/IP 参考模型</h2>
<p>从上到下分为 4 层，对应于 OSI 中的 5 层：</p>
<ol>
<li>应用层：对应于 OSI 参考模型的应用层，为用户提供所需要的各种服务。定义的是应用进程间的通信和交互的规则，不同的网络应用需要不同的应用层协议。协议包括 SMTP、HTTP、FTP 等</li>
<li>传输层：对应于 OSI 参考模型的传输层，为应用层实体提供端到端的、通用的通信功能，保证了数据包的顺序传送及数据的完整性。“通用的”是指不同的应用可以使用同一个运输层服务。协议包括 TCP、UDP 等</li>
<li>网络层（或网际互联层）：对应于 OSI 参考模型的网络层，主要解决主机到主机的路由问题。协议包括 IP、ICMP 等</li>
<li>网络接入层：对应于 OSI 参考模型的物理层和数据链路层，负责相邻的物理节点间的可靠数据传输。协议包括 ARP、IEEE 802.2 等</li>
</ol>
<h2 id="tcpip-参考模型各层常见协议">TCP/IP 参考模型各层常见协议</h2>
<figure data-type="image" tabindex="1"><img src="/Users/qlzhou/Desktop/protocol.png" alt="protocol" loading="lazy"></figure>
<p>![5cKLtR](/Users/qlzhou/Desktop/TCP 参考模型各层协议.png)</p>
<p>将“网络接入层”进一步分为“数据链路层”与“物理层”，得到五层协议模型。各层的常见协议如下：</p>
<table>
<thead>
<tr>
<th>TCP/IP 协议层</th>
<th>协议</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层</td>
<td>HTTP</td>
<td>超文本传输协议（HyperText Transfer Protocol）</td>
</tr>
<tr>
<td></td>
<td>FTP</td>
<td>文件传输协议（File Transfer Protocol）用于在客户端和服务器之间进行文件传输</td>
</tr>
<tr>
<td></td>
<td>SMTP</td>
<td>文件传输协议（File Transfer Protocol）用于在客户端和服务器之间进行文件传输</td>
</tr>
<tr>
<td></td>
<td>TELNET</td>
<td>Telnet 是服务器远程登录控制的标准协议与主要方式</td>
</tr>
<tr>
<td></td>
<td>DNS</td>
<td>域名系统（Domain Name System）是域名和 IP 地址相互映射的分布式数据库</td>
</tr>
<tr>
<td></td>
<td>SSH</td>
<td>安全外壳协议（Secure Shell）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境</td>
</tr>
<tr>
<td></td>
<td>DHCP</td>
<td>动态主机配置协议（Dynamic Host Configuration Protocol）的主要作用是集中管理、动态分配 IP 地址，提升地址的使用率</td>
</tr>
<tr>
<td>传输层</td>
<td>TCP</td>
<td>传输控制协议（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议</td>
</tr>
<tr>
<td></td>
<td>UDP</td>
<td>用户数据报协议（User Datagram Protocol）是一个简单的、无连接的、不可靠的、面向数据报的通信协议</td>
</tr>
<tr>
<td>网络层</td>
<td>IP</td>
<td>网际协议（Internet Protocol）是用于分组交换数据网络的一种协议，功能包括寻址、路由、尽最大努力交付数据包</td>
</tr>
<tr>
<td></td>
<td>ICMP</td>
<td>互联网控制消息协议（Internet Control Message Protocol）用于返回通信环境的错误消息。traceroute 和 ping 都是基于 ICMP 消息实现的，traceroute 是通过发送含有特殊 TTL 的包，然后接收 ICMP 超时消息和目标不可达消息来实现的；ping 则是用 ICMP 的“Echo request (8)”和“Echo reply (0)”消息来实现的</td>
</tr>
<tr>
<td></td>
<td>IGMP</td>
<td>因特网组管理协议（Internet Group Management Protocol ）管理 IP 协议多播组成员</td>
</tr>
<tr>
<td></td>
<td>RIP</td>
<td>路由信息协议（Routing Information Protocol）是一种内部网关协议（IGP），是距离向量路由协议的一种实现</td>
</tr>
<tr>
<td></td>
<td>OSFP</td>
<td>开放式最短路径优先（Open Shortest Path First）是一种内部网关协议（IGP），使用 Dijkstra 算法计算最短路径，是链路状态路由协议的一种实现</td>
</tr>
<tr>
<td></td>
<td>BGP</td>
<td>边界网关协议（Border Gateway Protocol）是互联网上一个核心的去中心化自治路由协议，属于矢量路由协议。BGP 用于互联网上，将自治系统视作一个整体；每个自治系统使用 IGP（代表实现有 RIP 和 OSPF）进行路由</td>
</tr>
<tr>
<td>数据链路层</td>
<td>ARP*</td>
<td>地址解析协议（Address Resolution Protocol）通过 IP 寻找 MAC 地址</td>
</tr>
<tr>
<td></td>
<td>ARQ</td>
<td>自动重传请求（Automatic Repeat-reQuest）是一种错误纠正协议</td>
</tr>
<tr>
<td>物理层</td>
<td>IEEE802</td>
<td>IEEE 802 指 IEEE 标准中关于局域网和城域网的一系列标准，其中最广泛使用的有以太网、令牌环、无线局域网等</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>ARP 协议</strong>：ARP 协议应该属于哪一层？一种说法是属于网络层，因为 IP 协议使用 ARP 协议；另一种说法是属于数据链路层，因为 MAC 地址是数据链路层的内容。在 OSI 模型中，ARP 协议属于链路层；而在 TCP/IP 模型中，ARP 协议属于网络层。</li>
</ul>
<h2 id="集线器-网桥-交换机-路由器">集线器、网桥、交换机、路由器</h2>
<ol>
<li>网线是物理层的硬件</li>
<li>集线器（Hub）是物理层的硬件，连接所有的线路，广播所有信息</li>
<li>网桥（Bridge）是数据链路层的硬件。网桥隔离两个端口，不同的端口形成单独的冲突域，减少网内冲突。网桥在不同或相同类型的 LAN 之间存储并转发数据帧，根据 MAC 头部来决定转发端口，显然是数据链路层的设备</li>
<li>交换机（Switch）是数据链路层的硬件，相当于多端口的网桥。交换机内部存储 MAC 表，只会将数据帧发送到指定的目的地址</li>
<li>路由器（Router）是网络层的硬件，根据 IP 地址进行寻址，不同子网间的数据传输隔离</li>
</ol>
<h2 id="比特-帧-数据包-数据段-报文">比特、帧、数据包、数据段、报文</h2>
<p>PDU：Prtocol data unit，协议数据单元，指对等层协议之间交换的信息单元。PDU 再往上就是数据（data）。</p>
<p>在 OSI 模型里，PDU 和底下四层相关：</p>
<ol>
<li>物理层———<strong>比特（Bit）</strong></li>
<li>数据链路层———<strong>帧（Frame）</strong></li>
<li>网络层———<strong>分组、数据包（Packet）</strong></li>
<li>传输层———<strong>数据段（Segment）</strong></li>
</ol>
<p>第五层或以上为<strong>数据（data）</strong>。也有一种说法是，应用层的信息称为<strong>消息、报文（message）</strong>，表示完整的信息。</p>
<h2 id="msl-ttl-rtt-是什么">MSL、TTL、RTT 是什么？</h2>
<p><strong>MSL</strong>（Maximum segment lifetime）：报文最大生存时间。它是任何 TCP 报文在网络上存在的最长时间，超过这个时间报文将被丢弃。实际应用中常用的设置是 30 秒，1 分钟和 2 分钟。</p>
<ol>
<li>应用场景：TCP 四次挥手时，需要在 TIME-WAIT 状态等待 2MSL 的时间，可以保证本次连接产生的所有报文段都从网络中消失。</li>
</ol>
<p><strong>TTL</strong>（Time to live）：IP 数据报在网络中可以存活的总跳数，称为“生存时间”，但并不是一个真正的时间。该域由源主机设置初始值，每经过一个路由器，跳数减 1，如果减至 0，则丢弃该数据包，同时发送 ICMP 报文通知源主机。取值范围 1-255，如果设置的 TTL 值小于传输过程中需要经过的路由器数量，则该数据包在传输中就会被丢弃。</p>
<p><strong>RTT</strong>（Round trip time）：客户端到服务端往返所花时间。RTT 受网络传输拥塞的变化而变化，由 TCP <strong>动态地估算</strong>。</p>
<h2 id="tcp-的流量控制和拥塞控制">TCP 的流量控制和拥塞控制</h2>
<figure data-type="image" tabindex="2"><img src="/Users/qlzhou/Desktop/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%B4%A0%E6%98%82.png" alt="NrFurg" loading="lazy"></figure>
<pre><code class="language-markdown">1. TCP 的流量控制机制
   - 滑动窗口的原理
   - 零窗口
   - Nagle 算法

2. TCP 的拥塞控制机制
   - 慢启动
     - 每收到一个 ACK，窗口大小+1，倍增
   - 拥塞避免
   - 超时重传
     - 丢包时，慢启动阈值设定为窗口大小的一半
   - 快速重传 / 快速恢复
     - 收到三个重复的 ACK 消息
</code></pre>
<h2 id="tcp-标志位">TCP 标志位：</h2>
<p>TPC 标志位代表了当前请求的目的。一共有六种：</p>
<ol>
<li><strong>SYN</strong>（synchronous）： 发送/同步标志，用来建立连接，和 ACK 标志位搭配使用。A 请求与 B 建立连接时，SYN=1，ACK=0；B 确认与 A 建立连接时，SYN=1，ACK=1</li>
<li><strong>ACK</strong>（acknowledgement）：确认标志，表示确认收到请求</li>
<li>PSH（push） ：表示推送操作，就是指数据包到达接收端以后，不对其进行队列处理，而是尽可能的将数据交给应用程序处理</li>
<li><strong>FIN</strong>（finish）：结束标志，表示关闭一个 TCP 连接</li>
<li>RST（reset）：重置复位标志，用于复位对应的 TCP 连接</li>
<li>URG（urgent）：紧急标志，用于保证 TCP 连接不被中断，并且督促中间层设备尽快处理</li>
</ol>
<h2 id="tcp-序列号-确认号">TCP 序列号、确认号</h2>
<pre><code class="language-markdown">### 作用
序列号和确认号是 TCP 实现可靠传输的依赖。TCP 使用序列号来记录发送数据包的顺序。TCP 传送一个数据包后，只有在指定时间里收到这个包的确认信息，才会将其从队列中删除，否则会重新发送该数据包。对接收方而言，通过数据分段中的序列号可以保证数据能够按照正常的顺序进行重组。

### 序列号 Sequence Number
- 在 SYN flag 置 1 时，表示当前连接的初始序列号（Initial Sequence Number，ISN）
- 在 SYN flag 置 0 时，表示当前报文段中的第一个字节的序列号

序列号的规则：

- 握手阶段，`[SYN]` 包即使没有传送数据，也会消耗一个序列号。因此，建立连接后的序列号从 `ISN+1` 开始
- 挥手阶段，`[FIN/ACK]` 包即使没有传送数据，也会消耗掉一个序列号
- 数据传输阶段，序列号 = 第一个报文段的序列号 + 已经发送的字节数
  - 比如第一个报文段的序列号为 `S`，已经发送了 100 个字节，则下一个报文段的序列号为 `S+100`
  - 如果某个报文段不携带数据，不会消耗序列号，下一个报文段还是用相同的序列号发送
  - 正常情况下，B 给 A 的确认号，就是 A 下一个报文段的序列号
- 客户端三次握手第三步的 `[ACK]` 包，和传输阶段的第一个报文段，有相同的序列号

### 确认号 Acknowledge Number
- ACK flag 置 1 时才有效，表示接收方期待的下一个报文段的序列号。一般是上次收到的报文段 seq + 1
</code></pre>
<h2 id="三次握手">三次握手</h2>
<h3 id="三次握手过程">三次握手过程</h3>
<img src="/Users/qlzhou/Desktop/A.png" alt="A" style="zoom:70%;" />
<ol>
<li>第一次握手：客户端请求建立连接，向服务端发送一个<strong>同步报文</strong>（SYN synchronous 标志位记为1），同时选择一个随机数 seq（sequence number） = x 作为<strong>初始序列号</strong></li>
<li>第二次握手：服务端收到连接请求报文后，如果同意建立连接，则向客户端发送<strong>同步确认报文</strong>（SYN synchronous为1，ACK acknowledgement 为1），确认号为 ack acknowledge number 为x + 1，同时选择一个随机数 seq sequence number 为y 作为<strong>初始序列号</strong></li>
<li>第三次握手：客户端收到服务端的确认后，向服务端发送一个<strong>确认报文</strong>（ACK标志位 acknowledgement为1），确认号为 ack acknowledge number 为y + 1，序列号为 seq sequence number 为x + 1</li>
</ol>
<p>这时就完成了三次握手，连接建立成功。随后，客户端和服务端的序列号将分别从 <code>x+1</code> 和 <code>y+1</code> 开始进行传输。</p>
<p>客户端在两次握手就进入<code>ESTABLISHED</code>状态，服务端在三次握手后再进入<code>ESTABLISHED</code>状态，故而第三次ACK 可捎带客户端数据一起发送</p>
<h2 id="为什么需要三次握手而不是两次或四次">为什么需要三次握手，而不是两次或四次？</h2>
<figure data-type="image" tabindex="3"><img src="/Users/qlzhou/Desktop/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="F3KgOu" loading="lazy"></figure>
<p>如果只有两次握手，那么服务端向客户端发送 SYN/ACK 报文后，就会认为连接建立。但是如果客户端没有收到报文，那么客户端是没有建立连接的。这就导致服务端会浪费资源。</p>
<ol>
<li>
<p>确认双方的收发能力正常；</p>
</li>
<li>
<p>序号同步的确定性；</p>
<p>缺少最后一次 ACK 则服务端无法确定对方是否收到自己的初始序号，</p>
<p>数据包的序号是 TCP滑动窗口机制的基本字段</p>
</li>
<li>
<p>历史失效链接请求的乱序问题</p>
<p>老的失效请求连接延迟，此时到达服务端，无第三次握手则服务端即开启新的连接进入 ESTABLISHED 状态，有三次握手则会发生 RST 标志 restet 终止连接</p>
</li>
</ol>
<p>为什么不是四次握手？理论上我们总可以使用更多的通信次数交换相同的信息，使用两次握手无法建立 TCP 连接，而使用三次握手是建立连接所需要的最小次数：</p>
<ol>
<li>第一次握手：服务端确认“自己收、客户端发”报文功能正常</li>
<li>第二次握手：客户端确认“自己发、自己收、服务端收、客户端发”报文功能正常，客户端认为连接已建立</li>
<li>第三次握手：服务端确认“自己发、客户端收”报文功能正常，此时双方均建立连接，可以正常通信</li>
</ol>
<h2 id="tcp-第三次握手丢包">TCP 第三次握手丢包</h2>
<p>丢包则触发 TCP重传机制：</p>
<ol>
<li>重试一定次数后，服务端管理连接；</li>
<li>客户端认为建立连接，发送数据；</li>
<li>服务端回复 RST 报文，则客户端知悉链接失效</li>
</ol>
<h2 id="什么是-syn-攻击如何防范">什么是 SYN 攻击？如何防范？</h2>
<p>SYN 攻击属于 DOS 攻击的一种，它利用 TCP 协议缺陷，通过发送大量的半连接请求，耗费 CPU 和内存资源。</p>
<p>原理：</p>
<ol>
<li>在三次握手过程中，服务器发送 <code>[SYN/ACK]</code> 包（第二个包）之后、收到客户端的 <code>[ACK]</code> 包（第三个包）之前的 TCP 连接称为半连接（half-open connect），此时服务器处于 <code>SYN_RECV</code>（等待客户端响应）状态。如果接收到客户端的 <code>[ACK]</code>，则 TCP 连接成功，如果未接受到，则会<strong>不断重发请求</strong>直至成功</li>
<li>SYN 攻击的攻击者在短时间内<strong>伪造大量不存在的 IP 地址</strong>，向服务器不断地发送 <code>[SYN]</code> 包，服务器回复 <code>[SYN/ACK]</code> 包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时</li>
<li>这些伪造的 <code>[SYN]</code> 包将长时间占用未连接队列，影响了正常的 SYN，导致目标系统运行缓慢、网络堵塞甚至系统瘫痪</li>
</ol>
<p>检测：当在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。</p>
<p>防范：主要有两大类，一类是通过防火墙、路由器等过滤网关防护，另一类是通过加固 TCP/IP 协议栈防范，如增加最大半连接数，缩短超时时间。但 SYN 攻击不能完全被阻止，除非将 TCP 协议重新设计，否则只能尽可能的减轻 SYN 攻击的危害。</p>
<h2 id="四次挥手">四次挥手</h2>
<h3 id="四次挥手过程">四次挥手过程</h3>
<img src="/Users/qlzhou/Desktop/B.png" alt="B" style="zoom:80%;" />
<ol>
<li>第一次挥手：客户端向服务端发送连接释放报文（FIN=1，ACK=1），主动关闭连接，同时等待服务端的确认，客户端加入 FIN_WAIT_1
<ol>
<li>序列号 seq = X，即客户端上次发送的报文的最后一个字节的序号 + 1</li>
<li>确认号 ack = Y, 即服务端上次发送的报文的最后一个字节的序号 + 1</li>
</ol>
</li>
<li>第二次挥手：服务端收到连接释放报文后，立即发出<strong>确认报文</strong>（ACK=1），序列号 seq = Y，确认号 ack = X + 1，服务端进入 CLOSE_WAIT，客户端收到后进入FIN_WAIT_2</li>
</ol>
<p>这时 TCP 连接处于半关闭状态，即客户端到服务端的连接已经释放了，但是服务端到客户端的连接还未释放。这表示客户端已经没有数据发送了，但是服务端可能还要给客户端发送数据。</p>
<ol start="3">
<li>第三次挥手：服务端向客户端发送连接释放报文（FIN=1，ACK=1），主动关闭连接，同时等待 A 的确认，客户端进入 LAST_WAIT
<ol>
<li>序列号 seq = w(未发送数据则 w==Y)，即服务端上次发送的报文的最后一个字节的序号 + 1。如果半关闭状态，服务端没有发送数据，那么 w == Y</li>
<li>确认号 ack = X + 1，与第二次挥手相同，因为这段时间客户端没有发送数据</li>
</ol>
</li>
<li>第四次挥手：客户端收到服务端的连接释放报文后，立即发出<strong>确认报文</strong>（ACK=1），序列号 seq = X + 1，确认号为 ack = w + 1，客户端进入 TIME_WAIT</li>
</ol>
<p>此时，客户端就进入了 <code>TIME-WAIT</code> 状态。注意此时客户端到 TCP 连接还没有释放，必须经过 2*MSL（最长报文段生命周期）的时间后，才进入 <code>CLOSED</code> 状态。而服务端只要收到客户端发出的确认，就立即进入 <code>CLOSED</code> 状态。可以看到，服务端结束 TCP 连接的时间要比客户端早一些。</p>
<p>TCP 规定，<code>[FIN/ACK]</code> 包即使没有传送数据，也会消耗掉一个序列号。<code>[FIN/ACK]</code> 包是第一、三次挥手：</p>
<ol>
<li>第一次挥手时，客户端的序列号 seq = X，消耗一个序列号。因此：
<ol>
<li>第二次挥手时，服务端的确认号 ack = X + 1</li>
<li>第四次挥手时，客户端的序列号 seq = X + 1</li>
</ol>
</li>
<li>第三次挥手时，服务端的序列号 seq = w，消耗一个序列号。因此：
<ol>
<li>第四次挥手时，客户端的确认号 ack = w + 1</li>
</ol>
</li>
</ol>
<h2 id="为什么第四次挥手客户端的-time-wait-状态必须等待-2msl-的时间才能返回到-closed-状态">为什么第四次挥手，客户端的 TIME-WAIT 状态必须等待 2MSL 的时间才能返回到 CLOSED 状态？</h2>
<p>为什么四次挥手——&gt;因为 <strong>TCP 是全双工的</strong>，一方关闭连接后，另一方还可以继续发送数据。所以四次挥手，将断开连接分成两个独立的过程。</p>
<p>2MSL——&gt;主要有两个原因：</p>
<p>(1) 确保 ACK 报文能够到达服务端，从而使服务端正常关闭连接。</p>
<p>第四次挥手时，客户端第四次挥手的 ACK 报文不一定会到达服务端。服务端会超时重传 FIN/ACK 报文，此时如果客户端已经断开了连接，那么就无法响应服务端的二次请求，这样服务端迟迟收不到 FIN/ACK 报文的确认，就无法正常断开连接。</p>
<p>MSL 是报文段在网络上存活的最长时间。客户端等待 2MSL 时间，即「客户端 ACK 报文 1MSL 超时 + 服务端 FIN 报文 1MSL 传输」，就能够收到服务端重传的 FIN/ACK 报文，然后客户端重传一次 ACK 报文，并重新启动 2MSL 计时器。如此保证服务端能够正常关闭。</p>
<p>那如果服务端重发的 FIN 没有成功地在 2MSL 时间里传给客户端，会怎样？服务端会继续超时重试直到断开连接，见下文。</p>
<p>(2) 防止已失效的连接请求报文段出现在之后的连接中。</p>
<p>TCP 要求在 2MSL 内不使用相同的序列号。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以保证本连接持续的时间内产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。或者即使收到这些过时的报文，也可以不处理它。</p>
<h2 id="如果已经建立了连接但是客户端出现故障了怎么办">如果已经建立了连接，但是客户端出现故障了怎么办？</h2>
<p>或者说，如果三次握手阶段、四次挥手阶段的包丢失了怎么办？比如上面描述的“服务端重发 FIN”的问题。</p>
<p>简而言之，通过<strong>定时器 + 超时重试机制</strong>，尝试获取确认，直到最后会自动断开连接。</p>
<p>具体而言，TCP 设有一个保活计时器。服务器每收到一次客户端的数据，都会重新复位这个计时器，时间通常是设置为 2 小时。若 2 小时还没有收到客户端的任何数据，服务器就开始重试：每隔 75 分钟发送一个探测报文段，若一连发送 10 个探测报文后客户端依然没有回应，那么服务器就认为连接已经断开了。</p>
<h2 id="tcp-的粘包问题">TCP 的粘包问题</h2>
<p>TCP 是基于字节流的，数据块是没有边界、没有结构的字节流，因此可能产生粘包：</p>
<ol>
<li>
<p>发送方为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小、数据量小的数据包，合并成一个大的数据包一次性发送。</p>
<p>当应用层协议通过 TCP 协议传输数据时，实际上待发送的数据先被写入了 TCP 协议的缓冲区，如果用户开启了 Nagle 算法，那么 TCP 协议可能不会立刻发送写入的数据，它会等待缓冲区中数据超过最大数据段（MSS）或者上一个数据段被 ACK 时才会发送缓冲区中的数据。</p>
</li>
<li>
<p>接收方不能及时读取数据，导致缓冲区中的多个包粘连。</p>
</li>
</ol>
<p><strong>解决方法</strong>：</p>
<ol>
<li>发送方关闭 Nagle 算法</li>
<li>应用层定义消息边界，最常见的两种解决方案就是基于长度或者基于终结符（Delimiter）
<ol>
<li>基于长度的实现有两种方式，一种是使用固定长度；另一种方式是使用不固定长度，但是需要在应用层协议的协议头中增加表示负载长度的字段，HTTP 协议的消息边界就是基于长度实现的</li>
<li>HTTP 协议除了使用基于长度的方式实现边界，也会使用基于终结符的策略，当 HTTP 使用块传输（Chunked Transfer）机制时，HTTP 头中就不再包含 Content-Length 了，它会使用负载大小为 0 的 HTTP 消息作为终结符表示消息的边界</li>
</ol>
</li>
</ol>
<p>除了这两种方式之外，我们可以基于特定的规则实现消息的边界，例如：使用 TCP 协议发送 JSON 数据，接收方可以根据接收到的数据是否能够被解析成合法的 JSON 判断消息是否终结。</p>
<p>但值得注意的是，<strong>粘包并不是 TCP 协议本身的“问题”，而是一个“现象”</strong>。TCP 本身面向字节流的特性，导致会有所谓的“粘包”问题，需要应用层进行拆分。所以也有一种说法是“TCP 粘包是一个伪命题”。</p>
<p>**为什么 UDP 协议没有粘包问题？**UDP 是面向报文的，应用层交给 UDP 多长的报文，UDP 就照样发送，既不合并，也不拆分，而是保留这些报文的边界。</p>
<h2 id="tcp-如何保证传输的可靠性">TCP 如何保证传输的可靠性？</h2>
<ol>
<li>序列号：解决乱序问题</li>
<li>确认号 / 超时重传机制：解决丢包问题</li>
</ol>
<h2 id="tcp-udp-对比">TCP、UDP 对比</h2>
<ol>
<li>TCP：面向连接的、可靠的、基于字节流的传输层通信协议</li>
<li>UDP：无连接的、不可靠的、基于报文的传输层通信协议</li>
<li>面向字节流：TCP 将要发送的数据视为无结构的字节流，如果发送的数据太长，就拆分发送，如果发送的数据太短，则积累较多的字节后再发送</li>
<li>面向报文：UDP 一次发送一个报文，不管多大，都以报文为发送单位</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody>
<tr>
<td>连接性</td>
<td>面向连接</td>
<td>无连接</td>
</tr>
<tr>
<td>可靠性</td>
<td>可靠</td>
<td>不可靠</td>
</tr>
<tr>
<td>传输方式</td>
<td>面向字节流</td>
<td>面向报文（保留报文的边界）</td>
</tr>
<tr>
<td>传输速度</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>双工性</td>
<td>全双工</td>
<td>一对一、一对多、多对一、多对多</td>
</tr>
<tr>
<td>流量控制 / 拥塞控制</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>应用场景</td>
<td>对效率要求相对低，但是对准确性要求高的场景；或是要求有连接的场景。如文件传输、发送邮件等</td>
<td>对效率要求相对高，对准确性要求相对低的场景。如即时通信、直播等</td>
</tr>
<tr>
<td>应用层协议</td>
<td>SMTP（电子邮件）、TELNET（远程登录控制）、HTTP、FTP</td>
<td>DNS、TFTP（文件传输）、DHCP（动态主机配置）...</td>
</tr>
</tbody>
</table>
<h2 id="http-请求方法">HTTP 请求方法</h2>
<p>HTTP 请求方法表明了要对给定资源执行的<strong>操作</strong>，每一个请求方法都实现了不同的<strong>语义</strong>。包括：GET、HEAD、POST、PUT、PATCH、DELETE、OPTIONS，以及不常用的 CONNECT、TRACE。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>获取数据</td>
</tr>
<tr>
<td>HEAD</td>
<td>与 <code>GET</code> 类似，但<strong>只返回响应头</strong></td>
</tr>
<tr>
<td>POST</td>
<td>提交表单</td>
</tr>
<tr>
<td>PUT</td>
<td>用一个新的资源<strong>完全替换</strong>掉服务器的资源</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除资源</td>
</tr>
<tr>
<td>CONNECT</td>
<td>建立一个 tunnel</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>询问服务器支持哪些方法</td>
</tr>
<tr>
<td>TRACE</td>
<td>发起环回诊断，主要用于诊断</td>
</tr>
<tr>
<td>PATCH</td>
<td>对服务器资源进行<strong>部分更新</strong></td>
</tr>
</tbody>
</table>
<h2 id="get-和-post-的区别">GET 和 POST 的区别</h2>
<table>
<thead>
<tr>
<th></th>
<th>GET</th>
<th>POST</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用</td>
<td>获取服务器的指定数据</td>
<td>添加 / 修改服务器的数据</td>
</tr>
<tr>
<td>历史记录 / 书签</td>
<td>可保留在浏览器历史记录中，或者收藏为书签</td>
<td>不可以</td>
</tr>
<tr>
<td>Cacheable</td>
<td>会被浏览器缓存</td>
<td>不会缓存</td>
</tr>
<tr>
<td>幂等</td>
<td>幂等，不会改变服务器上的资源</td>
<td>非幂等，会对服务器资源进行改变</td>
</tr>
<tr>
<td>后退 / 刷新</td>
<td>后退或刷新时，GET 是无害的</td>
<td>后退或刷新时，POST 会重新提交表单</td>
</tr>
<tr>
<td>参数位置</td>
<td>query 中（直接明文暴露在链接中）</td>
<td>query 或 body 中</td>
</tr>
<tr>
<td>参数长度</td>
<td>2KB（2048 个字符）</td>
<td>无限制</td>
</tr>
</tbody>
</table>
<h2 id="cookie-与-session-的区别">Cookie 与 Session 的区别</h2>
<p>二者都是用来跟踪浏览器用户身份的会话方式。</p>
<p>Cookie：</p>
<ol>
<li>存在浏览器里，可以设置过期时间</li>
<li>每次访问服务器时，浏览器会自动在 header 中携带 cookie</li>
<li>如果浏览器禁用了 cookie，可以使用 <strong>URL 重写机制</strong>，将信息保存在 URL 里</li>
</ol>
<p>Session:</p>
<ol>
<li>存在服务端，由服务器维护，一段时间后 session 就失效了</li>
<li><strong>本质上，session 还是通过 cookie 实现的</strong>。浏览器的 cookie 中只保存一个 <code>sessionId</code>，所有其他信息均保存在服务端，由 <code>sessionId</code> 标识</li>
<li>Session 失效，其实是服务器设置了失效时间。如果用户长时间不和服务器交互（比如 30 分钟），那么 session 就会被销毁；交互的话，就会刷新 session</li>
</ol>
<h2 id="从输入一个-url-到页面加载完成的过程">从输入一个 URL 到页面加载完成的过程</h2>
<img src="/Users/qlzhou/Desktop/C.png" alt="C" style="zoom:87%;" />
<ol>
<li>用户在某个标签页输入 URL 并回车后，浏览器主进程会新开一个网络线程，发起 HTTP 请求</li>
<li>浏览器会进行 DNS 查询，将域名解析为 IP 地址</li>
<li>浏览器获得 IP 地址后，向服务器请求建立 TCP 连接</li>
<li>浏览器向服务器发起 HTTP 请求</li>
<li>服务器处理请求，返回 HTTP 响应</li>
<li>浏览器的渲染进程解析并绘制页面</li>
<li>如果遇到 JS/CSS/图片 等静态资源的引用链接，重复上述过程，向服务器请求这些资源</li>
</ol>
<h2 id="介绍一下-http-协议">介绍一下 HTTP 协议</h2>
<p>HTTP 协议是<strong>基于 TCP 协议</strong>实现的，它是一个<strong>超文本传输协议</strong>，其实就是一个简单的请求-响应协议，它<strong>指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应</strong>。</p>
<p>它主要是<strong>负责点对点之间通信</strong>的。</p>
<p><strong>超文本</strong>就是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本。比如说html，内部定义了很多图片视频的链接，放在浏览器上就呈现出了画面。</p>
<p><strong>协议</strong>就是约定俗称的东西，比如说 moon 要给读者送一本书，读者那里只接受顺丰快递，那么 moon 觉得可以，发快递的时候选择的顺丰，那么我们彼此之间共同约定好的就叫做协议。</p>
<p><strong>传输</strong>这个就很好理解了，比如刚才举的例子，将书发给读者，要通过骑车或者飞机的方式，传递的这个过程就是运输。</p>
<h2 id="get-和-post有什么区别">GET 和 POST有什么区别？</h2>
<p><strong>GET 和 POST 本质上就是 TCP 链接，并无差别。</strong></p>
<p><strong>但是由于 HTTP 的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">区别</th>
<th style="text-align:center">GET</th>
<th style="text-align:right">POST</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">数据传输方式</td>
<td style="text-align:center">从服务器获取数据</td>
<td style="text-align:right">向服务器提交数据</td>
</tr>
<tr>
<td style="text-align:left">对数据长度的限制</td>
<td style="text-align:center">当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）</td>
<td style="text-align:right">无限制</td>
</tr>
<tr>
<td style="text-align:left">对数据类型的限制</td>
<td style="text-align:center">只允许 ASCII 字符</td>
<td style="text-align:right">无限制</td>
</tr>
<tr>
<td style="text-align:left">安全性</td>
<td style="text-align:center">较差，所发送的数据是 URL 的一部分，会显示在网页上</td>
<td style="text-align:right">较好 参数不会被保存在浏览器历史或 WEB 服务器日志中</td>
</tr>
<tr>
<td style="text-align:left">可见性</td>
<td style="text-align:center">显示在 URL 上</td>
<td style="text-align:right">不显示</td>
</tr>
<tr>
<td style="text-align:left">收藏为书签</td>
<td style="text-align:center">可以</td>
<td style="text-align:right">不可以</td>
</tr>
<tr>
<td style="text-align:left">历史记录</td>
<td style="text-align:center">可以被保留在历史记录当中</td>
<td style="text-align:right">不可以被保留</td>
</tr>
<tr>
<td style="text-align:left">缓存</td>
<td style="text-align:center">能被缓存</td>
<td style="text-align:right">不可以被缓存</td>
</tr>
</tbody>
</table>
<h2 id="ping-的作用">PING 的作用？</h2>
<p>PING 主要的作用就是<strong>测试在两台主机之间能否建立连接</strong>，如果 PING 不通就无法建立连接。</p>
<p>它其实就是向目的主机发送多个 ICMP 回送请求报文</p>
<ol>
<li>如果没有响应则无法建立连接</li>
<li>如果有响应就可以根据目的主机返回的回送报文的时间和成功响应的次数估算出数据包<strong>往返时间及丢包率</strong></li>
</ol>
<h2 id="http11-和-http10-的区别有哪些">HTTP1.1 和 HTTP1.0 的区别有哪些？</h2>
<img src="/Users/qlzhou/Desktop/D.png" alt="D" style="zoom:67%;" />
<ol>
<li>
<p><strong>长链接</strong></p>
<ol>
<li>早期 HTTP1.0 的每一次请求都伴随着一次三次握手的过程，并且是<strong>串行的请求</strong>，增加了不必要的性能开销</li>
<li>HTTP1.1 <strong>新增了长链接</strong>的通讯方式，减少了性能损耗</li>
</ol>
</li>
<li>
<p><strong>管道</strong></p>
<ol>
<li>HTTP1.0 只有串行发送，没有管道</li>
<li>HTTP1.1 增加了<strong>管道</strong>的概念，使得在同一个 TCP 链接当中可以同时发出多个请求</li>
</ol>
</li>
<li>
<p><strong>断点续传</strong></p>
<ol>
<li>HTTP1.0 <strong>不支持断点续传</strong></li>
<li>HTTP1.1 新增了 <strong>range</strong> 字段，用来指定数据字节位置，开启了断点续传的时代</li>
</ol>
</li>
<li>
<p><strong>Host头处理</strong></p>
<ol>
<li>HTTP1.0 任务主机只有一个节点，所以并<strong>没有传 HOST</strong></li>
<li>HTTP1.1 时代，虚拟机技术越来越发达，一台机器上也有可能有很多节点，故<strong>增加了 HOST 信息</strong></li>
</ol>
</li>
<li>
<p><strong>缓存处理</strong></p>
<ol>
<li>在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准</li>
<li>HTTP1.1则<strong>引入了更多的缓存控制策略</strong>例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>
</ol>
</li>
<li>
<p><strong>错误状态响应码</strong></p>
<ol>
<li>在HTTP1.1中<strong>新增了24个错误状态响应码</strong>，如410（Gone）表示服务器上的某个资源被永久性的删除等。</li>
</ol>
</li>
</ol>
<h2 id="https-和-http-的区别是什么">HTTPS 和 HTTP 的区别是什么？</h2>
<img src="/Users/qlzhou/Desktop/E.png" alt="E" style="zoom:67%;" />
<ol>
<li>
<p><strong>SSL安全协议</strong></p>
<p>HTTP 是超⽂本传输协议，信息是<strong>明⽂传输</strong>，存在安全⻛险的问题。</p>
<p>HTTPS 则解决 HTTP 不安全的缺陷，在TCP 和 HTTP ⽹络层之间加⼊了 SSL/TLS 安全协议，使得报⽂能够<strong>加密传输</strong>。</p>
</li>
<li>
<p><strong>建立连接</strong></p>
<p>HTTP 连接建⽴相对简单， TCP <strong>三次握⼿</strong>之后便可进⾏ HTTP 的报⽂传输。</p>
<p>HTTPS 在 TCP <strong>三次握⼿</strong>之后，还需进⾏ <strong>SSL/TLS</strong> 的<strong>握⼿</strong>过程，才可进⼊加密报⽂传输。</p>
</li>
<li>
<p><strong>端口号</strong></p>
<p>HTTP 的端⼝号是 <strong>80</strong>。</p>
<p>HTTPS 的端⼝号是 <strong>443</strong>。</p>
</li>
<li>
<p><strong>CA证书</strong></p>
<p>*HTTPS 协议需要向 CA（证书权威。机构）申请数字证书**来保证服务器的身份是可信的。</p>
</li>
</ol>
<h2 id="http2-和-http11-的区别是什么">HTTP2 和 HTTP1.1 的区别是什么？</h2>
<img src="/Users/qlzhou/Desktop/G.png" alt="G" style="zoom:67%;" />
<ol>
<li>
<p><strong>头部压缩</strong></p>
<ol>
<li>在 HTTP2 当中，如果你发出了<strong>多个请求</strong>，并且它们的<strong>头部(header)是相同的</strong>，那么 HTTP2 协议会帮你<strong>消除同样的部分</strong>。(其实就是在客户端和服务端维护一张索引表来实现)</li>
</ol>
</li>
<li>
<p><strong>二进制格式</strong></p>
<p>HTTP1.1 采用<strong>明文</strong>的形式</p>
<p>HTTP/2 全⾯采⽤了<strong>⼆进制格式</strong>，头信息和数据体都是⼆进制</p>
</li>
<li>
<p><strong>数据流</strong></p>
<p>HTTP/2 的数据包不是按顺序发送的，同⼀个连接⾥⾯连续的数据包，可能属于不同的回应。(对数据包做了标记，标志其属于哪一个请求，其中规定客户端发出的数据流编号为奇数，服务器发出的数据流编号为偶数。<strong>客户端还可以指定数据流的优先级</strong>，优先级⾼的请求，服务器就先响应该请求)</p>
</li>
<li>
<p><strong>IO多路复用</strong></p>
<p>如:在⼀个连接中，服务器收到了客户端 A 和 B 的两个请求，但是发现在处理 A 的过程中⾮常耗时，索性就先回应 A 已经处理好的部分，再接着回应 B 请求，最后再回应 A 请求剩下的部分。</p>
<p>HTTP/2 可以<strong>在⼀个连接中并发多个请求或回应</strong>。</p>
</li>
<li>
<p><strong>服务器推送</strong></p>
<p>服务器可以主动向客户端发送请求</p>
</li>
</ol>
<h2 id="http2与http1相比改进在哪为什么会更快">HTTP/2与HTTP/1相比，改进在哪？为什么会更快？</h2>
<p>主要的改进包括：</p>
<ol>
<li>多路复用，允许通过单一的HTTP/2连接发起多重的请求-响应消息。而HTTP/1.1协议中，<br>
浏览器客户端在同一时间内，针对同一域名下的请求数量有一定的数量限制。超过限制数目<br>
的请求会被阻塞。(解决办法：CDN使用多个域名)</li>
<li>二进制分帧，HTTP/2会将所有传输的信息分割成更小的消息和帧，并对他们采用二进制<br>
格式的编码，其中HTTP/1.1中的首部信息会被封装到HEADER frame，而body则会封装进<br>
DATA frame。头部进行压缩，使用<a href="https://www.jianshu.com/p/f44b930cfcac">HPACK</a>算法。</li>
</ol>
<h2 id="http3-和-http2-的区别是什么">HTTP3 和 HTTP2 的区别是什么？</h2>
<img src="/Users/qlzhou/Desktop/H.png" alt="H" style="zoom:67%;" />
<ol>
<li>
<p><strong>协议不同</strong></p>
<p>HTTP2 是基于 <strong>TCP</strong> 协议实现的</p>
<p>HTTP3 是基于 <strong>UDP</strong> 协议实现的</p>
</li>
<li>
<p><strong>QUIC</strong></p>
<p>HTTP3 新增了 QUIC 协议**来实现可靠性的传输</p>
</li>
<li>
<p><strong>握手次数</strong></p>
<p>HTTP2 是基于 HTTPS 实现的，建立连接需要先进行 TCP 3次握手，然后再进行 TLS 3次握手，<strong>总共6次握手</strong></p>
<p>HTTP3 只需要 QUIC 的<strong>3次握手</strong></p>
</li>
</ol>
<h2 id="tcp-半连接队列和全连接队列是什么">TCP 半连接队列和全连接队列是什么？</h2>
<img src="/Users/qlzhou/Desktop/AA.png" alt="AA" style="zoom:67%;" />
<p>服务端收到客户端发出的 SYN 请求后，会把这个连接信息存储到<strong>半链接队列(SYN 队列)</strong>。</p>
<p>服务端收到第三次握⼿的 ACK 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到<strong>全连接队列</strong>(accept 队列)，等待进程调⽤ accept 函数时把连接取出来。</p>
<p>这两个队列都是有大小限制的，当超过容量后就会将链接丢弃，或者返回 RST 包。</p>
<h2 id="粘包拆包是怎么发生的怎么解决这个问题">粘包/拆包是怎么发生的？怎么解决这个问题？</h2>
<p>TCP 发送数据时会根据 TCP 缓冲区的实际情况进行包的划分，一个完整的包<strong>可能会被 TCP 拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送</strong>，这就是 TCP 粘包和拆包问题。</p>
<img src="/Users/qlzhou/Desktop/BB.png" alt="BB" style="zoom:67%;" />
<p>发生 TCP <strong>粘包</strong>的<strong>原因</strong>:<br>
1. <strong>发送的数据小于 TCP 缓冲区大小</strong>，TCP将缓冲区中的数据(数据属于多条业务内容)一次发送出去可能就会发生粘包。<br>
2. 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</p>
<p>发生 TCP <strong>拆包</strong>的<strong>原因</strong>:<br>
1. <strong>待发送数据大于最大报文长度</strong>，TCP 在传输前将进行拆包。<br>
2. <strong>发送的数据大于 TCP 发送缓冲区剩余空间大小</strong>，将会发生拆包。</p>
<p><strong>解决方案</strong>:</p>
<figure data-type="image" tabindex="4"><img src="/Users/qlzhou/Desktop/CC.png" alt="CC" loading="lazy"></figure>
<ol>
<li><strong>发送端给每个数据包添加包首部</strong>，首部中包含数据包的长度，这样接收端在接收到数据后，通过该字段就可以知道每个数据包的实际长度了。</li>
<li>发送端将每个数据包<strong>设置固定长度</strong>，这样接收端每次从读取固定长度的数据把每个数据包拆分开。</li>
<li>可以在数据包之间<strong>设置边界</strong>，如添加特殊符号，接收端可以通过这个特殊符号来拆分包。</li>
</ol>
<h2 id="浏览器地址栏输入网站按回车后发生了什么">浏览器地址栏输入网站按回车后发生了什么？</h2>
<img src="/Users/qlzhou/Desktop/DD.png" alt="DD" style="zoom:67%;" />
<ol>
<li><strong>解析网址</strong>,生成 HTTP 请求信息</li>
<li>根据 DNS 服务器<strong>查询真实请求的 IP 地址</strong>，如果本地服务器有缓存则直接返回</li>
<li>得到了 IP 以后，向服务器<strong>发送 TCP 连接</strong>，TCP 连接经过三次握手。</li>
<li>接受 TCP 报文后，对<strong>连接进行处理</strong>，对 HTTP 协议解析</li>
<li>服务器<strong>返回响应</strong></li>
<li><em>浏览器*<em>接受响应，显示页面，渲染页面*</em></em>*</li>
</ol>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://flyingchase.github.io/post/golang-dui-zhan-yu-tao-yi-fen-xi/">
              <h3 class="post-title">
                下一篇：【Golang】堆栈与逃逸分析
              </h3>
            </a>
          </div>
          
      </div>

      

      <div class="site-footer">
  <div class="slogan">一两黄金一两风</div>
  <div class="social-container">
    
      
        <a href="https://github.com/flyingchase" target="_blank">
          <i class="fab fa-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
   | <a class="rss" href="https://flyingchase.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
